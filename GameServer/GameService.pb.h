// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GameService.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_GameService_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_GameService_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_GameService_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_GameService_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[49]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_GameService_2eproto;
namespace protocol {
class Attack;
struct AttackDefaultTypeInternal;
extern AttackDefaultTypeInternal _Attack_default_instance_;
class CAllUpdateMail;
struct CAllUpdateMailDefaultTypeInternal;
extern CAllUpdateMailDefaultTypeInternal _CAllUpdateMail_default_instance_;
class CAttack;
struct CAttackDefaultTypeInternal;
extern CAttackDefaultTypeInternal _CAttack_default_instance_;
class CBuyCharater;
struct CBuyCharaterDefaultTypeInternal;
extern CBuyCharaterDefaultTypeInternal _CBuyCharater_default_instance_;
class CBuyWeapon;
struct CBuyWeaponDefaultTypeInternal;
extern CBuyWeaponDefaultTypeInternal _CBuyWeapon_default_instance_;
class CFriend;
struct CFriendDefaultTypeInternal;
extern CFriendDefaultTypeInternal _CFriend_default_instance_;
class CLoad;
struct CLoadDefaultTypeInternal;
extern CLoadDefaultTypeInternal _CLoad_default_instance_;
class CLoadMail;
struct CLoadMailDefaultTypeInternal;
extern CLoadMailDefaultTypeInternal _CLoadMail_default_instance_;
class CMovePotal;
struct CMovePotalDefaultTypeInternal;
extern CMovePotalDefaultTypeInternal _CMovePotal_default_instance_;
class CPlayerAim;
struct CPlayerAimDefaultTypeInternal;
extern CPlayerAimDefaultTypeInternal _CPlayerAim_default_instance_;
class CPlayerJump;
struct CPlayerJumpDefaultTypeInternal;
extern CPlayerJumpDefaultTypeInternal _CPlayerJump_default_instance_;
class CSellItems;
struct CSellItemsDefaultTypeInternal;
extern CSellItemsDefaultTypeInternal _CSellItems_default_instance_;
class CSendMail;
struct CSendMailDefaultTypeInternal;
extern CSendMailDefaultTypeInternal _CSendMail_default_instance_;
class CUpdateAccount;
struct CUpdateAccountDefaultTypeInternal;
extern CUpdateAccountDefaultTypeInternal _CUpdateAccount_default_instance_;
class CUpdateItems;
struct CUpdateItemsDefaultTypeInternal;
extern CUpdateItemsDefaultTypeInternal _CUpdateItems_default_instance_;
class CUpdateMail;
struct CUpdateMailDefaultTypeInternal;
extern CUpdateMailDefaultTypeInternal _CUpdateMail_default_instance_;
class Charater;
struct CharaterDefaultTypeInternal;
extern CharaterDefaultTypeInternal _Charater_default_instance_;
class CreateCharacter;
struct CreateCharacterDefaultTypeInternal;
extern CreateCharacterDefaultTypeInternal _CreateCharacter_default_instance_;
class DLoad;
struct DLoadDefaultTypeInternal;
extern DLoadDefaultTypeInternal _DLoad_default_instance_;
class Demage;
struct DemageDefaultTypeInternal;
extern DemageDefaultTypeInternal _Demage_default_instance_;
class Friend;
struct FriendDefaultTypeInternal;
extern FriendDefaultTypeInternal _Friend_default_instance_;
class ItemEquip;
struct ItemEquipDefaultTypeInternal;
extern ItemEquipDefaultTypeInternal _ItemEquip_default_instance_;
class ItemEtc;
struct ItemEtcDefaultTypeInternal;
extern ItemEtcDefaultTypeInternal _ItemEtc_default_instance_;
class Login;
struct LoginDefaultTypeInternal;
extern LoginDefaultTypeInternal _Login_default_instance_;
class LoginAccess;
struct LoginAccessDefaultTypeInternal;
extern LoginAccessDefaultTypeInternal _LoginAccess_default_instance_;
class Mail;
struct MailDefaultTypeInternal;
extern MailDefaultTypeInternal _Mail_default_instance_;
class MailEquipItem;
struct MailEquipItemDefaultTypeInternal;
extern MailEquipItemDefaultTypeInternal _MailEquipItem_default_instance_;
class MailEtcItem;
struct MailEtcItemDefaultTypeInternal;
extern MailEtcItemDefaultTypeInternal _MailEtcItem_default_instance_;
class Position;
struct PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class SBuyResult;
struct SBuyResultDefaultTypeInternal;
extern SBuyResultDefaultTypeInternal _SBuyResult_default_instance_;
class SChat;
struct SChatDefaultTypeInternal;
extern SChatDefaultTypeInternal _SChat_default_instance_;
class SClosePlayer;
struct SClosePlayerDefaultTypeInternal;
extern SClosePlayerDefaultTypeInternal _SClosePlayer_default_instance_;
class SCurrentInfo;
struct SCurrentInfoDefaultTypeInternal;
extern SCurrentInfoDefaultTypeInternal _SCurrentInfo_default_instance_;
class SEndGame;
struct SEndGameDefaultTypeInternal;
extern SEndGameDefaultTypeInternal _SEndGame_default_instance_;
class SExpLv;
struct SExpLvDefaultTypeInternal;
extern SExpLvDefaultTypeInternal _SExpLv_default_instance_;
class SFriendSystem;
struct SFriendSystemDefaultTypeInternal;
extern SFriendSystemDefaultTypeInternal _SFriendSystem_default_instance_;
class SInsertplayer;
struct SInsertplayerDefaultTypeInternal;
extern SInsertplayerDefaultTypeInternal _SInsertplayer_default_instance_;
class SLoad;
struct SLoadDefaultTypeInternal;
extern SLoadDefaultTypeInternal _SLoad_default_instance_;
class SLoadInventory;
struct SLoadInventoryDefaultTypeInternal;
extern SLoadInventoryDefaultTypeInternal _SLoadInventory_default_instance_;
class SMove;
struct SMoveDefaultTypeInternal;
extern SMoveDefaultTypeInternal _SMove_default_instance_;
class SPlayerData;
struct SPlayerDataDefaultTypeInternal;
extern SPlayerDataDefaultTypeInternal _SPlayerData_default_instance_;
class SRoomQuest;
struct SRoomQuestDefaultTypeInternal;
extern SRoomQuestDefaultTypeInternal _SRoomQuest_default_instance_;
class SSendMail;
struct SSendMailDefaultTypeInternal;
extern SSendMailDefaultTypeInternal _SSendMail_default_instance_;
class SUnitDemage;
struct SUnitDemageDefaultTypeInternal;
extern SUnitDemageDefaultTypeInternal _SUnitDemage_default_instance_;
class SUnitStates;
struct SUnitStatesDefaultTypeInternal;
extern SUnitStatesDefaultTypeInternal _SUnitStates_default_instance_;
class Unit;
struct UnitDefaultTypeInternal;
extern UnitDefaultTypeInternal _Unit_default_instance_;
class UnitState;
struct UnitStateDefaultTypeInternal;
extern UnitStateDefaultTypeInternal _UnitState_default_instance_;
class UpdateInventory;
struct UpdateInventoryDefaultTypeInternal;
extern UpdateInventoryDefaultTypeInternal _UpdateInventory_default_instance_;
class UserAttack;
struct UserAttackDefaultTypeInternal;
extern UserAttackDefaultTypeInternal _UserAttack_default_instance_;
}  // namespace protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::protocol::Attack* Arena::CreateMaybeMessage<::protocol::Attack>(Arena*);
template<> ::protocol::CAllUpdateMail* Arena::CreateMaybeMessage<::protocol::CAllUpdateMail>(Arena*);
template<> ::protocol::CAttack* Arena::CreateMaybeMessage<::protocol::CAttack>(Arena*);
template<> ::protocol::CBuyCharater* Arena::CreateMaybeMessage<::protocol::CBuyCharater>(Arena*);
template<> ::protocol::CBuyWeapon* Arena::CreateMaybeMessage<::protocol::CBuyWeapon>(Arena*);
template<> ::protocol::CFriend* Arena::CreateMaybeMessage<::protocol::CFriend>(Arena*);
template<> ::protocol::CLoad* Arena::CreateMaybeMessage<::protocol::CLoad>(Arena*);
template<> ::protocol::CLoadMail* Arena::CreateMaybeMessage<::protocol::CLoadMail>(Arena*);
template<> ::protocol::CMovePotal* Arena::CreateMaybeMessage<::protocol::CMovePotal>(Arena*);
template<> ::protocol::CPlayerAim* Arena::CreateMaybeMessage<::protocol::CPlayerAim>(Arena*);
template<> ::protocol::CPlayerJump* Arena::CreateMaybeMessage<::protocol::CPlayerJump>(Arena*);
template<> ::protocol::CSellItems* Arena::CreateMaybeMessage<::protocol::CSellItems>(Arena*);
template<> ::protocol::CSendMail* Arena::CreateMaybeMessage<::protocol::CSendMail>(Arena*);
template<> ::protocol::CUpdateAccount* Arena::CreateMaybeMessage<::protocol::CUpdateAccount>(Arena*);
template<> ::protocol::CUpdateItems* Arena::CreateMaybeMessage<::protocol::CUpdateItems>(Arena*);
template<> ::protocol::CUpdateMail* Arena::CreateMaybeMessage<::protocol::CUpdateMail>(Arena*);
template<> ::protocol::Charater* Arena::CreateMaybeMessage<::protocol::Charater>(Arena*);
template<> ::protocol::CreateCharacter* Arena::CreateMaybeMessage<::protocol::CreateCharacter>(Arena*);
template<> ::protocol::DLoad* Arena::CreateMaybeMessage<::protocol::DLoad>(Arena*);
template<> ::protocol::Demage* Arena::CreateMaybeMessage<::protocol::Demage>(Arena*);
template<> ::protocol::Friend* Arena::CreateMaybeMessage<::protocol::Friend>(Arena*);
template<> ::protocol::ItemEquip* Arena::CreateMaybeMessage<::protocol::ItemEquip>(Arena*);
template<> ::protocol::ItemEtc* Arena::CreateMaybeMessage<::protocol::ItemEtc>(Arena*);
template<> ::protocol::Login* Arena::CreateMaybeMessage<::protocol::Login>(Arena*);
template<> ::protocol::LoginAccess* Arena::CreateMaybeMessage<::protocol::LoginAccess>(Arena*);
template<> ::protocol::Mail* Arena::CreateMaybeMessage<::protocol::Mail>(Arena*);
template<> ::protocol::MailEquipItem* Arena::CreateMaybeMessage<::protocol::MailEquipItem>(Arena*);
template<> ::protocol::MailEtcItem* Arena::CreateMaybeMessage<::protocol::MailEtcItem>(Arena*);
template<> ::protocol::Position* Arena::CreateMaybeMessage<::protocol::Position>(Arena*);
template<> ::protocol::SBuyResult* Arena::CreateMaybeMessage<::protocol::SBuyResult>(Arena*);
template<> ::protocol::SChat* Arena::CreateMaybeMessage<::protocol::SChat>(Arena*);
template<> ::protocol::SClosePlayer* Arena::CreateMaybeMessage<::protocol::SClosePlayer>(Arena*);
template<> ::protocol::SCurrentInfo* Arena::CreateMaybeMessage<::protocol::SCurrentInfo>(Arena*);
template<> ::protocol::SEndGame* Arena::CreateMaybeMessage<::protocol::SEndGame>(Arena*);
template<> ::protocol::SExpLv* Arena::CreateMaybeMessage<::protocol::SExpLv>(Arena*);
template<> ::protocol::SFriendSystem* Arena::CreateMaybeMessage<::protocol::SFriendSystem>(Arena*);
template<> ::protocol::SInsertplayer* Arena::CreateMaybeMessage<::protocol::SInsertplayer>(Arena*);
template<> ::protocol::SLoad* Arena::CreateMaybeMessage<::protocol::SLoad>(Arena*);
template<> ::protocol::SLoadInventory* Arena::CreateMaybeMessage<::protocol::SLoadInventory>(Arena*);
template<> ::protocol::SMove* Arena::CreateMaybeMessage<::protocol::SMove>(Arena*);
template<> ::protocol::SPlayerData* Arena::CreateMaybeMessage<::protocol::SPlayerData>(Arena*);
template<> ::protocol::SRoomQuest* Arena::CreateMaybeMessage<::protocol::SRoomQuest>(Arena*);
template<> ::protocol::SSendMail* Arena::CreateMaybeMessage<::protocol::SSendMail>(Arena*);
template<> ::protocol::SUnitDemage* Arena::CreateMaybeMessage<::protocol::SUnitDemage>(Arena*);
template<> ::protocol::SUnitStates* Arena::CreateMaybeMessage<::protocol::SUnitStates>(Arena*);
template<> ::protocol::Unit* Arena::CreateMaybeMessage<::protocol::Unit>(Arena*);
template<> ::protocol::UnitState* Arena::CreateMaybeMessage<::protocol::UnitState>(Arena*);
template<> ::protocol::UpdateInventory* Arena::CreateMaybeMessage<::protocol::UpdateInventory>(Arena*);
template<> ::protocol::UserAttack* Arena::CreateMaybeMessage<::protocol::UserAttack>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace protocol {

enum MessageCode : int {
  LOGIN = 0,
  S_LOAD = 1,
  S_INSERTPLAYER = 2,
  S_MOVE = 3,
  S_CHAT = 4,
  S_PLAYERDATA = 5,
  S_CLOSEPLAYER = 6,
  S_UNITSTATES = 7,
  C_ATTACK = 8,
  S_UNITDEMAGE = 10,
  S_ROOMQUEST = 12,
  C_MOVEPOTAL = 13,
  S_ENDGAME = 14,
  LOGINACCESS = 15,
  C_LOAD = 17,
  CREATECHARACTER = 18,
  UPDATEINVENTROY = 19,
  C_BUYCHARATER = 20,
  C_BUYWEAPON = 21,
  C_UPDATEACCOUNT = 22,
  S_CURRENTINFO = 23,
  S_BUYRESULT = 24,
  C_PLAYERJUMP = 25,
  C_PLAYERAIM = 26,
  S_EXPLV = 27,
  S_LOADINVENTORY = 30,
  C_SELLITEMS = 31,
  S_FRIENDSYSTEM = 32,
  C_FRIEND = 34,
  C_LOADMAIL = 40,
  C_UPDATEMAIL = 41,
  C_ALLUPDATEMAIL = 42,
  C_SENDMAIL = 43,
  S_SENDMAIL = 44,
  C_UPDATEITEMS = 35,
  C_ATTACKS = 100,
  D_LOAD = 101,
  MessageCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MessageCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MessageCode_IsValid(int value);
constexpr MessageCode MessageCode_MIN = LOGIN;
constexpr MessageCode MessageCode_MAX = D_LOAD;
constexpr int MessageCode_ARRAYSIZE = MessageCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageCode_descriptor();
template<typename T>
inline const std::string& MessageCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MessageCode_descriptor(), enum_t_value);
}
inline bool MessageCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageCode>(
    MessageCode_descriptor(), name, value);
}
// ===================================================================

class Login final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Login) */ {
 public:
  inline Login() : Login(nullptr) {}
  ~Login() override;
  explicit constexpr Login(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Login(const Login& from);
  Login(Login&& from) noexcept
    : Login() {
    *this = ::std::move(from);
  }

  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }
  inline Login& operator=(Login&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Login& default_instance() {
    return *internal_default_instance();
  }
  static inline const Login* internal_default_instance() {
    return reinterpret_cast<const Login*>(
               &_Login_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Login& a, Login& b) {
    a.Swap(&b);
  }
  inline void Swap(Login* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Login* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Login* New() const final {
    return new Login();
  }

  Login* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Login>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Login& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Login& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Login* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Login";
  }
  protected:
  explicit Login(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPwdFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string pwd = 2;
  void clear_pwd();
  const std::string& pwd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pwd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pwd();
  PROTOBUF_MUST_USE_RESULT std::string* release_pwd();
  void set_allocated_pwd(std::string* pwd);
  private:
  const std::string& _internal_pwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pwd(const std::string& value);
  std::string* _internal_mutable_pwd();
  public:

  // @@protoc_insertion_point(class_scope:protocol.Login)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pwd_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class CreateCharacter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.CreateCharacter) */ {
 public:
  inline CreateCharacter() : CreateCharacter(nullptr) {}
  ~CreateCharacter() override;
  explicit constexpr CreateCharacter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateCharacter(const CreateCharacter& from);
  CreateCharacter(CreateCharacter&& from) noexcept
    : CreateCharacter() {
    *this = ::std::move(from);
  }

  inline CreateCharacter& operator=(const CreateCharacter& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateCharacter& operator=(CreateCharacter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateCharacter& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateCharacter* internal_default_instance() {
    return reinterpret_cast<const CreateCharacter*>(
               &_CreateCharacter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CreateCharacter& a, CreateCharacter& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateCharacter* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateCharacter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateCharacter* New() const final {
    return new CreateCharacter();
  }

  CreateCharacter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateCharacter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateCharacter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateCharacter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateCharacter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.CreateCharacter";
  }
  protected:
  explicit CreateCharacter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharaterFieldNumber = 1,
  };
  // .protocol.Charater charater = 1;
  bool has_charater() const;
  private:
  bool _internal_has_charater() const;
  public:
  void clear_charater();
  const ::protocol::Charater& charater() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Charater* release_charater();
  ::protocol::Charater* mutable_charater();
  void set_allocated_charater(::protocol::Charater* charater);
  private:
  const ::protocol::Charater& _internal_charater() const;
  ::protocol::Charater* _internal_mutable_charater();
  public:
  void unsafe_arena_set_allocated_charater(
      ::protocol::Charater* charater);
  ::protocol::Charater* unsafe_arena_release_charater();

  // @@protoc_insertion_point(class_scope:protocol.CreateCharacter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::Charater* charater_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class CUpdateAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.CUpdateAccount) */ {
 public:
  inline CUpdateAccount() : CUpdateAccount(nullptr) {}
  ~CUpdateAccount() override;
  explicit constexpr CUpdateAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CUpdateAccount(const CUpdateAccount& from);
  CUpdateAccount(CUpdateAccount&& from) noexcept
    : CUpdateAccount() {
    *this = ::std::move(from);
  }

  inline CUpdateAccount& operator=(const CUpdateAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline CUpdateAccount& operator=(CUpdateAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CUpdateAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const CUpdateAccount* internal_default_instance() {
    return reinterpret_cast<const CUpdateAccount*>(
               &_CUpdateAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CUpdateAccount& a, CUpdateAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(CUpdateAccount* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CUpdateAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CUpdateAccount* New() const final {
    return new CUpdateAccount();
  }

  CUpdateAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CUpdateAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CUpdateAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CUpdateAccount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CUpdateAccount* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.CUpdateAccount";
  }
  protected:
  explicit CUpdateAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharaterTypeFieldNumber = 1,
    kWeaponTypeFieldNumber = 2,
    kUseCashFieldNumber = 3,
  };
  // int32 charaterType = 1;
  void clear_charatertype();
  ::PROTOBUF_NAMESPACE_ID::int32 charatertype() const;
  void set_charatertype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_charatertype() const;
  void _internal_set_charatertype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 weaponType = 2;
  void clear_weapontype();
  ::PROTOBUF_NAMESPACE_ID::int32 weapontype() const;
  void set_weapontype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_weapontype() const;
  void _internal_set_weapontype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 useCash = 3;
  void clear_usecash();
  ::PROTOBUF_NAMESPACE_ID::int32 usecash() const;
  void set_usecash(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_usecash() const;
  void _internal_set_usecash(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.CUpdateAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 charatertype_;
  ::PROTOBUF_NAMESPACE_ID::int32 weapontype_;
  ::PROTOBUF_NAMESPACE_ID::int32 usecash_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class SCurrentInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SCurrentInfo) */ {
 public:
  inline SCurrentInfo() : SCurrentInfo(nullptr) {}
  ~SCurrentInfo() override;
  explicit constexpr SCurrentInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SCurrentInfo(const SCurrentInfo& from);
  SCurrentInfo(SCurrentInfo&& from) noexcept
    : SCurrentInfo() {
    *this = ::std::move(from);
  }

  inline SCurrentInfo& operator=(const SCurrentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCurrentInfo& operator=(SCurrentInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCurrentInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCurrentInfo* internal_default_instance() {
    return reinterpret_cast<const SCurrentInfo*>(
               &_SCurrentInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SCurrentInfo& a, SCurrentInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SCurrentInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCurrentInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SCurrentInfo* New() const final {
    return new SCurrentInfo();
  }

  SCurrentInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SCurrentInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SCurrentInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SCurrentInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCurrentInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SCurrentInfo";
  }
  protected:
  explicit SCurrentInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharaterFieldNumber = 4,
    kCashFieldNumber = 1,
    kCharaterTypeFieldNumber = 2,
    kWeaponTypeFieldNumber = 3,
    kExpFieldNumber = 5,
  };
  // .protocol.Charater charater = 4;
  bool has_charater() const;
  private:
  bool _internal_has_charater() const;
  public:
  void clear_charater();
  const ::protocol::Charater& charater() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Charater* release_charater();
  ::protocol::Charater* mutable_charater();
  void set_allocated_charater(::protocol::Charater* charater);
  private:
  const ::protocol::Charater& _internal_charater() const;
  ::protocol::Charater* _internal_mutable_charater();
  public:
  void unsafe_arena_set_allocated_charater(
      ::protocol::Charater* charater);
  ::protocol::Charater* unsafe_arena_release_charater();

  // int32 cash = 1;
  void clear_cash();
  ::PROTOBUF_NAMESPACE_ID::int32 cash() const;
  void set_cash(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cash() const;
  void _internal_set_cash(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 charaterType = 2;
  void clear_charatertype();
  ::PROTOBUF_NAMESPACE_ID::int32 charatertype() const;
  void set_charatertype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_charatertype() const;
  void _internal_set_charatertype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 weaponType = 3;
  void clear_weapontype();
  ::PROTOBUF_NAMESPACE_ID::int32 weapontype() const;
  void set_weapontype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_weapontype() const;
  void _internal_set_weapontype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 exp = 5;
  void clear_exp();
  ::PROTOBUF_NAMESPACE_ID::int32 exp() const;
  void set_exp(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_exp() const;
  void _internal_set_exp(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SCurrentInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::Charater* charater_;
  ::PROTOBUF_NAMESPACE_ID::int32 cash_;
  ::PROTOBUF_NAMESPACE_ID::int32 charatertype_;
  ::PROTOBUF_NAMESPACE_ID::int32 weapontype_;
  ::PROTOBUF_NAMESPACE_ID::int32 exp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class LoginAccess final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.LoginAccess) */ {
 public:
  inline LoginAccess() : LoginAccess(nullptr) {}
  ~LoginAccess() override;
  explicit constexpr LoginAccess(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginAccess(const LoginAccess& from);
  LoginAccess(LoginAccess&& from) noexcept
    : LoginAccess() {
    *this = ::std::move(from);
  }

  inline LoginAccess& operator=(const LoginAccess& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginAccess& operator=(LoginAccess&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginAccess& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginAccess* internal_default_instance() {
    return reinterpret_cast<const LoginAccess*>(
               &_LoginAccess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LoginAccess& a, LoginAccess& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginAccess* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginAccess* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoginAccess* New() const final {
    return new LoginAccess();
  }

  LoginAccess* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoginAccess>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginAccess& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginAccess& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginAccess* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.LoginAccess";
  }
  protected:
  explicit LoginAccess(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharaterFieldNumber = 2,
    kWeaponListFieldNumber = 6,
    kResultFieldNumber = 1,
    kCurCharaterTypeFieldNumber = 3,
    kCurWeaponTypeFieldNumber = 4,
    kCashFieldNumber = 5,
  };
  // repeated .protocol.Charater charater = 2;
  int charater_size() const;
  private:
  int _internal_charater_size() const;
  public:
  void clear_charater();
  ::protocol::Charater* mutable_charater(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Charater >*
      mutable_charater();
  private:
  const ::protocol::Charater& _internal_charater(int index) const;
  ::protocol::Charater* _internal_add_charater();
  public:
  const ::protocol::Charater& charater(int index) const;
  ::protocol::Charater* add_charater();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Charater >&
      charater() const;

  // repeated int32 weaponList = 6;
  int weaponlist_size() const;
  private:
  int _internal_weaponlist_size() const;
  public:
  void clear_weaponlist();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_weaponlist(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_weaponlist() const;
  void _internal_add_weaponlist(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_weaponlist();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 weaponlist(int index) const;
  void set_weaponlist(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_weaponlist(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      weaponlist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_weaponlist();

  // int32 result = 1;
  void clear_result();
  ::PROTOBUF_NAMESPACE_ID::int32 result() const;
  void set_result(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_result() const;
  void _internal_set_result(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 curCharaterType = 3;
  void clear_curcharatertype();
  ::PROTOBUF_NAMESPACE_ID::int32 curcharatertype() const;
  void set_curcharatertype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_curcharatertype() const;
  void _internal_set_curcharatertype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 curWeaponType = 4;
  void clear_curweapontype();
  ::PROTOBUF_NAMESPACE_ID::int32 curweapontype() const;
  void set_curweapontype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_curweapontype() const;
  void _internal_set_curweapontype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 cash = 5;
  void clear_cash();
  ::PROTOBUF_NAMESPACE_ID::int32 cash() const;
  void set_cash(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cash() const;
  void _internal_set_cash(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.LoginAccess)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Charater > charater_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > weaponlist_;
  mutable std::atomic<int> _weaponlist_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 result_;
  ::PROTOBUF_NAMESPACE_ID::int32 curcharatertype_;
  ::PROTOBUF_NAMESPACE_ID::int32 curweapontype_;
  ::PROTOBUF_NAMESPACE_ID::int32 cash_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class Charater final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Charater) */ {
 public:
  inline Charater() : Charater(nullptr) {}
  ~Charater() override;
  explicit constexpr Charater(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Charater(const Charater& from);
  Charater(Charater&& from) noexcept
    : Charater() {
    *this = ::std::move(from);
  }

  inline Charater& operator=(const Charater& from) {
    CopyFrom(from);
    return *this;
  }
  inline Charater& operator=(Charater&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Charater& default_instance() {
    return *internal_default_instance();
  }
  static inline const Charater* internal_default_instance() {
    return reinterpret_cast<const Charater*>(
               &_Charater_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Charater& a, Charater& b) {
    a.Swap(&b);
  }
  inline void Swap(Charater* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Charater* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Charater* New() const final {
    return new Charater();
  }

  Charater* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Charater>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Charater& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Charater& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Charater* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Charater";
  }
  protected:
  explicit Charater(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kUuidFieldNumber = 1,
    kCodeFieldNumber = 2,
    kLvFieldNumber = 4,
  };
  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 uuid = 1;
  void clear_uuid();
  ::PROTOBUF_NAMESPACE_ID::int32 uuid() const;
  void set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_uuid() const;
  void _internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 code = 2;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 lv = 4;
  void clear_lv();
  ::PROTOBUF_NAMESPACE_ID::int32 lv() const;
  void set_lv(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_lv() const;
  void _internal_set_lv(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Charater)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 uuid_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  ::PROTOBUF_NAMESPACE_ID::int32 lv_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class Position final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Position) */ {
 public:
  inline Position() : Position(nullptr) {}
  ~Position() override;
  explicit constexpr Position(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Position(const Position& from);
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  inline Position& operator=(Position&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Position& default_instance() {
    return *internal_default_instance();
  }
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }
  inline void Swap(Position* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Position* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Position* New() const final {
    return new Position();
  }

  Position* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Position& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Position& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Position";
  }
  protected:
  explicit Position(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kYawFieldNumber = 4,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // float yaw = 4;
  void clear_yaw();
  float yaw() const;
  void set_yaw(float value);
  private:
  float _internal_yaw() const;
  void _internal_set_yaw(float value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Position)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  float z_;
  float yaw_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class Unit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Unit) */ {
 public:
  inline Unit() : Unit(nullptr) {}
  ~Unit() override;
  explicit constexpr Unit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Unit(const Unit& from);
  Unit(Unit&& from) noexcept
    : Unit() {
    *this = ::std::move(from);
  }

  inline Unit& operator=(const Unit& from) {
    CopyFrom(from);
    return *this;
  }
  inline Unit& operator=(Unit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Unit& default_instance() {
    return *internal_default_instance();
  }
  static inline const Unit* internal_default_instance() {
    return reinterpret_cast<const Unit*>(
               &_Unit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Unit& a, Unit& b) {
    a.Swap(&b);
  }
  inline void Swap(Unit* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Unit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Unit* New() const final {
    return new Unit();
  }

  Unit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Unit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Unit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Unit& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Unit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Unit";
  }
  protected:
  explicit Unit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 5,
    kPositionFieldNumber = 4,
    kUuidFieldNumber = 1,
    kHpFieldNumber = 2,
    kCodeFieldNumber = 3,
    kLvFieldNumber = 6,
    kStateFieldNumber = 7,
    kWeaponCodeFieldNumber = 8,
  };
  // string name = 5;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .protocol.Position position = 4;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::protocol::Position& position() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Position* release_position();
  ::protocol::Position* mutable_position();
  void set_allocated_position(::protocol::Position* position);
  private:
  const ::protocol::Position& _internal_position() const;
  ::protocol::Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::protocol::Position* position);
  ::protocol::Position* unsafe_arena_release_position();

  // uint32 uuid = 1;
  void clear_uuid();
  ::PROTOBUF_NAMESPACE_ID::uint32 uuid() const;
  void set_uuid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_uuid() const;
  void _internal_set_uuid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 hp = 2;
  void clear_hp();
  ::PROTOBUF_NAMESPACE_ID::uint32 hp() const;
  void set_hp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_hp() const;
  void _internal_set_hp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // int32 code = 3;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 lv = 6;
  void clear_lv();
  ::PROTOBUF_NAMESPACE_ID::int32 lv() const;
  void set_lv(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_lv() const;
  void _internal_set_lv(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 state = 7;
  void clear_state();
  ::PROTOBUF_NAMESPACE_ID::int32 state() const;
  void set_state(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_state() const;
  void _internal_set_state(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 weaponCode = 8;
  void clear_weaponcode();
  ::PROTOBUF_NAMESPACE_ID::int32 weaponcode() const;
  void set_weaponcode(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_weaponcode() const;
  void _internal_set_weaponcode(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Unit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::protocol::Position* position_;
  ::PROTOBUF_NAMESPACE_ID::uint32 uuid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 hp_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  ::PROTOBUF_NAMESPACE_ID::int32 lv_;
  ::PROTOBUF_NAMESPACE_ID::int32 state_;
  ::PROTOBUF_NAMESPACE_ID::int32 weaponcode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class SLoad final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SLoad) */ {
 public:
  inline SLoad() : SLoad(nullptr) {}
  ~SLoad() override;
  explicit constexpr SLoad(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLoad(const SLoad& from);
  SLoad(SLoad&& from) noexcept
    : SLoad() {
    *this = ::std::move(from);
  }

  inline SLoad& operator=(const SLoad& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLoad& operator=(SLoad&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLoad& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLoad* internal_default_instance() {
    return reinterpret_cast<const SLoad*>(
               &_SLoad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SLoad& a, SLoad& b) {
    a.Swap(&b);
  }
  inline void Swap(SLoad* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLoad* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SLoad* New() const final {
    return new SLoad();
  }

  SLoad* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SLoad>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLoad& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLoad& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLoad* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SLoad";
  }
  protected:
  explicit SLoad(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnitFieldNumber = 1,
    kRoomIdFieldNumber = 3,
  };
  // repeated .protocol.UnitState unit = 1;
  int unit_size() const;
  private:
  int _internal_unit_size() const;
  public:
  void clear_unit();
  ::protocol::UnitState* mutable_unit(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::UnitState >*
      mutable_unit();
  private:
  const ::protocol::UnitState& _internal_unit(int index) const;
  ::protocol::UnitState* _internal_add_unit();
  public:
  const ::protocol::UnitState& unit(int index) const;
  ::protocol::UnitState* add_unit();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::UnitState >&
      unit() const;

  // int32 room_id = 3;
  void clear_room_id();
  ::PROTOBUF_NAMESPACE_ID::int32 room_id() const;
  void set_room_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_room_id() const;
  void _internal_set_room_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SLoad)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::UnitState > unit_;
  ::PROTOBUF_NAMESPACE_ID::int32 room_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class CLoad final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.CLoad) */ {
 public:
  inline CLoad() : CLoad(nullptr) {}
  ~CLoad() override;
  explicit constexpr CLoad(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CLoad(const CLoad& from);
  CLoad(CLoad&& from) noexcept
    : CLoad() {
    *this = ::std::move(from);
  }

  inline CLoad& operator=(const CLoad& from) {
    CopyFrom(from);
    return *this;
  }
  inline CLoad& operator=(CLoad&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CLoad& default_instance() {
    return *internal_default_instance();
  }
  static inline const CLoad* internal_default_instance() {
    return reinterpret_cast<const CLoad*>(
               &_CLoad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CLoad& a, CLoad& b) {
    a.Swap(&b);
  }
  inline void Swap(CLoad* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CLoad* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CLoad* New() const final {
    return new CLoad();
  }

  CLoad* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CLoad>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CLoad& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CLoad& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CLoad* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.CLoad";
  }
  protected:
  explicit CLoad(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 100,
    kUuidFieldNumber = 1,
  };
  // .protocol.Position position = 100;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::protocol::Position& position() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Position* release_position();
  ::protocol::Position* mutable_position();
  void set_allocated_position(::protocol::Position* position);
  private:
  const ::protocol::Position& _internal_position() const;
  ::protocol::Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::protocol::Position* position);
  ::protocol::Position* unsafe_arena_release_position();

  // int32 uuid = 1;
  void clear_uuid();
  ::PROTOBUF_NAMESPACE_ID::int32 uuid() const;
  void set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_uuid() const;
  void _internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.CLoad)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::Position* position_;
  ::PROTOBUF_NAMESPACE_ID::int32 uuid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class SInsertplayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SInsertplayer) */ {
 public:
  inline SInsertplayer() : SInsertplayer(nullptr) {}
  ~SInsertplayer() override;
  explicit constexpr SInsertplayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SInsertplayer(const SInsertplayer& from);
  SInsertplayer(SInsertplayer&& from) noexcept
    : SInsertplayer() {
    *this = ::std::move(from);
  }

  inline SInsertplayer& operator=(const SInsertplayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline SInsertplayer& operator=(SInsertplayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SInsertplayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const SInsertplayer* internal_default_instance() {
    return reinterpret_cast<const SInsertplayer*>(
               &_SInsertplayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SInsertplayer& a, SInsertplayer& b) {
    a.Swap(&b);
  }
  inline void Swap(SInsertplayer* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SInsertplayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SInsertplayer* New() const final {
    return new SInsertplayer();
  }

  SInsertplayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SInsertplayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SInsertplayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SInsertplayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SInsertplayer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SInsertplayer";
  }
  protected:
  explicit SInsertplayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerFieldNumber = 1,
  };
  // .protocol.Unit player = 1;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::protocol::Unit& player() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Unit* release_player();
  ::protocol::Unit* mutable_player();
  void set_allocated_player(::protocol::Unit* player);
  private:
  const ::protocol::Unit& _internal_player() const;
  ::protocol::Unit* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::protocol::Unit* player);
  ::protocol::Unit* unsafe_arena_release_player();

  // @@protoc_insertion_point(class_scope:protocol.SInsertplayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::Unit* player_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class SMove final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SMove) */ {
 public:
  inline SMove() : SMove(nullptr) {}
  ~SMove() override;
  explicit constexpr SMove(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SMove(const SMove& from);
  SMove(SMove&& from) noexcept
    : SMove() {
    *this = ::std::move(from);
  }

  inline SMove& operator=(const SMove& from) {
    CopyFrom(from);
    return *this;
  }
  inline SMove& operator=(SMove&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SMove& default_instance() {
    return *internal_default_instance();
  }
  static inline const SMove* internal_default_instance() {
    return reinterpret_cast<const SMove*>(
               &_SMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SMove& a, SMove& b) {
    a.Swap(&b);
  }
  inline void Swap(SMove* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SMove* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SMove* New() const final {
    return new SMove();
  }

  SMove* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SMove>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SMove& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SMove& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SMove* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SMove";
  }
  protected:
  explicit SMove(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 2,
    kUuidFieldNumber = 1,
    kIsMonsterFieldNumber = 3,
  };
  // .protocol.Position position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::protocol::Position& position() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Position* release_position();
  ::protocol::Position* mutable_position();
  void set_allocated_position(::protocol::Position* position);
  private:
  const ::protocol::Position& _internal_position() const;
  ::protocol::Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::protocol::Position* position);
  ::protocol::Position* unsafe_arena_release_position();

  // int32 uuid = 1;
  void clear_uuid();
  ::PROTOBUF_NAMESPACE_ID::int32 uuid() const;
  void set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_uuid() const;
  void _internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool is_monster = 3;
  void clear_is_monster();
  bool is_monster() const;
  void set_is_monster(bool value);
  private:
  bool _internal_is_monster() const;
  void _internal_set_is_monster(bool value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SMove)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::Position* position_;
  ::PROTOBUF_NAMESPACE_ID::int32 uuid_;
  bool is_monster_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class SChat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SChat) */ {
 public:
  inline SChat() : SChat(nullptr) {}
  ~SChat() override;
  explicit constexpr SChat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SChat(const SChat& from);
  SChat(SChat&& from) noexcept
    : SChat() {
    *this = ::std::move(from);
  }

  inline SChat& operator=(const SChat& from) {
    CopyFrom(from);
    return *this;
  }
  inline SChat& operator=(SChat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SChat& default_instance() {
    return *internal_default_instance();
  }
  static inline const SChat* internal_default_instance() {
    return reinterpret_cast<const SChat*>(
               &_SChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SChat& a, SChat& b) {
    a.Swap(&b);
  }
  inline void Swap(SChat* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SChat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SChat* New() const final {
    return new SChat();
  }

  SChat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SChat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SChat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SChat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SChat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SChat";
  }
  protected:
  explicit SChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 5,
    kTypeFieldNumber = 1,
    kUuidFieldNumber = 2,
  };
  // string text = 5;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_MUST_USE_RESULT std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // uint32 type = 1;
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::uint32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // int32 uuid = 2;
  void clear_uuid();
  ::PROTOBUF_NAMESPACE_ID::int32 uuid() const;
  void set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_uuid() const;
  void _internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SChat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::PROTOBUF_NAMESPACE_ID::uint32 type_;
  ::PROTOBUF_NAMESPACE_ID::int32 uuid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class SPlayerData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SPlayerData) */ {
 public:
  inline SPlayerData() : SPlayerData(nullptr) {}
  ~SPlayerData() override;
  explicit constexpr SPlayerData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SPlayerData(const SPlayerData& from);
  SPlayerData(SPlayerData&& from) noexcept
    : SPlayerData() {
    *this = ::std::move(from);
  }

  inline SPlayerData& operator=(const SPlayerData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SPlayerData& operator=(SPlayerData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SPlayerData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SPlayerData* internal_default_instance() {
    return reinterpret_cast<const SPlayerData*>(
               &_SPlayerData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SPlayerData& a, SPlayerData& b) {
    a.Swap(&b);
  }
  inline void Swap(SPlayerData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SPlayerData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SPlayerData* New() const final {
    return new SPlayerData();
  }

  SPlayerData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SPlayerData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SPlayerData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SPlayerData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SPlayerData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SPlayerData";
  }
  protected:
  explicit SPlayerData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerFieldNumber = 1,
    kExpFieldNumber = 2,
  };
  // .protocol.Unit player = 1;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::protocol::Unit& player() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Unit* release_player();
  ::protocol::Unit* mutable_player();
  void set_allocated_player(::protocol::Unit* player);
  private:
  const ::protocol::Unit& _internal_player() const;
  ::protocol::Unit* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::protocol::Unit* player);
  ::protocol::Unit* unsafe_arena_release_player();

  // int32 exp = 2;
  void clear_exp();
  ::PROTOBUF_NAMESPACE_ID::int32 exp() const;
  void set_exp(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_exp() const;
  void _internal_set_exp(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SPlayerData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::Unit* player_;
  ::PROTOBUF_NAMESPACE_ID::int32 exp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class SClosePlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SClosePlayer) */ {
 public:
  inline SClosePlayer() : SClosePlayer(nullptr) {}
  ~SClosePlayer() override;
  explicit constexpr SClosePlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SClosePlayer(const SClosePlayer& from);
  SClosePlayer(SClosePlayer&& from) noexcept
    : SClosePlayer() {
    *this = ::std::move(from);
  }

  inline SClosePlayer& operator=(const SClosePlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline SClosePlayer& operator=(SClosePlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SClosePlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const SClosePlayer* internal_default_instance() {
    return reinterpret_cast<const SClosePlayer*>(
               &_SClosePlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SClosePlayer& a, SClosePlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(SClosePlayer* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SClosePlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SClosePlayer* New() const final {
    return new SClosePlayer();
  }

  SClosePlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SClosePlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SClosePlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SClosePlayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SClosePlayer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SClosePlayer";
  }
  protected:
  explicit SClosePlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
  };
  // int32 uuid = 1;
  void clear_uuid();
  ::PROTOBUF_NAMESPACE_ID::int32 uuid() const;
  void set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_uuid() const;
  void _internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SClosePlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 uuid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class UnitState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.UnitState) */ {
 public:
  inline UnitState() : UnitState(nullptr) {}
  ~UnitState() override;
  explicit constexpr UnitState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnitState(const UnitState& from);
  UnitState(UnitState&& from) noexcept
    : UnitState() {
    *this = ::std::move(from);
  }

  inline UnitState& operator=(const UnitState& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnitState& operator=(UnitState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnitState& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnitState* internal_default_instance() {
    return reinterpret_cast<const UnitState*>(
               &_UnitState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(UnitState& a, UnitState& b) {
    a.Swap(&b);
  }
  inline void Swap(UnitState* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnitState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnitState* New() const final {
    return new UnitState();
  }

  UnitState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnitState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnitState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnitState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.UnitState";
  }
  protected:
  explicit UnitState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnitFieldNumber = 1,
    kAttackFieldNumber = 11,
    kIsMonsterFieldNumber = 10,
  };
  // .protocol.Unit unit = 1;
  bool has_unit() const;
  private:
  bool _internal_has_unit() const;
  public:
  void clear_unit();
  const ::protocol::Unit& unit() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Unit* release_unit();
  ::protocol::Unit* mutable_unit();
  void set_allocated_unit(::protocol::Unit* unit);
  private:
  const ::protocol::Unit& _internal_unit() const;
  ::protocol::Unit* _internal_mutable_unit();
  public:
  void unsafe_arena_set_allocated_unit(
      ::protocol::Unit* unit);
  ::protocol::Unit* unsafe_arena_release_unit();

  // .protocol.Attack attack = 11;
  bool has_attack() const;
  private:
  bool _internal_has_attack() const;
  public:
  void clear_attack();
  const ::protocol::Attack& attack() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Attack* release_attack();
  ::protocol::Attack* mutable_attack();
  void set_allocated_attack(::protocol::Attack* attack);
  private:
  const ::protocol::Attack& _internal_attack() const;
  ::protocol::Attack* _internal_mutable_attack();
  public:
  void unsafe_arena_set_allocated_attack(
      ::protocol::Attack* attack);
  ::protocol::Attack* unsafe_arena_release_attack();

  // bool is_monster = 10;
  void clear_is_monster();
  bool is_monster() const;
  void set_is_monster(bool value);
  private:
  bool _internal_is_monster() const;
  void _internal_set_is_monster(bool value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.UnitState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::Unit* unit_;
  ::protocol::Attack* attack_;
  bool is_monster_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class SUnitStates final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SUnitStates) */ {
 public:
  inline SUnitStates() : SUnitStates(nullptr) {}
  ~SUnitStates() override;
  explicit constexpr SUnitStates(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SUnitStates(const SUnitStates& from);
  SUnitStates(SUnitStates&& from) noexcept
    : SUnitStates() {
    *this = ::std::move(from);
  }

  inline SUnitStates& operator=(const SUnitStates& from) {
    CopyFrom(from);
    return *this;
  }
  inline SUnitStates& operator=(SUnitStates&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SUnitStates& default_instance() {
    return *internal_default_instance();
  }
  static inline const SUnitStates* internal_default_instance() {
    return reinterpret_cast<const SUnitStates*>(
               &_SUnitStates_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SUnitStates& a, SUnitStates& b) {
    a.Swap(&b);
  }
  inline void Swap(SUnitStates* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SUnitStates* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SUnitStates* New() const final {
    return new SUnitStates();
  }

  SUnitStates* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SUnitStates>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SUnitStates& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SUnitStates& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SUnitStates* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SUnitStates";
  }
  protected:
  explicit SUnitStates(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnitStateFieldNumber = 1,
  };
  // repeated .protocol.UnitState unit_state = 1;
  int unit_state_size() const;
  private:
  int _internal_unit_state_size() const;
  public:
  void clear_unit_state();
  ::protocol::UnitState* mutable_unit_state(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::UnitState >*
      mutable_unit_state();
  private:
  const ::protocol::UnitState& _internal_unit_state(int index) const;
  ::protocol::UnitState* _internal_add_unit_state();
  public:
  const ::protocol::UnitState& unit_state(int index) const;
  ::protocol::UnitState* add_unit_state();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::UnitState >&
      unit_state() const;

  // @@protoc_insertion_point(class_scope:protocol.SUnitStates)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::UnitState > unit_state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class Attack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Attack) */ {
 public:
  inline Attack() : Attack(nullptr) {}
  ~Attack() override;
  explicit constexpr Attack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Attack(const Attack& from);
  Attack(Attack&& from) noexcept
    : Attack() {
    *this = ::std::move(from);
  }

  inline Attack& operator=(const Attack& from) {
    CopyFrom(from);
    return *this;
  }
  inline Attack& operator=(Attack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Attack& default_instance() {
    return *internal_default_instance();
  }
  static inline const Attack* internal_default_instance() {
    return reinterpret_cast<const Attack*>(
               &_Attack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Attack& a, Attack& b) {
    a.Swap(&b);
  }
  inline void Swap(Attack* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Attack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Attack* New() const final {
    return new Attack();
  }

  Attack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Attack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Attack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Attack& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Attack* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Attack";
  }
  protected:
  explicit Attack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kSkillCodeFieldNumber = 2,
    kTargetUuidFieldNumber = 3,
  };
  // int32 uuid = 1;
  void clear_uuid();
  ::PROTOBUF_NAMESPACE_ID::int32 uuid() const;
  void set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_uuid() const;
  void _internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 skill_code = 2;
  void clear_skill_code();
  ::PROTOBUF_NAMESPACE_ID::int32 skill_code() const;
  void set_skill_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_skill_code() const;
  void _internal_set_skill_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 target_uuid = 3;
  void clear_target_uuid();
  ::PROTOBUF_NAMESPACE_ID::int32 target_uuid() const;
  void set_target_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_target_uuid() const;
  void _internal_set_target_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Attack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 uuid_;
  ::PROTOBUF_NAMESPACE_ID::int32 skill_code_;
  ::PROTOBUF_NAMESPACE_ID::int32 target_uuid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class Demage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Demage) */ {
 public:
  inline Demage() : Demage(nullptr) {}
  ~Demage() override;
  explicit constexpr Demage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Demage(const Demage& from);
  Demage(Demage&& from) noexcept
    : Demage() {
    *this = ::std::move(from);
  }

  inline Demage& operator=(const Demage& from) {
    CopyFrom(from);
    return *this;
  }
  inline Demage& operator=(Demage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Demage& default_instance() {
    return *internal_default_instance();
  }
  static inline const Demage* internal_default_instance() {
    return reinterpret_cast<const Demage*>(
               &_Demage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Demage& a, Demage& b) {
    a.Swap(&b);
  }
  inline void Swap(Demage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Demage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Demage* New() const final {
    return new Demage();
  }

  Demage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Demage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Demage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Demage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Demage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Demage";
  }
  protected:
  explicit Demage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 3,
    kUuidFieldNumber = 1,
    kDemageFieldNumber = 2,
    kIsHealFieldNumber = 4,
    kIsMonsterFieldNumber = 10,
  };
  // .protocol.Position position = 3;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::protocol::Position& position() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Position* release_position();
  ::protocol::Position* mutable_position();
  void set_allocated_position(::protocol::Position* position);
  private:
  const ::protocol::Position& _internal_position() const;
  ::protocol::Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::protocol::Position* position);
  ::protocol::Position* unsafe_arena_release_position();

  // int32 uuid = 1;
  void clear_uuid();
  ::PROTOBUF_NAMESPACE_ID::int32 uuid() const;
  void set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_uuid() const;
  void _internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 demage = 2;
  void clear_demage();
  ::PROTOBUF_NAMESPACE_ID::int32 demage() const;
  void set_demage(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_demage() const;
  void _internal_set_demage(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool is_heal = 4;
  void clear_is_heal();
  bool is_heal() const;
  void set_is_heal(bool value);
  private:
  bool _internal_is_heal() const;
  void _internal_set_is_heal(bool value);
  public:

  // bool is_monster = 10;
  void clear_is_monster();
  bool is_monster() const;
  void set_is_monster(bool value);
  private:
  bool _internal_is_monster() const;
  void _internal_set_is_monster(bool value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Demage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::Position* position_;
  ::PROTOBUF_NAMESPACE_ID::int32 uuid_;
  ::PROTOBUF_NAMESPACE_ID::int32 demage_;
  bool is_heal_;
  bool is_monster_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class SUnitDemage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SUnitDemage) */ {
 public:
  inline SUnitDemage() : SUnitDemage(nullptr) {}
  ~SUnitDemage() override;
  explicit constexpr SUnitDemage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SUnitDemage(const SUnitDemage& from);
  SUnitDemage(SUnitDemage&& from) noexcept
    : SUnitDemage() {
    *this = ::std::move(from);
  }

  inline SUnitDemage& operator=(const SUnitDemage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SUnitDemage& operator=(SUnitDemage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SUnitDemage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SUnitDemage* internal_default_instance() {
    return reinterpret_cast<const SUnitDemage*>(
               &_SUnitDemage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SUnitDemage& a, SUnitDemage& b) {
    a.Swap(&b);
  }
  inline void Swap(SUnitDemage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SUnitDemage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SUnitDemage* New() const final {
    return new SUnitDemage();
  }

  SUnitDemage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SUnitDemage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SUnitDemage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SUnitDemage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SUnitDemage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SUnitDemage";
  }
  protected:
  explicit SUnitDemage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDemageFieldNumber = 3,
    kUuidFieldNumber = 1,
    kIsMonsterFieldNumber = 2,
  };
  // repeated .protocol.Demage demage = 3;
  int demage_size() const;
  private:
  int _internal_demage_size() const;
  public:
  void clear_demage();
  ::protocol::Demage* mutable_demage(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Demage >*
      mutable_demage();
  private:
  const ::protocol::Demage& _internal_demage(int index) const;
  ::protocol::Demage* _internal_add_demage();
  public:
  const ::protocol::Demage& demage(int index) const;
  ::protocol::Demage* add_demage();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Demage >&
      demage() const;

  // int32 uuid = 1;
  void clear_uuid();
  ::PROTOBUF_NAMESPACE_ID::int32 uuid() const;
  void set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_uuid() const;
  void _internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool is_monster = 2;
  void clear_is_monster();
  bool is_monster() const;
  void set_is_monster(bool value);
  private:
  bool _internal_is_monster() const;
  void _internal_set_is_monster(bool value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SUnitDemage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Demage > demage_;
  ::PROTOBUF_NAMESPACE_ID::int32 uuid_;
  bool is_monster_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class SRoomQuest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SRoomQuest) */ {
 public:
  inline SRoomQuest() : SRoomQuest(nullptr) {}
  ~SRoomQuest() override;
  explicit constexpr SRoomQuest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SRoomQuest(const SRoomQuest& from);
  SRoomQuest(SRoomQuest&& from) noexcept
    : SRoomQuest() {
    *this = ::std::move(from);
  }

  inline SRoomQuest& operator=(const SRoomQuest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SRoomQuest& operator=(SRoomQuest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SRoomQuest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SRoomQuest* internal_default_instance() {
    return reinterpret_cast<const SRoomQuest*>(
               &_SRoomQuest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SRoomQuest& a, SRoomQuest& b) {
    a.Swap(&b);
  }
  inline void Swap(SRoomQuest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SRoomQuest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SRoomQuest* New() const final {
    return new SRoomQuest();
  }

  SRoomQuest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SRoomQuest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SRoomQuest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SRoomQuest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SRoomQuest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SRoomQuest";
  }
  protected:
  explicit SRoomQuest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsClearFieldNumber = 1,
    kKillCountFieldNumber = 2,
    kSumKillFieldNumber = 3,
  };
  // bool is_clear = 1;
  void clear_is_clear();
  bool is_clear() const;
  void set_is_clear(bool value);
  private:
  bool _internal_is_clear() const;
  void _internal_set_is_clear(bool value);
  public:

  // int32 kill_count = 2;
  void clear_kill_count();
  ::PROTOBUF_NAMESPACE_ID::int32 kill_count() const;
  void set_kill_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_kill_count() const;
  void _internal_set_kill_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 sum_kill = 3;
  void clear_sum_kill();
  ::PROTOBUF_NAMESPACE_ID::int32 sum_kill() const;
  void set_sum_kill(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_sum_kill() const;
  void _internal_set_sum_kill(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SRoomQuest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool is_clear_;
  ::PROTOBUF_NAMESPACE_ID::int32 kill_count_;
  ::PROTOBUF_NAMESPACE_ID::int32 sum_kill_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class CMovePotal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.CMovePotal) */ {
 public:
  inline CMovePotal() : CMovePotal(nullptr) {}
  ~CMovePotal() override;
  explicit constexpr CMovePotal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMovePotal(const CMovePotal& from);
  CMovePotal(CMovePotal&& from) noexcept
    : CMovePotal() {
    *this = ::std::move(from);
  }

  inline CMovePotal& operator=(const CMovePotal& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMovePotal& operator=(CMovePotal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMovePotal& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMovePotal* internal_default_instance() {
    return reinterpret_cast<const CMovePotal*>(
               &_CMovePotal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CMovePotal& a, CMovePotal& b) {
    a.Swap(&b);
  }
  inline void Swap(CMovePotal* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMovePotal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CMovePotal* New() const final {
    return new CMovePotal();
  }

  CMovePotal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CMovePotal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMovePotal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMovePotal& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMovePotal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.CMovePotal";
  }
  protected:
  explicit CMovePotal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPreRoomIdFieldNumber = 1,
    kNextRoomIdFieldNumber = 2,
  };
  // int32 pre_room_id = 1;
  void clear_pre_room_id();
  ::PROTOBUF_NAMESPACE_ID::int32 pre_room_id() const;
  void set_pre_room_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_pre_room_id() const;
  void _internal_set_pre_room_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 next_room_id = 2;
  void clear_next_room_id();
  ::PROTOBUF_NAMESPACE_ID::int32 next_room_id() const;
  void set_next_room_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_next_room_id() const;
  void _internal_set_next_room_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.CMovePotal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 pre_room_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 next_room_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class SEndGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SEndGame) */ {
 public:
  inline SEndGame() : SEndGame(nullptr) {}
  ~SEndGame() override;
  explicit constexpr SEndGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SEndGame(const SEndGame& from);
  SEndGame(SEndGame&& from) noexcept
    : SEndGame() {
    *this = ::std::move(from);
  }

  inline SEndGame& operator=(const SEndGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline SEndGame& operator=(SEndGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SEndGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const SEndGame* internal_default_instance() {
    return reinterpret_cast<const SEndGame*>(
               &_SEndGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SEndGame& a, SEndGame& b) {
    a.Swap(&b);
  }
  inline void Swap(SEndGame* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SEndGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SEndGame* New() const final {
    return new SEndGame();
  }

  SEndGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SEndGame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SEndGame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SEndGame& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SEndGame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SEndGame";
  }
  protected:
  explicit SEndGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndGameFieldNumber = 1,
  };
  // bool end_game = 1;
  void clear_end_game();
  bool end_game() const;
  void set_end_game(bool value);
  private:
  bool _internal_end_game() const;
  void _internal_set_end_game(bool value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SEndGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool end_game_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class CBuyCharater final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.CBuyCharater) */ {
 public:
  inline CBuyCharater() : CBuyCharater(nullptr) {}
  ~CBuyCharater() override;
  explicit constexpr CBuyCharater(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CBuyCharater(const CBuyCharater& from);
  CBuyCharater(CBuyCharater&& from) noexcept
    : CBuyCharater() {
    *this = ::std::move(from);
  }

  inline CBuyCharater& operator=(const CBuyCharater& from) {
    CopyFrom(from);
    return *this;
  }
  inline CBuyCharater& operator=(CBuyCharater&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CBuyCharater& default_instance() {
    return *internal_default_instance();
  }
  static inline const CBuyCharater* internal_default_instance() {
    return reinterpret_cast<const CBuyCharater*>(
               &_CBuyCharater_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(CBuyCharater& a, CBuyCharater& b) {
    a.Swap(&b);
  }
  inline void Swap(CBuyCharater* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CBuyCharater* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CBuyCharater* New() const final {
    return new CBuyCharater();
  }

  CBuyCharater* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CBuyCharater>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CBuyCharater& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CBuyCharater& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CBuyCharater* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.CBuyCharater";
  }
  protected:
  explicit CBuyCharater(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kCharaterTypeFieldNumber = 1,
    kUseCashFieldNumber = 2,
  };
  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 CharaterType = 1;
  void clear_charatertype();
  ::PROTOBUF_NAMESPACE_ID::int32 charatertype() const;
  void set_charatertype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_charatertype() const;
  void _internal_set_charatertype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 useCash = 2;
  void clear_usecash();
  ::PROTOBUF_NAMESPACE_ID::int32 usecash() const;
  void set_usecash(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_usecash() const;
  void _internal_set_usecash(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.CBuyCharater)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 charatertype_;
  ::PROTOBUF_NAMESPACE_ID::int32 usecash_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class CBuyWeapon final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.CBuyWeapon) */ {
 public:
  inline CBuyWeapon() : CBuyWeapon(nullptr) {}
  ~CBuyWeapon() override;
  explicit constexpr CBuyWeapon(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CBuyWeapon(const CBuyWeapon& from);
  CBuyWeapon(CBuyWeapon&& from) noexcept
    : CBuyWeapon() {
    *this = ::std::move(from);
  }

  inline CBuyWeapon& operator=(const CBuyWeapon& from) {
    CopyFrom(from);
    return *this;
  }
  inline CBuyWeapon& operator=(CBuyWeapon&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CBuyWeapon& default_instance() {
    return *internal_default_instance();
  }
  static inline const CBuyWeapon* internal_default_instance() {
    return reinterpret_cast<const CBuyWeapon*>(
               &_CBuyWeapon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(CBuyWeapon& a, CBuyWeapon& b) {
    a.Swap(&b);
  }
  inline void Swap(CBuyWeapon* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CBuyWeapon* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CBuyWeapon* New() const final {
    return new CBuyWeapon();
  }

  CBuyWeapon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CBuyWeapon>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CBuyWeapon& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CBuyWeapon& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CBuyWeapon* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.CBuyWeapon";
  }
  protected:
  explicit CBuyWeapon(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWeaponTypeFieldNumber = 1,
    kUseCashFieldNumber = 2,
  };
  // int32 weaponType = 1;
  void clear_weapontype();
  ::PROTOBUF_NAMESPACE_ID::int32 weapontype() const;
  void set_weapontype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_weapontype() const;
  void _internal_set_weapontype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 useCash = 2;
  void clear_usecash();
  ::PROTOBUF_NAMESPACE_ID::int32 usecash() const;
  void set_usecash(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_usecash() const;
  void _internal_set_usecash(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.CBuyWeapon)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 weapontype_;
  ::PROTOBUF_NAMESPACE_ID::int32 usecash_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class SBuyResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SBuyResult) */ {
 public:
  inline SBuyResult() : SBuyResult(nullptr) {}
  ~SBuyResult() override;
  explicit constexpr SBuyResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SBuyResult(const SBuyResult& from);
  SBuyResult(SBuyResult&& from) noexcept
    : SBuyResult() {
    *this = ::std::move(from);
  }

  inline SBuyResult& operator=(const SBuyResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SBuyResult& operator=(SBuyResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SBuyResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const SBuyResult* internal_default_instance() {
    return reinterpret_cast<const SBuyResult*>(
               &_SBuyResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SBuyResult& a, SBuyResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SBuyResult* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SBuyResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SBuyResult* New() const final {
    return new SBuyResult();
  }

  SBuyResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SBuyResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SBuyResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SBuyResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SBuyResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SBuyResult";
  }
  protected:
  explicit SBuyResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharaterFieldNumber = 2,
    kWeaponListFieldNumber = 6,
    kResultFieldNumber = 1,
    kCurCharaterTypeFieldNumber = 3,
    kCurWeaponTypeFieldNumber = 4,
    kCashFieldNumber = 5,
  };
  // repeated .protocol.Charater charater = 2;
  int charater_size() const;
  private:
  int _internal_charater_size() const;
  public:
  void clear_charater();
  ::protocol::Charater* mutable_charater(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Charater >*
      mutable_charater();
  private:
  const ::protocol::Charater& _internal_charater(int index) const;
  ::protocol::Charater* _internal_add_charater();
  public:
  const ::protocol::Charater& charater(int index) const;
  ::protocol::Charater* add_charater();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Charater >&
      charater() const;

  // repeated int32 weaponList = 6;
  int weaponlist_size() const;
  private:
  int _internal_weaponlist_size() const;
  public:
  void clear_weaponlist();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_weaponlist(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_weaponlist() const;
  void _internal_add_weaponlist(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_weaponlist();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 weaponlist(int index) const;
  void set_weaponlist(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_weaponlist(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      weaponlist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_weaponlist();

  // int32 result = 1;
  void clear_result();
  ::PROTOBUF_NAMESPACE_ID::int32 result() const;
  void set_result(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_result() const;
  void _internal_set_result(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 curCharaterType = 3;
  void clear_curcharatertype();
  ::PROTOBUF_NAMESPACE_ID::int32 curcharatertype() const;
  void set_curcharatertype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_curcharatertype() const;
  void _internal_set_curcharatertype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 curWeaponType = 4;
  void clear_curweapontype();
  ::PROTOBUF_NAMESPACE_ID::int32 curweapontype() const;
  void set_curweapontype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_curweapontype() const;
  void _internal_set_curweapontype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 cash = 5;
  void clear_cash();
  ::PROTOBUF_NAMESPACE_ID::int32 cash() const;
  void set_cash(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cash() const;
  void _internal_set_cash(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SBuyResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Charater > charater_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > weaponlist_;
  mutable std::atomic<int> _weaponlist_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 result_;
  ::PROTOBUF_NAMESPACE_ID::int32 curcharatertype_;
  ::PROTOBUF_NAMESPACE_ID::int32 curweapontype_;
  ::PROTOBUF_NAMESPACE_ID::int32 cash_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class CPlayerJump final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.CPlayerJump) */ {
 public:
  inline CPlayerJump() : CPlayerJump(nullptr) {}
  ~CPlayerJump() override;
  explicit constexpr CPlayerJump(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CPlayerJump(const CPlayerJump& from);
  CPlayerJump(CPlayerJump&& from) noexcept
    : CPlayerJump() {
    *this = ::std::move(from);
  }

  inline CPlayerJump& operator=(const CPlayerJump& from) {
    CopyFrom(from);
    return *this;
  }
  inline CPlayerJump& operator=(CPlayerJump&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CPlayerJump& default_instance() {
    return *internal_default_instance();
  }
  static inline const CPlayerJump* internal_default_instance() {
    return reinterpret_cast<const CPlayerJump*>(
               &_CPlayerJump_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CPlayerJump& a, CPlayerJump& b) {
    a.Swap(&b);
  }
  inline void Swap(CPlayerJump* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CPlayerJump* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CPlayerJump* New() const final {
    return new CPlayerJump();
  }

  CPlayerJump* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CPlayerJump>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CPlayerJump& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CPlayerJump& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CPlayerJump* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.CPlayerJump";
  }
  protected:
  explicit CPlayerJump(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsJumpFieldNumber = 1,
    kUuidFieldNumber = 2,
  };
  // bool isJump = 1;
  void clear_isjump();
  bool isjump() const;
  void set_isjump(bool value);
  private:
  bool _internal_isjump() const;
  void _internal_set_isjump(bool value);
  public:

  // int32 uuid = 2;
  void clear_uuid();
  ::PROTOBUF_NAMESPACE_ID::int32 uuid() const;
  void set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_uuid() const;
  void _internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.CPlayerJump)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool isjump_;
  ::PROTOBUF_NAMESPACE_ID::int32 uuid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class CPlayerAim final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.CPlayerAim) */ {
 public:
  inline CPlayerAim() : CPlayerAim(nullptr) {}
  ~CPlayerAim() override;
  explicit constexpr CPlayerAim(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CPlayerAim(const CPlayerAim& from);
  CPlayerAim(CPlayerAim&& from) noexcept
    : CPlayerAim() {
    *this = ::std::move(from);
  }

  inline CPlayerAim& operator=(const CPlayerAim& from) {
    CopyFrom(from);
    return *this;
  }
  inline CPlayerAim& operator=(CPlayerAim&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CPlayerAim& default_instance() {
    return *internal_default_instance();
  }
  static inline const CPlayerAim* internal_default_instance() {
    return reinterpret_cast<const CPlayerAim*>(
               &_CPlayerAim_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CPlayerAim& a, CPlayerAim& b) {
    a.Swap(&b);
  }
  inline void Swap(CPlayerAim* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CPlayerAim* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CPlayerAim* New() const final {
    return new CPlayerAim();
  }

  CPlayerAim* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CPlayerAim>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CPlayerAim& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CPlayerAim& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CPlayerAim* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.CPlayerAim";
  }
  protected:
  explicit CPlayerAim(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsAimFieldNumber = 1,
    kUuidFieldNumber = 2,
  };
  // bool isAim = 1;
  void clear_isaim();
  bool isaim() const;
  void set_isaim(bool value);
  private:
  bool _internal_isaim() const;
  void _internal_set_isaim(bool value);
  public:

  // int32 uuid = 2;
  void clear_uuid();
  ::PROTOBUF_NAMESPACE_ID::int32 uuid() const;
  void set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_uuid() const;
  void _internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.CPlayerAim)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool isaim_;
  ::PROTOBUF_NAMESPACE_ID::int32 uuid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class SExpLv final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SExpLv) */ {
 public:
  inline SExpLv() : SExpLv(nullptr) {}
  ~SExpLv() override;
  explicit constexpr SExpLv(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SExpLv(const SExpLv& from);
  SExpLv(SExpLv&& from) noexcept
    : SExpLv() {
    *this = ::std::move(from);
  }

  inline SExpLv& operator=(const SExpLv& from) {
    CopyFrom(from);
    return *this;
  }
  inline SExpLv& operator=(SExpLv&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SExpLv& default_instance() {
    return *internal_default_instance();
  }
  static inline const SExpLv* internal_default_instance() {
    return reinterpret_cast<const SExpLv*>(
               &_SExpLv_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(SExpLv& a, SExpLv& b) {
    a.Swap(&b);
  }
  inline void Swap(SExpLv* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SExpLv* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SExpLv* New() const final {
    return new SExpLv();
  }

  SExpLv* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SExpLv>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SExpLv& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SExpLv& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SExpLv* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SExpLv";
  }
  protected:
  explicit SExpLv(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kLvFieldNumber = 2,
    kExpFieldNumber = 3,
  };
  // int32 uuid = 1;
  void clear_uuid();
  ::PROTOBUF_NAMESPACE_ID::int32 uuid() const;
  void set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_uuid() const;
  void _internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 lv = 2;
  void clear_lv();
  ::PROTOBUF_NAMESPACE_ID::int32 lv() const;
  void set_lv(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_lv() const;
  void _internal_set_lv(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 exp = 3;
  void clear_exp();
  ::PROTOBUF_NAMESPACE_ID::int32 exp() const;
  void set_exp(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_exp() const;
  void _internal_set_exp(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SExpLv)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 uuid_;
  ::PROTOBUF_NAMESPACE_ID::int32 lv_;
  ::PROTOBUF_NAMESPACE_ID::int32 exp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class ItemEquip final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.ItemEquip) */ {
 public:
  inline ItemEquip() : ItemEquip(nullptr) {}
  ~ItemEquip() override;
  explicit constexpr ItemEquip(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemEquip(const ItemEquip& from);
  ItemEquip(ItemEquip&& from) noexcept
    : ItemEquip() {
    *this = ::std::move(from);
  }

  inline ItemEquip& operator=(const ItemEquip& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemEquip& operator=(ItemEquip&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemEquip& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemEquip* internal_default_instance() {
    return reinterpret_cast<const ItemEquip*>(
               &_ItemEquip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ItemEquip& a, ItemEquip& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemEquip* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemEquip* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ItemEquip* New() const final {
    return new ItemEquip();
  }

  ItemEquip* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ItemEquip>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemEquip& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ItemEquip& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemEquip* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.ItemEquip";
  }
  protected:
  explicit ItemEquip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemCodeFieldNumber = 1,
    kItemTypeFieldNumber = 2,
    kAttackFieldNumber = 3,
    kSpeedFieldNumber = 4,
    kEquipPosFieldNumber = 5,
    kInvenPosFieldNumber = 7,
  };
  // int32 item_code = 1;
  void clear_item_code();
  ::PROTOBUF_NAMESPACE_ID::int32 item_code() const;
  void set_item_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_item_code() const;
  void _internal_set_item_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 item_type = 2;
  void clear_item_type();
  ::PROTOBUF_NAMESPACE_ID::int32 item_type() const;
  void set_item_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_item_type() const;
  void _internal_set_item_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 attack = 3;
  void clear_attack();
  ::PROTOBUF_NAMESPACE_ID::int32 attack() const;
  void set_attack(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_attack() const;
  void _internal_set_attack(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 speed = 4;
  void clear_speed();
  ::PROTOBUF_NAMESPACE_ID::int32 speed() const;
  void set_speed(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_speed() const;
  void _internal_set_speed(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 equipPos = 5;
  void clear_equippos();
  ::PROTOBUF_NAMESPACE_ID::int32 equippos() const;
  void set_equippos(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_equippos() const;
  void _internal_set_equippos(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 invenPos = 7;
  void clear_invenpos();
  ::PROTOBUF_NAMESPACE_ID::int32 invenpos() const;
  void set_invenpos(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_invenpos() const;
  void _internal_set_invenpos(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.ItemEquip)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 item_code_;
  ::PROTOBUF_NAMESPACE_ID::int32 item_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 attack_;
  ::PROTOBUF_NAMESPACE_ID::int32 speed_;
  ::PROTOBUF_NAMESPACE_ID::int32 equippos_;
  ::PROTOBUF_NAMESPACE_ID::int32 invenpos_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class ItemEtc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.ItemEtc) */ {
 public:
  inline ItemEtc() : ItemEtc(nullptr) {}
  ~ItemEtc() override;
  explicit constexpr ItemEtc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemEtc(const ItemEtc& from);
  ItemEtc(ItemEtc&& from) noexcept
    : ItemEtc() {
    *this = ::std::move(from);
  }

  inline ItemEtc& operator=(const ItemEtc& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemEtc& operator=(ItemEtc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemEtc& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemEtc* internal_default_instance() {
    return reinterpret_cast<const ItemEtc*>(
               &_ItemEtc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ItemEtc& a, ItemEtc& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemEtc* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemEtc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ItemEtc* New() const final {
    return new ItemEtc();
  }

  ItemEtc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ItemEtc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemEtc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ItemEtc& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemEtc* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.ItemEtc";
  }
  protected:
  explicit ItemEtc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemCodeFieldNumber = 1,
    kItemCountFieldNumber = 2,
    kItemTypeFieldNumber = 3,
    kInvenPosFieldNumber = 4,
  };
  // int32 item_code = 1;
  void clear_item_code();
  ::PROTOBUF_NAMESPACE_ID::int32 item_code() const;
  void set_item_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_item_code() const;
  void _internal_set_item_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 item_count = 2;
  void clear_item_count();
  ::PROTOBUF_NAMESPACE_ID::int32 item_count() const;
  void set_item_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_item_count() const;
  void _internal_set_item_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 item_type = 3;
  void clear_item_type();
  ::PROTOBUF_NAMESPACE_ID::int32 item_type() const;
  void set_item_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_item_type() const;
  void _internal_set_item_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 invenPos = 4;
  void clear_invenpos();
  ::PROTOBUF_NAMESPACE_ID::int32 invenpos() const;
  void set_invenpos(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_invenpos() const;
  void _internal_set_invenpos(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.ItemEtc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 item_code_;
  ::PROTOBUF_NAMESPACE_ID::int32 item_count_;
  ::PROTOBUF_NAMESPACE_ID::int32 item_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 invenpos_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class UpdateInventory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.UpdateInventory) */ {
 public:
  inline UpdateInventory() : UpdateInventory(nullptr) {}
  ~UpdateInventory() override;
  explicit constexpr UpdateInventory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateInventory(const UpdateInventory& from);
  UpdateInventory(UpdateInventory&& from) noexcept
    : UpdateInventory() {
    *this = ::std::move(from);
  }

  inline UpdateInventory& operator=(const UpdateInventory& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateInventory& operator=(UpdateInventory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateInventory& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateInventory* internal_default_instance() {
    return reinterpret_cast<const UpdateInventory*>(
               &_UpdateInventory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(UpdateInventory& a, UpdateInventory& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateInventory* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateInventory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateInventory* New() const final {
    return new UpdateInventory();
  }

  UpdateInventory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateInventory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateInventory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateInventory& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateInventory* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.UpdateInventory";
  }
  protected:
  explicit UpdateInventory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemEquipsFieldNumber = 1,
    kItemEtcsFieldNumber = 2,
    kGoldFieldNumber = 3,
  };
  // repeated .protocol.ItemEquip itemEquips = 1;
  int itemequips_size() const;
  private:
  int _internal_itemequips_size() const;
  public:
  void clear_itemequips();
  ::protocol::ItemEquip* mutable_itemequips(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >*
      mutable_itemequips();
  private:
  const ::protocol::ItemEquip& _internal_itemequips(int index) const;
  ::protocol::ItemEquip* _internal_add_itemequips();
  public:
  const ::protocol::ItemEquip& itemequips(int index) const;
  ::protocol::ItemEquip* add_itemequips();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >&
      itemequips() const;

  // repeated .protocol.ItemEtc itemEtcs = 2;
  int itemetcs_size() const;
  private:
  int _internal_itemetcs_size() const;
  public:
  void clear_itemetcs();
  ::protocol::ItemEtc* mutable_itemetcs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEtc >*
      mutable_itemetcs();
  private:
  const ::protocol::ItemEtc& _internal_itemetcs(int index) const;
  ::protocol::ItemEtc* _internal_add_itemetcs();
  public:
  const ::protocol::ItemEtc& itemetcs(int index) const;
  ::protocol::ItemEtc* add_itemetcs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEtc >&
      itemetcs() const;

  // int32 gold = 3;
  void clear_gold();
  ::PROTOBUF_NAMESPACE_ID::int32 gold() const;
  void set_gold(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_gold() const;
  void _internal_set_gold(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.UpdateInventory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip > itemequips_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEtc > itemetcs_;
  ::PROTOBUF_NAMESPACE_ID::int32 gold_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class SLoadInventory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SLoadInventory) */ {
 public:
  inline SLoadInventory() : SLoadInventory(nullptr) {}
  ~SLoadInventory() override;
  explicit constexpr SLoadInventory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLoadInventory(const SLoadInventory& from);
  SLoadInventory(SLoadInventory&& from) noexcept
    : SLoadInventory() {
    *this = ::std::move(from);
  }

  inline SLoadInventory& operator=(const SLoadInventory& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLoadInventory& operator=(SLoadInventory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLoadInventory& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLoadInventory* internal_default_instance() {
    return reinterpret_cast<const SLoadInventory*>(
               &_SLoadInventory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(SLoadInventory& a, SLoadInventory& b) {
    a.Swap(&b);
  }
  inline void Swap(SLoadInventory* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLoadInventory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SLoadInventory* New() const final {
    return new SLoadInventory();
  }

  SLoadInventory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SLoadInventory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLoadInventory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLoadInventory& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLoadInventory* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SLoadInventory";
  }
  protected:
  explicit SLoadInventory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemEquipsFieldNumber = 1,
    kItemEtcsFieldNumber = 2,
    kGoldFieldNumber = 3,
  };
  // repeated .protocol.ItemEquip itemEquips = 1;
  int itemequips_size() const;
  private:
  int _internal_itemequips_size() const;
  public:
  void clear_itemequips();
  ::protocol::ItemEquip* mutable_itemequips(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >*
      mutable_itemequips();
  private:
  const ::protocol::ItemEquip& _internal_itemequips(int index) const;
  ::protocol::ItemEquip* _internal_add_itemequips();
  public:
  const ::protocol::ItemEquip& itemequips(int index) const;
  ::protocol::ItemEquip* add_itemequips();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >&
      itemequips() const;

  // repeated .protocol.ItemEtc itemEtcs = 2;
  int itemetcs_size() const;
  private:
  int _internal_itemetcs_size() const;
  public:
  void clear_itemetcs();
  ::protocol::ItemEtc* mutable_itemetcs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEtc >*
      mutable_itemetcs();
  private:
  const ::protocol::ItemEtc& _internal_itemetcs(int index) const;
  ::protocol::ItemEtc* _internal_add_itemetcs();
  public:
  const ::protocol::ItemEtc& itemetcs(int index) const;
  ::protocol::ItemEtc* add_itemetcs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEtc >&
      itemetcs() const;

  // int32 gold = 3;
  void clear_gold();
  ::PROTOBUF_NAMESPACE_ID::int32 gold() const;
  void set_gold(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_gold() const;
  void _internal_set_gold(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SLoadInventory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip > itemequips_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEtc > itemetcs_;
  ::PROTOBUF_NAMESPACE_ID::int32 gold_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class CSellItems final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.CSellItems) */ {
 public:
  inline CSellItems() : CSellItems(nullptr) {}
  ~CSellItems() override;
  explicit constexpr CSellItems(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSellItems(const CSellItems& from);
  CSellItems(CSellItems&& from) noexcept
    : CSellItems() {
    *this = ::std::move(from);
  }

  inline CSellItems& operator=(const CSellItems& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSellItems& operator=(CSellItems&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSellItems& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSellItems* internal_default_instance() {
    return reinterpret_cast<const CSellItems*>(
               &_CSellItems_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(CSellItems& a, CSellItems& b) {
    a.Swap(&b);
  }
  inline void Swap(CSellItems* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSellItems* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CSellItems* New() const final {
    return new CSellItems();
  }

  CSellItems* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CSellItems>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSellItems& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSellItems& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSellItems* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.CSellItems";
  }
  protected:
  explicit CSellItems(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemEquipsFieldNumber = 1,
    kItemEtcsFieldNumber = 2,
    kGoldFieldNumber = 3,
    kResultFieldNumber = 4,
  };
  // repeated .protocol.ItemEquip itemEquips = 1;
  int itemequips_size() const;
  private:
  int _internal_itemequips_size() const;
  public:
  void clear_itemequips();
  ::protocol::ItemEquip* mutable_itemequips(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >*
      mutable_itemequips();
  private:
  const ::protocol::ItemEquip& _internal_itemequips(int index) const;
  ::protocol::ItemEquip* _internal_add_itemequips();
  public:
  const ::protocol::ItemEquip& itemequips(int index) const;
  ::protocol::ItemEquip* add_itemequips();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >&
      itemequips() const;

  // repeated .protocol.ItemEtc itemEtcs = 2;
  int itemetcs_size() const;
  private:
  int _internal_itemetcs_size() const;
  public:
  void clear_itemetcs();
  ::protocol::ItemEtc* mutable_itemetcs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEtc >*
      mutable_itemetcs();
  private:
  const ::protocol::ItemEtc& _internal_itemetcs(int index) const;
  ::protocol::ItemEtc* _internal_add_itemetcs();
  public:
  const ::protocol::ItemEtc& itemetcs(int index) const;
  ::protocol::ItemEtc* add_itemetcs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEtc >&
      itemetcs() const;

  // int32 gold = 3;
  void clear_gold();
  ::PROTOBUF_NAMESPACE_ID::int32 gold() const;
  void set_gold(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_gold() const;
  void _internal_set_gold(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool result = 4;
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.CSellItems)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip > itemequips_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEtc > itemetcs_;
  ::PROTOBUF_NAMESPACE_ID::int32 gold_;
  bool result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class DLoad final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.DLoad) */ {
 public:
  inline DLoad() : DLoad(nullptr) {}
  ~DLoad() override;
  explicit constexpr DLoad(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DLoad(const DLoad& from);
  DLoad(DLoad&& from) noexcept
    : DLoad() {
    *this = ::std::move(from);
  }

  inline DLoad& operator=(const DLoad& from) {
    CopyFrom(from);
    return *this;
  }
  inline DLoad& operator=(DLoad&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DLoad& default_instance() {
    return *internal_default_instance();
  }
  static inline const DLoad* internal_default_instance() {
    return reinterpret_cast<const DLoad*>(
               &_DLoad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(DLoad& a, DLoad& b) {
    a.Swap(&b);
  }
  inline void Swap(DLoad* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DLoad* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DLoad* New() const final {
    return new DLoad();
  }

  DLoad* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DLoad>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DLoad& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DLoad& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DLoad* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.DLoad";
  }
  protected:
  explicit DLoad(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnitFieldNumber = 101,
  };
  // .protocol.Unit unit = 101;
  bool has_unit() const;
  private:
  bool _internal_has_unit() const;
  public:
  void clear_unit();
  const ::protocol::Unit& unit() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Unit* release_unit();
  ::protocol::Unit* mutable_unit();
  void set_allocated_unit(::protocol::Unit* unit);
  private:
  const ::protocol::Unit& _internal_unit() const;
  ::protocol::Unit* _internal_mutable_unit();
  public:
  void unsafe_arena_set_allocated_unit(
      ::protocol::Unit* unit);
  ::protocol::Unit* unsafe_arena_release_unit();

  // @@protoc_insertion_point(class_scope:protocol.DLoad)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::Unit* unit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class Friend final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Friend) */ {
 public:
  inline Friend() : Friend(nullptr) {}
  ~Friend() override;
  explicit constexpr Friend(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Friend(const Friend& from);
  Friend(Friend&& from) noexcept
    : Friend() {
    *this = ::std::move(from);
  }

  inline Friend& operator=(const Friend& from) {
    CopyFrom(from);
    return *this;
  }
  inline Friend& operator=(Friend&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Friend& default_instance() {
    return *internal_default_instance();
  }
  static inline const Friend* internal_default_instance() {
    return reinterpret_cast<const Friend*>(
               &_Friend_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(Friend& a, Friend& b) {
    a.Swap(&b);
  }
  inline void Swap(Friend* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Friend* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Friend* New() const final {
    return new Friend();
  }

  Friend* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Friend>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Friend& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Friend& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Friend* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Friend";
  }
  protected:
  explicit Friend(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerNameFieldNumber = 2,
    kPlayerCodeFieldNumber = 1,
    kAccessFieldNumber = 3,
    kAddFieldNumber = 4,
  };
  // string playerName = 2;
  void clear_playername();
  const std::string& playername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_playername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_playername();
  PROTOBUF_MUST_USE_RESULT std::string* release_playername();
  void set_allocated_playername(std::string* playername);
  private:
  const std::string& _internal_playername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_playername(const std::string& value);
  std::string* _internal_mutable_playername();
  public:

  // int32 playerCode = 1;
  void clear_playercode();
  ::PROTOBUF_NAMESPACE_ID::int32 playercode() const;
  void set_playercode(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_playercode() const;
  void _internal_set_playercode(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool access = 3;
  void clear_access();
  bool access() const;
  void set_access(bool value);
  private:
  bool _internal_access() const;
  void _internal_set_access(bool value);
  public:

  // bool add = 4;
  void clear_add();
  bool add() const;
  void set_add(bool value);
  private:
  bool _internal_add() const;
  void _internal_set_add(bool value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Friend)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playername_;
  ::PROTOBUF_NAMESPACE_ID::int32 playercode_;
  bool access_;
  bool add_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class SFriendSystem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SFriendSystem) */ {
 public:
  inline SFriendSystem() : SFriendSystem(nullptr) {}
  ~SFriendSystem() override;
  explicit constexpr SFriendSystem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SFriendSystem(const SFriendSystem& from);
  SFriendSystem(SFriendSystem&& from) noexcept
    : SFriendSystem() {
    *this = ::std::move(from);
  }

  inline SFriendSystem& operator=(const SFriendSystem& from) {
    CopyFrom(from);
    return *this;
  }
  inline SFriendSystem& operator=(SFriendSystem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SFriendSystem& default_instance() {
    return *internal_default_instance();
  }
  static inline const SFriendSystem* internal_default_instance() {
    return reinterpret_cast<const SFriendSystem*>(
               &_SFriendSystem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(SFriendSystem& a, SFriendSystem& b) {
    a.Swap(&b);
  }
  inline void Swap(SFriendSystem* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SFriendSystem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SFriendSystem* New() const final {
    return new SFriendSystem();
  }

  SFriendSystem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SFriendSystem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SFriendSystem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SFriendSystem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SFriendSystem* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SFriendSystem";
  }
  protected:
  explicit SFriendSystem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFriendFieldNumber = 1,
    kResultFieldNumber = 3,
  };
  // repeated .protocol.Friend friend = 1;
  int friend__size() const;
  private:
  int _internal_friend__size() const;
  public:
  void clear_friend_();
  ::protocol::Friend* mutable_friend_(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Friend >*
      mutable_friend_();
  private:
  const ::protocol::Friend& _internal_friend_(int index) const;
  ::protocol::Friend* _internal_add_friend_();
  public:
  const ::protocol::Friend& friend_(int index) const;
  ::protocol::Friend* add_friend_();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Friend >&
      friend_() const;

  // int32 result = 3;
  void clear_result();
  ::PROTOBUF_NAMESPACE_ID::int32 result() const;
  void set_result(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_result() const;
  void _internal_set_result(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SFriendSystem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Friend > friend__;
  ::PROTOBUF_NAMESPACE_ID::int32 result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class CFriend final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.CFriend) */ {
 public:
  inline CFriend() : CFriend(nullptr) {}
  ~CFriend() override;
  explicit constexpr CFriend(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CFriend(const CFriend& from);
  CFriend(CFriend&& from) noexcept
    : CFriend() {
    *this = ::std::move(from);
  }

  inline CFriend& operator=(const CFriend& from) {
    CopyFrom(from);
    return *this;
  }
  inline CFriend& operator=(CFriend&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CFriend& default_instance() {
    return *internal_default_instance();
  }
  static inline const CFriend* internal_default_instance() {
    return reinterpret_cast<const CFriend*>(
               &_CFriend_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(CFriend& a, CFriend& b) {
    a.Swap(&b);
  }
  inline void Swap(CFriend* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CFriend* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CFriend* New() const final {
    return new CFriend();
  }

  CFriend* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CFriend>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CFriend& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CFriend& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CFriend* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.CFriend";
  }
  protected:
  explicit CFriend(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFriendFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .protocol.Friend friend = 2;
  bool has_friend_() const;
  private:
  bool _internal_has_friend_() const;
  public:
  void clear_friend_();
  const ::protocol::Friend& friend_() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Friend* release_friend_();
  ::protocol::Friend* mutable_friend_();
  void set_allocated_friend_(::protocol::Friend* friend_);
  private:
  const ::protocol::Friend& _internal_friend_() const;
  ::protocol::Friend* _internal_mutable_friend_();
  public:
  void unsafe_arena_set_allocated_friend_(
      ::protocol::Friend* friend_);
  ::protocol::Friend* unsafe_arena_release_friend_();

  // int32 type = 1;
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::int32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.CFriend)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::Friend* friend__;
  ::PROTOBUF_NAMESPACE_ID::int32 type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class CUpdateItems final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.CUpdateItems) */ {
 public:
  inline CUpdateItems() : CUpdateItems(nullptr) {}
  ~CUpdateItems() override;
  explicit constexpr CUpdateItems(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CUpdateItems(const CUpdateItems& from);
  CUpdateItems(CUpdateItems&& from) noexcept
    : CUpdateItems() {
    *this = ::std::move(from);
  }

  inline CUpdateItems& operator=(const CUpdateItems& from) {
    CopyFrom(from);
    return *this;
  }
  inline CUpdateItems& operator=(CUpdateItems&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CUpdateItems& default_instance() {
    return *internal_default_instance();
  }
  static inline const CUpdateItems* internal_default_instance() {
    return reinterpret_cast<const CUpdateItems*>(
               &_CUpdateItems_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(CUpdateItems& a, CUpdateItems& b) {
    a.Swap(&b);
  }
  inline void Swap(CUpdateItems* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CUpdateItems* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CUpdateItems* New() const final {
    return new CUpdateItems();
  }

  CUpdateItems* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CUpdateItems>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CUpdateItems& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CUpdateItems& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CUpdateItems* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.CUpdateItems";
  }
  protected:
  explicit CUpdateItems(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInvenPosFieldNumber = 1,
    kEquipPosFieldNumber = 2,
  };
  // int32 invenPos = 1;
  void clear_invenpos();
  ::PROTOBUF_NAMESPACE_ID::int32 invenpos() const;
  void set_invenpos(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_invenpos() const;
  void _internal_set_invenpos(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 equipPos = 2;
  void clear_equippos();
  ::PROTOBUF_NAMESPACE_ID::int32 equippos() const;
  void set_equippos(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_equippos() const;
  void _internal_set_equippos(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.CUpdateItems)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 invenpos_;
  ::PROTOBUF_NAMESPACE_ID::int32 equippos_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class Mail final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Mail) */ {
 public:
  inline Mail() : Mail(nullptr) {}
  ~Mail() override;
  explicit constexpr Mail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mail(const Mail& from);
  Mail(Mail&& from) noexcept
    : Mail() {
    *this = ::std::move(from);
  }

  inline Mail& operator=(const Mail& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mail& operator=(Mail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mail& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mail* internal_default_instance() {
    return reinterpret_cast<const Mail*>(
               &_Mail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(Mail& a, Mail& b) {
    a.Swap(&b);
  }
  inline void Swap(Mail* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Mail* New() const final {
    return new Mail();
  }

  Mail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Mail>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Mail& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Mail& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mail* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Mail";
  }
  protected:
  explicit Mail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 9,
    kMessageFieldNumber = 10,
    kCodeFieldNumber = 1,
    kReadFieldNumber = 2,
    kGoldFieldNumber = 3,
    kSocket1FieldNumber = 4,
    kSocket1TypeFieldNumber = 5,
    kSocket2FieldNumber = 6,
    kSocket2TypeFieldNumber = 7,
  };
  // string title = 9;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_MUST_USE_RESULT std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string message = 10;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int32 code = 1;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 read = 2;
  void clear_read();
  ::PROTOBUF_NAMESPACE_ID::int32 read() const;
  void set_read(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_read() const;
  void _internal_set_read(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 gold = 3;
  void clear_gold();
  ::PROTOBUF_NAMESPACE_ID::int32 gold() const;
  void set_gold(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_gold() const;
  void _internal_set_gold(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 socket1 = 4;
  void clear_socket1();
  ::PROTOBUF_NAMESPACE_ID::int32 socket1() const;
  void set_socket1(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_socket1() const;
  void _internal_set_socket1(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 socket1Type = 5;
  void clear_socket1type();
  ::PROTOBUF_NAMESPACE_ID::int32 socket1type() const;
  void set_socket1type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_socket1type() const;
  void _internal_set_socket1type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 socket2 = 6;
  void clear_socket2();
  ::PROTOBUF_NAMESPACE_ID::int32 socket2() const;
  void set_socket2(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_socket2() const;
  void _internal_set_socket2(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 socket2Type = 7;
  void clear_socket2type();
  ::PROTOBUF_NAMESPACE_ID::int32 socket2type() const;
  void set_socket2type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_socket2type() const;
  void _internal_set_socket2type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Mail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  ::PROTOBUF_NAMESPACE_ID::int32 read_;
  ::PROTOBUF_NAMESPACE_ID::int32 gold_;
  ::PROTOBUF_NAMESPACE_ID::int32 socket1_;
  ::PROTOBUF_NAMESPACE_ID::int32 socket1type_;
  ::PROTOBUF_NAMESPACE_ID::int32 socket2_;
  ::PROTOBUF_NAMESPACE_ID::int32 socket2type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class MailEquipItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.MailEquipItem) */ {
 public:
  inline MailEquipItem() : MailEquipItem(nullptr) {}
  ~MailEquipItem() override;
  explicit constexpr MailEquipItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MailEquipItem(const MailEquipItem& from);
  MailEquipItem(MailEquipItem&& from) noexcept
    : MailEquipItem() {
    *this = ::std::move(from);
  }

  inline MailEquipItem& operator=(const MailEquipItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline MailEquipItem& operator=(MailEquipItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MailEquipItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const MailEquipItem* internal_default_instance() {
    return reinterpret_cast<const MailEquipItem*>(
               &_MailEquipItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(MailEquipItem& a, MailEquipItem& b) {
    a.Swap(&b);
  }
  inline void Swap(MailEquipItem* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MailEquipItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MailEquipItem* New() const final {
    return new MailEquipItem();
  }

  MailEquipItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MailEquipItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MailEquipItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MailEquipItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MailEquipItem* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.MailEquipItem";
  }
  protected:
  explicit MailEquipItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 3,
    kMailCodeFieldNumber = 1,
    kSocketFieldNumber = 2,
  };
  // .protocol.ItemEquip item = 3;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::protocol::ItemEquip& item() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::ItemEquip* release_item();
  ::protocol::ItemEquip* mutable_item();
  void set_allocated_item(::protocol::ItemEquip* item);
  private:
  const ::protocol::ItemEquip& _internal_item() const;
  ::protocol::ItemEquip* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::protocol::ItemEquip* item);
  ::protocol::ItemEquip* unsafe_arena_release_item();

  // int32 mailCode = 1;
  void clear_mailcode();
  ::PROTOBUF_NAMESPACE_ID::int32 mailcode() const;
  void set_mailcode(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_mailcode() const;
  void _internal_set_mailcode(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 socket = 2;
  void clear_socket();
  ::PROTOBUF_NAMESPACE_ID::int32 socket() const;
  void set_socket(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_socket() const;
  void _internal_set_socket(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.MailEquipItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::ItemEquip* item_;
  ::PROTOBUF_NAMESPACE_ID::int32 mailcode_;
  ::PROTOBUF_NAMESPACE_ID::int32 socket_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class MailEtcItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.MailEtcItem) */ {
 public:
  inline MailEtcItem() : MailEtcItem(nullptr) {}
  ~MailEtcItem() override;
  explicit constexpr MailEtcItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MailEtcItem(const MailEtcItem& from);
  MailEtcItem(MailEtcItem&& from) noexcept
    : MailEtcItem() {
    *this = ::std::move(from);
  }

  inline MailEtcItem& operator=(const MailEtcItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline MailEtcItem& operator=(MailEtcItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MailEtcItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const MailEtcItem* internal_default_instance() {
    return reinterpret_cast<const MailEtcItem*>(
               &_MailEtcItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(MailEtcItem& a, MailEtcItem& b) {
    a.Swap(&b);
  }
  inline void Swap(MailEtcItem* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MailEtcItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MailEtcItem* New() const final {
    return new MailEtcItem();
  }

  MailEtcItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MailEtcItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MailEtcItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MailEtcItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MailEtcItem* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.MailEtcItem";
  }
  protected:
  explicit MailEtcItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 3,
    kMailCodeFieldNumber = 1,
    kSocketFieldNumber = 2,
  };
  // .protocol.ItemEtc item = 3;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::protocol::ItemEtc& item() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::ItemEtc* release_item();
  ::protocol::ItemEtc* mutable_item();
  void set_allocated_item(::protocol::ItemEtc* item);
  private:
  const ::protocol::ItemEtc& _internal_item() const;
  ::protocol::ItemEtc* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::protocol::ItemEtc* item);
  ::protocol::ItemEtc* unsafe_arena_release_item();

  // int32 mailCode = 1;
  void clear_mailcode();
  ::PROTOBUF_NAMESPACE_ID::int32 mailcode() const;
  void set_mailcode(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_mailcode() const;
  void _internal_set_mailcode(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 socket = 2;
  void clear_socket();
  ::PROTOBUF_NAMESPACE_ID::int32 socket() const;
  void set_socket(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_socket() const;
  void _internal_set_socket(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.MailEtcItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::ItemEtc* item_;
  ::PROTOBUF_NAMESPACE_ID::int32 mailcode_;
  ::PROTOBUF_NAMESPACE_ID::int32 socket_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class CLoadMail final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.CLoadMail) */ {
 public:
  inline CLoadMail() : CLoadMail(nullptr) {}
  ~CLoadMail() override;
  explicit constexpr CLoadMail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CLoadMail(const CLoadMail& from);
  CLoadMail(CLoadMail&& from) noexcept
    : CLoadMail() {
    *this = ::std::move(from);
  }

  inline CLoadMail& operator=(const CLoadMail& from) {
    CopyFrom(from);
    return *this;
  }
  inline CLoadMail& operator=(CLoadMail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CLoadMail& default_instance() {
    return *internal_default_instance();
  }
  static inline const CLoadMail* internal_default_instance() {
    return reinterpret_cast<const CLoadMail*>(
               &_CLoadMail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(CLoadMail& a, CLoadMail& b) {
    a.Swap(&b);
  }
  inline void Swap(CLoadMail* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CLoadMail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CLoadMail* New() const final {
    return new CLoadMail();
  }

  CLoadMail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CLoadMail>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CLoadMail& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CLoadMail& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CLoadMail* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.CLoadMail";
  }
  protected:
  explicit CLoadMail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMailsFieldNumber = 2,
    kEquipItemsFieldNumber = 3,
    kEtcItemsFieldNumber = 4,
    kTypeFieldNumber = 1,
  };
  // repeated .protocol.Mail mails = 2;
  int mails_size() const;
  private:
  int _internal_mails_size() const;
  public:
  void clear_mails();
  ::protocol::Mail* mutable_mails(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Mail >*
      mutable_mails();
  private:
  const ::protocol::Mail& _internal_mails(int index) const;
  ::protocol::Mail* _internal_add_mails();
  public:
  const ::protocol::Mail& mails(int index) const;
  ::protocol::Mail* add_mails();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Mail >&
      mails() const;

  // repeated .protocol.MailEquipItem equipItems = 3;
  int equipitems_size() const;
  private:
  int _internal_equipitems_size() const;
  public:
  void clear_equipitems();
  ::protocol::MailEquipItem* mutable_equipitems(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MailEquipItem >*
      mutable_equipitems();
  private:
  const ::protocol::MailEquipItem& _internal_equipitems(int index) const;
  ::protocol::MailEquipItem* _internal_add_equipitems();
  public:
  const ::protocol::MailEquipItem& equipitems(int index) const;
  ::protocol::MailEquipItem* add_equipitems();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MailEquipItem >&
      equipitems() const;

  // repeated .protocol.MailEtcItem etcItems = 4;
  int etcitems_size() const;
  private:
  int _internal_etcitems_size() const;
  public:
  void clear_etcitems();
  ::protocol::MailEtcItem* mutable_etcitems(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MailEtcItem >*
      mutable_etcitems();
  private:
  const ::protocol::MailEtcItem& _internal_etcitems(int index) const;
  ::protocol::MailEtcItem* _internal_add_etcitems();
  public:
  const ::protocol::MailEtcItem& etcitems(int index) const;
  ::protocol::MailEtcItem* add_etcitems();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MailEtcItem >&
      etcitems() const;

  // int32 type = 1;
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::int32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.CLoadMail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Mail > mails_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MailEquipItem > equipitems_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MailEtcItem > etcitems_;
  ::PROTOBUF_NAMESPACE_ID::int32 type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class CUpdateMail final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.CUpdateMail) */ {
 public:
  inline CUpdateMail() : CUpdateMail(nullptr) {}
  ~CUpdateMail() override;
  explicit constexpr CUpdateMail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CUpdateMail(const CUpdateMail& from);
  CUpdateMail(CUpdateMail&& from) noexcept
    : CUpdateMail() {
    *this = ::std::move(from);
  }

  inline CUpdateMail& operator=(const CUpdateMail& from) {
    CopyFrom(from);
    return *this;
  }
  inline CUpdateMail& operator=(CUpdateMail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CUpdateMail& default_instance() {
    return *internal_default_instance();
  }
  static inline const CUpdateMail* internal_default_instance() {
    return reinterpret_cast<const CUpdateMail*>(
               &_CUpdateMail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(CUpdateMail& a, CUpdateMail& b) {
    a.Swap(&b);
  }
  inline void Swap(CUpdateMail* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CUpdateMail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CUpdateMail* New() const final {
    return new CUpdateMail();
  }

  CUpdateMail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CUpdateMail>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CUpdateMail& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CUpdateMail& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CUpdateMail* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.CUpdateMail";
  }
  protected:
  explicit CUpdateMail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMailFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .protocol.Mail mail = 2;
  bool has_mail() const;
  private:
  bool _internal_has_mail() const;
  public:
  void clear_mail();
  const ::protocol::Mail& mail() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Mail* release_mail();
  ::protocol::Mail* mutable_mail();
  void set_allocated_mail(::protocol::Mail* mail);
  private:
  const ::protocol::Mail& _internal_mail() const;
  ::protocol::Mail* _internal_mutable_mail();
  public:
  void unsafe_arena_set_allocated_mail(
      ::protocol::Mail* mail);
  ::protocol::Mail* unsafe_arena_release_mail();

  // int32 type = 1;
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::int32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.CUpdateMail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::Mail* mail_;
  ::PROTOBUF_NAMESPACE_ID::int32 type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class CAllUpdateMail final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.CAllUpdateMail) */ {
 public:
  inline CAllUpdateMail() : CAllUpdateMail(nullptr) {}
  ~CAllUpdateMail() override;
  explicit constexpr CAllUpdateMail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAllUpdateMail(const CAllUpdateMail& from);
  CAllUpdateMail(CAllUpdateMail&& from) noexcept
    : CAllUpdateMail() {
    *this = ::std::move(from);
  }

  inline CAllUpdateMail& operator=(const CAllUpdateMail& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAllUpdateMail& operator=(CAllUpdateMail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAllUpdateMail& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAllUpdateMail* internal_default_instance() {
    return reinterpret_cast<const CAllUpdateMail*>(
               &_CAllUpdateMail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(CAllUpdateMail& a, CAllUpdateMail& b) {
    a.Swap(&b);
  }
  inline void Swap(CAllUpdateMail* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAllUpdateMail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CAllUpdateMail* New() const final {
    return new CAllUpdateMail();
  }

  CAllUpdateMail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CAllUpdateMail>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAllUpdateMail& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAllUpdateMail& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAllUpdateMail* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.CAllUpdateMail";
  }
  protected:
  explicit CAllUpdateMail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMailsFieldNumber = 2,
    kEquipItemsFieldNumber = 3,
    kEtcItemsFieldNumber = 4,
    kTypeFieldNumber = 1,
  };
  // repeated .protocol.Mail mails = 2;
  int mails_size() const;
  private:
  int _internal_mails_size() const;
  public:
  void clear_mails();
  ::protocol::Mail* mutable_mails(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Mail >*
      mutable_mails();
  private:
  const ::protocol::Mail& _internal_mails(int index) const;
  ::protocol::Mail* _internal_add_mails();
  public:
  const ::protocol::Mail& mails(int index) const;
  ::protocol::Mail* add_mails();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Mail >&
      mails() const;

  // repeated .protocol.MailEquipItem equipItems = 3;
  int equipitems_size() const;
  private:
  int _internal_equipitems_size() const;
  public:
  void clear_equipitems();
  ::protocol::MailEquipItem* mutable_equipitems(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MailEquipItem >*
      mutable_equipitems();
  private:
  const ::protocol::MailEquipItem& _internal_equipitems(int index) const;
  ::protocol::MailEquipItem* _internal_add_equipitems();
  public:
  const ::protocol::MailEquipItem& equipitems(int index) const;
  ::protocol::MailEquipItem* add_equipitems();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MailEquipItem >&
      equipitems() const;

  // repeated .protocol.MailEtcItem etcItems = 4;
  int etcitems_size() const;
  private:
  int _internal_etcitems_size() const;
  public:
  void clear_etcitems();
  ::protocol::MailEtcItem* mutable_etcitems(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MailEtcItem >*
      mutable_etcitems();
  private:
  const ::protocol::MailEtcItem& _internal_etcitems(int index) const;
  ::protocol::MailEtcItem* _internal_add_etcitems();
  public:
  const ::protocol::MailEtcItem& etcitems(int index) const;
  ::protocol::MailEtcItem* add_etcitems();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MailEtcItem >&
      etcitems() const;

  // int32 type = 1;
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::int32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.CAllUpdateMail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Mail > mails_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MailEquipItem > equipitems_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MailEtcItem > etcitems_;
  ::PROTOBUF_NAMESPACE_ID::int32 type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class CSendMail final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.CSendMail) */ {
 public:
  inline CSendMail() : CSendMail(nullptr) {}
  ~CSendMail() override;
  explicit constexpr CSendMail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSendMail(const CSendMail& from);
  CSendMail(CSendMail&& from) noexcept
    : CSendMail() {
    *this = ::std::move(from);
  }

  inline CSendMail& operator=(const CSendMail& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSendMail& operator=(CSendMail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSendMail& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSendMail* internal_default_instance() {
    return reinterpret_cast<const CSendMail*>(
               &_CSendMail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(CSendMail& a, CSendMail& b) {
    a.Swap(&b);
  }
  inline void Swap(CSendMail* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSendMail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CSendMail* New() const final {
    return new CSendMail();
  }

  CSendMail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CSendMail>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSendMail& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSendMail& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSendMail* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.CSendMail";
  }
  protected:
  explicit CSendMail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEquipItemsFieldNumber = 3,
    kEtcItemsFieldNumber = 4,
    kMailsFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated .protocol.MailEquipItem equipItems = 3;
  int equipitems_size() const;
  private:
  int _internal_equipitems_size() const;
  public:
  void clear_equipitems();
  ::protocol::MailEquipItem* mutable_equipitems(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MailEquipItem >*
      mutable_equipitems();
  private:
  const ::protocol::MailEquipItem& _internal_equipitems(int index) const;
  ::protocol::MailEquipItem* _internal_add_equipitems();
  public:
  const ::protocol::MailEquipItem& equipitems(int index) const;
  ::protocol::MailEquipItem* add_equipitems();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MailEquipItem >&
      equipitems() const;

  // repeated .protocol.MailEtcItem etcItems = 4;
  int etcitems_size() const;
  private:
  int _internal_etcitems_size() const;
  public:
  void clear_etcitems();
  ::protocol::MailEtcItem* mutable_etcitems(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MailEtcItem >*
      mutable_etcitems();
  private:
  const ::protocol::MailEtcItem& _internal_etcitems(int index) const;
  ::protocol::MailEtcItem* _internal_add_etcitems();
  public:
  const ::protocol::MailEtcItem& etcitems(int index) const;
  ::protocol::MailEtcItem* add_etcitems();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MailEtcItem >&
      etcitems() const;

  // .protocol.Mail mails = 2;
  bool has_mails() const;
  private:
  bool _internal_has_mails() const;
  public:
  void clear_mails();
  const ::protocol::Mail& mails() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Mail* release_mails();
  ::protocol::Mail* mutable_mails();
  void set_allocated_mails(::protocol::Mail* mails);
  private:
  const ::protocol::Mail& _internal_mails() const;
  ::protocol::Mail* _internal_mutable_mails();
  public:
  void unsafe_arena_set_allocated_mails(
      ::protocol::Mail* mails);
  ::protocol::Mail* unsafe_arena_release_mails();

  // int32 type = 1;
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::int32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.CSendMail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MailEquipItem > equipitems_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MailEtcItem > etcitems_;
  ::protocol::Mail* mails_;
  ::PROTOBUF_NAMESPACE_ID::int32 type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class SSendMail final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SSendMail) */ {
 public:
  inline SSendMail() : SSendMail(nullptr) {}
  ~SSendMail() override;
  explicit constexpr SSendMail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SSendMail(const SSendMail& from);
  SSendMail(SSendMail&& from) noexcept
    : SSendMail() {
    *this = ::std::move(from);
  }

  inline SSendMail& operator=(const SSendMail& from) {
    CopyFrom(from);
    return *this;
  }
  inline SSendMail& operator=(SSendMail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SSendMail& default_instance() {
    return *internal_default_instance();
  }
  static inline const SSendMail* internal_default_instance() {
    return reinterpret_cast<const SSendMail*>(
               &_SSendMail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(SSendMail& a, SSendMail& b) {
    a.Swap(&b);
  }
  inline void Swap(SSendMail* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SSendMail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SSendMail* New() const final {
    return new SSendMail();
  }

  SSendMail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SSendMail>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SSendMail& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SSendMail& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SSendMail* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SSendMail";
  }
  protected:
  explicit SSendMail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemEquipsFieldNumber = 3,
    kEtcItemsFieldNumber = 4,
    kResultFieldNumber = 1,
    kGoldFieldNumber = 2,
  };
  // repeated .protocol.ItemEquip itemEquips = 3;
  int itemequips_size() const;
  private:
  int _internal_itemequips_size() const;
  public:
  void clear_itemequips();
  ::protocol::ItemEquip* mutable_itemequips(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >*
      mutable_itemequips();
  private:
  const ::protocol::ItemEquip& _internal_itemequips(int index) const;
  ::protocol::ItemEquip* _internal_add_itemequips();
  public:
  const ::protocol::ItemEquip& itemequips(int index) const;
  ::protocol::ItemEquip* add_itemequips();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >&
      itemequips() const;

  // repeated .protocol.ItemEquip etcItems = 4;
  int etcitems_size() const;
  private:
  int _internal_etcitems_size() const;
  public:
  void clear_etcitems();
  ::protocol::ItemEquip* mutable_etcitems(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >*
      mutable_etcitems();
  private:
  const ::protocol::ItemEquip& _internal_etcitems(int index) const;
  ::protocol::ItemEquip* _internal_add_etcitems();
  public:
  const ::protocol::ItemEquip& etcitems(int index) const;
  ::protocol::ItemEquip* add_etcitems();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >&
      etcitems() const;

  // int32 result = 1;
  void clear_result();
  ::PROTOBUF_NAMESPACE_ID::int32 result() const;
  void set_result(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_result() const;
  void _internal_set_result(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 gold = 2;
  void clear_gold();
  ::PROTOBUF_NAMESPACE_ID::int32 gold() const;
  void set_gold(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_gold() const;
  void _internal_set_gold(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SSendMail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip > itemequips_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip > etcitems_;
  ::PROTOBUF_NAMESPACE_ID::int32 result_;
  ::PROTOBUF_NAMESPACE_ID::int32 gold_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class CAttack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.CAttack) */ {
 public:
  inline CAttack() : CAttack(nullptr) {}
  ~CAttack() override;
  explicit constexpr CAttack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAttack(const CAttack& from);
  CAttack(CAttack&& from) noexcept
    : CAttack() {
    *this = ::std::move(from);
  }

  inline CAttack& operator=(const CAttack& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAttack& operator=(CAttack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAttack& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAttack* internal_default_instance() {
    return reinterpret_cast<const CAttack*>(
               &_CAttack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(CAttack& a, CAttack& b) {
    a.Swap(&b);
  }
  inline void Swap(CAttack* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAttack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CAttack* New() const final {
    return new CAttack();
  }

  CAttack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CAttack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAttack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAttack& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAttack* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.CAttack";
  }
  protected:
  explicit CAttack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 4,
    kAttackNumberFieldNumber = 1,
    kUuidFieldNumber = 2,
    kSkillCodeFieldNumber = 3,
  };
  // .protocol.Position position = 4;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::protocol::Position& position() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Position* release_position();
  ::protocol::Position* mutable_position();
  void set_allocated_position(::protocol::Position* position);
  private:
  const ::protocol::Position& _internal_position() const;
  ::protocol::Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::protocol::Position* position);
  ::protocol::Position* unsafe_arena_release_position();

  // int32 attackNumber = 1;
  void clear_attacknumber();
  ::PROTOBUF_NAMESPACE_ID::int32 attacknumber() const;
  void set_attacknumber(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_attacknumber() const;
  void _internal_set_attacknumber(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 uuid = 2;
  void clear_uuid();
  ::PROTOBUF_NAMESPACE_ID::int32 uuid() const;
  void set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_uuid() const;
  void _internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 skillCode = 3;
  void clear_skillcode();
  ::PROTOBUF_NAMESPACE_ID::int32 skillcode() const;
  void set_skillcode(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_skillcode() const;
  void _internal_set_skillcode(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.CAttack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::Position* position_;
  ::PROTOBUF_NAMESPACE_ID::int32 attacknumber_;
  ::PROTOBUF_NAMESPACE_ID::int32 uuid_;
  ::PROTOBUF_NAMESPACE_ID::int32 skillcode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class UserAttack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.UserAttack) */ {
 public:
  inline UserAttack() : UserAttack(nullptr) {}
  ~UserAttack() override;
  explicit constexpr UserAttack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserAttack(const UserAttack& from);
  UserAttack(UserAttack&& from) noexcept
    : UserAttack() {
    *this = ::std::move(from);
  }

  inline UserAttack& operator=(const UserAttack& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserAttack& operator=(UserAttack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserAttack& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserAttack* internal_default_instance() {
    return reinterpret_cast<const UserAttack*>(
               &_UserAttack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(UserAttack& a, UserAttack& b) {
    a.Swap(&b);
  }
  inline void Swap(UserAttack* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserAttack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserAttack* New() const final {
    return new UserAttack();
  }

  UserAttack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserAttack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserAttack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserAttack& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserAttack* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.UserAttack";
  }
  protected:
  explicit UserAttack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetCodesFieldNumber = 4,
    kPositionFieldNumber = 3,
    kAttackNumberFieldNumber = 1,
    kSkillCodeFieldNumber = 2,
  };
  // repeated int32 targetCodes = 4;
  int targetcodes_size() const;
  private:
  int _internal_targetcodes_size() const;
  public:
  void clear_targetcodes();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_targetcodes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_targetcodes() const;
  void _internal_add_targetcodes(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_targetcodes();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 targetcodes(int index) const;
  void set_targetcodes(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_targetcodes(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      targetcodes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_targetcodes();

  // .protocol.Position position = 3;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::protocol::Position& position() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Position* release_position();
  ::protocol::Position* mutable_position();
  void set_allocated_position(::protocol::Position* position);
  private:
  const ::protocol::Position& _internal_position() const;
  ::protocol::Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::protocol::Position* position);
  ::protocol::Position* unsafe_arena_release_position();

  // int32 attackNumber = 1;
  void clear_attacknumber();
  ::PROTOBUF_NAMESPACE_ID::int32 attacknumber() const;
  void set_attacknumber(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_attacknumber() const;
  void _internal_set_attacknumber(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 skillCode = 2;
  void clear_skillcode();
  ::PROTOBUF_NAMESPACE_ID::int32 skillcode() const;
  void set_skillcode(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_skillcode() const;
  void _internal_set_skillcode(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.UserAttack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > targetcodes_;
  mutable std::atomic<int> _targetcodes_cached_byte_size_;
  ::protocol::Position* position_;
  ::PROTOBUF_NAMESPACE_ID::int32 attacknumber_;
  ::PROTOBUF_NAMESPACE_ID::int32 skillcode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Login

// string id = 1;
inline void Login::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Login::id() const {
  // @@protoc_insertion_point(field_get:protocol.Login.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Login::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Login.id)
}
inline std::string* Login::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:protocol.Login.id)
  return _s;
}
inline const std::string& Login::_internal_id() const {
  return id_.Get();
}
inline void Login::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Login::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Login::release_id() {
  // @@protoc_insertion_point(field_release:protocol.Login.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Login::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.Login.id)
}

// string pwd = 2;
inline void Login::clear_pwd() {
  pwd_.ClearToEmpty();
}
inline const std::string& Login::pwd() const {
  // @@protoc_insertion_point(field_get:protocol.Login.pwd)
  return _internal_pwd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Login::set_pwd(ArgT0&& arg0, ArgT... args) {
 
 pwd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Login.pwd)
}
inline std::string* Login::mutable_pwd() {
  std::string* _s = _internal_mutable_pwd();
  // @@protoc_insertion_point(field_mutable:protocol.Login.pwd)
  return _s;
}
inline const std::string& Login::_internal_pwd() const {
  return pwd_.Get();
}
inline void Login::_internal_set_pwd(const std::string& value) {
  
  pwd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Login::_internal_mutable_pwd() {
  
  return pwd_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Login::release_pwd() {
  // @@protoc_insertion_point(field_release:protocol.Login.pwd)
  return pwd_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Login::set_allocated_pwd(std::string* pwd) {
  if (pwd != nullptr) {
    
  } else {
    
  }
  pwd_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pwd,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.Login.pwd)
}

// -------------------------------------------------------------------

// CreateCharacter

// .protocol.Charater charater = 1;
inline bool CreateCharacter::_internal_has_charater() const {
  return this != internal_default_instance() && charater_ != nullptr;
}
inline bool CreateCharacter::has_charater() const {
  return _internal_has_charater();
}
inline void CreateCharacter::clear_charater() {
  if (GetArenaForAllocation() == nullptr && charater_ != nullptr) {
    delete charater_;
  }
  charater_ = nullptr;
}
inline const ::protocol::Charater& CreateCharacter::_internal_charater() const {
  const ::protocol::Charater* p = charater_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Charater&>(
      ::protocol::_Charater_default_instance_);
}
inline const ::protocol::Charater& CreateCharacter::charater() const {
  // @@protoc_insertion_point(field_get:protocol.CreateCharacter.charater)
  return _internal_charater();
}
inline void CreateCharacter::unsafe_arena_set_allocated_charater(
    ::protocol::Charater* charater) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(charater_);
  }
  charater_ = charater;
  if (charater) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.CreateCharacter.charater)
}
inline ::protocol::Charater* CreateCharacter::release_charater() {
  
  ::protocol::Charater* temp = charater_;
  charater_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Charater* CreateCharacter::unsafe_arena_release_charater() {
  // @@protoc_insertion_point(field_release:protocol.CreateCharacter.charater)
  
  ::protocol::Charater* temp = charater_;
  charater_ = nullptr;
  return temp;
}
inline ::protocol::Charater* CreateCharacter::_internal_mutable_charater() {
  
  if (charater_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Charater>(GetArenaForAllocation());
    charater_ = p;
  }
  return charater_;
}
inline ::protocol::Charater* CreateCharacter::mutable_charater() {
  ::protocol::Charater* _msg = _internal_mutable_charater();
  // @@protoc_insertion_point(field_mutable:protocol.CreateCharacter.charater)
  return _msg;
}
inline void CreateCharacter::set_allocated_charater(::protocol::Charater* charater) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete charater_;
  }
  if (charater) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Charater>::GetOwningArena(charater);
    if (message_arena != submessage_arena) {
      charater = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, charater, submessage_arena);
    }
    
  } else {
    
  }
  charater_ = charater;
  // @@protoc_insertion_point(field_set_allocated:protocol.CreateCharacter.charater)
}

// -------------------------------------------------------------------

// CUpdateAccount

// int32 charaterType = 1;
inline void CUpdateAccount::clear_charatertype() {
  charatertype_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CUpdateAccount::_internal_charatertype() const {
  return charatertype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CUpdateAccount::charatertype() const {
  // @@protoc_insertion_point(field_get:protocol.CUpdateAccount.charaterType)
  return _internal_charatertype();
}
inline void CUpdateAccount::_internal_set_charatertype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  charatertype_ = value;
}
inline void CUpdateAccount::set_charatertype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_charatertype(value);
  // @@protoc_insertion_point(field_set:protocol.CUpdateAccount.charaterType)
}

// int32 weaponType = 2;
inline void CUpdateAccount::clear_weapontype() {
  weapontype_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CUpdateAccount::_internal_weapontype() const {
  return weapontype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CUpdateAccount::weapontype() const {
  // @@protoc_insertion_point(field_get:protocol.CUpdateAccount.weaponType)
  return _internal_weapontype();
}
inline void CUpdateAccount::_internal_set_weapontype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  weapontype_ = value;
}
inline void CUpdateAccount::set_weapontype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_weapontype(value);
  // @@protoc_insertion_point(field_set:protocol.CUpdateAccount.weaponType)
}

// int32 useCash = 3;
inline void CUpdateAccount::clear_usecash() {
  usecash_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CUpdateAccount::_internal_usecash() const {
  return usecash_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CUpdateAccount::usecash() const {
  // @@protoc_insertion_point(field_get:protocol.CUpdateAccount.useCash)
  return _internal_usecash();
}
inline void CUpdateAccount::_internal_set_usecash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  usecash_ = value;
}
inline void CUpdateAccount::set_usecash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_usecash(value);
  // @@protoc_insertion_point(field_set:protocol.CUpdateAccount.useCash)
}

// -------------------------------------------------------------------

// SCurrentInfo

// int32 cash = 1;
inline void SCurrentInfo::clear_cash() {
  cash_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SCurrentInfo::_internal_cash() const {
  return cash_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SCurrentInfo::cash() const {
  // @@protoc_insertion_point(field_get:protocol.SCurrentInfo.cash)
  return _internal_cash();
}
inline void SCurrentInfo::_internal_set_cash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  cash_ = value;
}
inline void SCurrentInfo::set_cash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cash(value);
  // @@protoc_insertion_point(field_set:protocol.SCurrentInfo.cash)
}

// int32 charaterType = 2;
inline void SCurrentInfo::clear_charatertype() {
  charatertype_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SCurrentInfo::_internal_charatertype() const {
  return charatertype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SCurrentInfo::charatertype() const {
  // @@protoc_insertion_point(field_get:protocol.SCurrentInfo.charaterType)
  return _internal_charatertype();
}
inline void SCurrentInfo::_internal_set_charatertype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  charatertype_ = value;
}
inline void SCurrentInfo::set_charatertype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_charatertype(value);
  // @@protoc_insertion_point(field_set:protocol.SCurrentInfo.charaterType)
}

// int32 weaponType = 3;
inline void SCurrentInfo::clear_weapontype() {
  weapontype_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SCurrentInfo::_internal_weapontype() const {
  return weapontype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SCurrentInfo::weapontype() const {
  // @@protoc_insertion_point(field_get:protocol.SCurrentInfo.weaponType)
  return _internal_weapontype();
}
inline void SCurrentInfo::_internal_set_weapontype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  weapontype_ = value;
}
inline void SCurrentInfo::set_weapontype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_weapontype(value);
  // @@protoc_insertion_point(field_set:protocol.SCurrentInfo.weaponType)
}

// .protocol.Charater charater = 4;
inline bool SCurrentInfo::_internal_has_charater() const {
  return this != internal_default_instance() && charater_ != nullptr;
}
inline bool SCurrentInfo::has_charater() const {
  return _internal_has_charater();
}
inline void SCurrentInfo::clear_charater() {
  if (GetArenaForAllocation() == nullptr && charater_ != nullptr) {
    delete charater_;
  }
  charater_ = nullptr;
}
inline const ::protocol::Charater& SCurrentInfo::_internal_charater() const {
  const ::protocol::Charater* p = charater_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Charater&>(
      ::protocol::_Charater_default_instance_);
}
inline const ::protocol::Charater& SCurrentInfo::charater() const {
  // @@protoc_insertion_point(field_get:protocol.SCurrentInfo.charater)
  return _internal_charater();
}
inline void SCurrentInfo::unsafe_arena_set_allocated_charater(
    ::protocol::Charater* charater) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(charater_);
  }
  charater_ = charater;
  if (charater) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.SCurrentInfo.charater)
}
inline ::protocol::Charater* SCurrentInfo::release_charater() {
  
  ::protocol::Charater* temp = charater_;
  charater_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Charater* SCurrentInfo::unsafe_arena_release_charater() {
  // @@protoc_insertion_point(field_release:protocol.SCurrentInfo.charater)
  
  ::protocol::Charater* temp = charater_;
  charater_ = nullptr;
  return temp;
}
inline ::protocol::Charater* SCurrentInfo::_internal_mutable_charater() {
  
  if (charater_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Charater>(GetArenaForAllocation());
    charater_ = p;
  }
  return charater_;
}
inline ::protocol::Charater* SCurrentInfo::mutable_charater() {
  ::protocol::Charater* _msg = _internal_mutable_charater();
  // @@protoc_insertion_point(field_mutable:protocol.SCurrentInfo.charater)
  return _msg;
}
inline void SCurrentInfo::set_allocated_charater(::protocol::Charater* charater) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete charater_;
  }
  if (charater) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Charater>::GetOwningArena(charater);
    if (message_arena != submessage_arena) {
      charater = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, charater, submessage_arena);
    }
    
  } else {
    
  }
  charater_ = charater;
  // @@protoc_insertion_point(field_set_allocated:protocol.SCurrentInfo.charater)
}

// int32 exp = 5;
inline void SCurrentInfo::clear_exp() {
  exp_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SCurrentInfo::_internal_exp() const {
  return exp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SCurrentInfo::exp() const {
  // @@protoc_insertion_point(field_get:protocol.SCurrentInfo.exp)
  return _internal_exp();
}
inline void SCurrentInfo::_internal_set_exp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  exp_ = value;
}
inline void SCurrentInfo::set_exp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:protocol.SCurrentInfo.exp)
}

// -------------------------------------------------------------------

// LoginAccess

// int32 result = 1;
inline void LoginAccess::clear_result() {
  result_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginAccess::_internal_result() const {
  return result_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginAccess::result() const {
  // @@protoc_insertion_point(field_get:protocol.LoginAccess.result)
  return _internal_result();
}
inline void LoginAccess::_internal_set_result(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  result_ = value;
}
inline void LoginAccess::set_result(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:protocol.LoginAccess.result)
}

// repeated .protocol.Charater charater = 2;
inline int LoginAccess::_internal_charater_size() const {
  return charater_.size();
}
inline int LoginAccess::charater_size() const {
  return _internal_charater_size();
}
inline void LoginAccess::clear_charater() {
  charater_.Clear();
}
inline ::protocol::Charater* LoginAccess::mutable_charater(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.LoginAccess.charater)
  return charater_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Charater >*
LoginAccess::mutable_charater() {
  // @@protoc_insertion_point(field_mutable_list:protocol.LoginAccess.charater)
  return &charater_;
}
inline const ::protocol::Charater& LoginAccess::_internal_charater(int index) const {
  return charater_.Get(index);
}
inline const ::protocol::Charater& LoginAccess::charater(int index) const {
  // @@protoc_insertion_point(field_get:protocol.LoginAccess.charater)
  return _internal_charater(index);
}
inline ::protocol::Charater* LoginAccess::_internal_add_charater() {
  return charater_.Add();
}
inline ::protocol::Charater* LoginAccess::add_charater() {
  ::protocol::Charater* _add = _internal_add_charater();
  // @@protoc_insertion_point(field_add:protocol.LoginAccess.charater)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Charater >&
LoginAccess::charater() const {
  // @@protoc_insertion_point(field_list:protocol.LoginAccess.charater)
  return charater_;
}

// int32 curCharaterType = 3;
inline void LoginAccess::clear_curcharatertype() {
  curcharatertype_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginAccess::_internal_curcharatertype() const {
  return curcharatertype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginAccess::curcharatertype() const {
  // @@protoc_insertion_point(field_get:protocol.LoginAccess.curCharaterType)
  return _internal_curcharatertype();
}
inline void LoginAccess::_internal_set_curcharatertype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  curcharatertype_ = value;
}
inline void LoginAccess::set_curcharatertype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_curcharatertype(value);
  // @@protoc_insertion_point(field_set:protocol.LoginAccess.curCharaterType)
}

// int32 curWeaponType = 4;
inline void LoginAccess::clear_curweapontype() {
  curweapontype_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginAccess::_internal_curweapontype() const {
  return curweapontype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginAccess::curweapontype() const {
  // @@protoc_insertion_point(field_get:protocol.LoginAccess.curWeaponType)
  return _internal_curweapontype();
}
inline void LoginAccess::_internal_set_curweapontype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  curweapontype_ = value;
}
inline void LoginAccess::set_curweapontype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_curweapontype(value);
  // @@protoc_insertion_point(field_set:protocol.LoginAccess.curWeaponType)
}

// int32 cash = 5;
inline void LoginAccess::clear_cash() {
  cash_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginAccess::_internal_cash() const {
  return cash_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginAccess::cash() const {
  // @@protoc_insertion_point(field_get:protocol.LoginAccess.cash)
  return _internal_cash();
}
inline void LoginAccess::_internal_set_cash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  cash_ = value;
}
inline void LoginAccess::set_cash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cash(value);
  // @@protoc_insertion_point(field_set:protocol.LoginAccess.cash)
}

// repeated int32 weaponList = 6;
inline int LoginAccess::_internal_weaponlist_size() const {
  return weaponlist_.size();
}
inline int LoginAccess::weaponlist_size() const {
  return _internal_weaponlist_size();
}
inline void LoginAccess::clear_weaponlist() {
  weaponlist_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginAccess::_internal_weaponlist(int index) const {
  return weaponlist_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginAccess::weaponlist(int index) const {
  // @@protoc_insertion_point(field_get:protocol.LoginAccess.weaponList)
  return _internal_weaponlist(index);
}
inline void LoginAccess::set_weaponlist(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  weaponlist_.Set(index, value);
  // @@protoc_insertion_point(field_set:protocol.LoginAccess.weaponList)
}
inline void LoginAccess::_internal_add_weaponlist(::PROTOBUF_NAMESPACE_ID::int32 value) {
  weaponlist_.Add(value);
}
inline void LoginAccess::add_weaponlist(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_weaponlist(value);
  // @@protoc_insertion_point(field_add:protocol.LoginAccess.weaponList)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
LoginAccess::_internal_weaponlist() const {
  return weaponlist_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
LoginAccess::weaponlist() const {
  // @@protoc_insertion_point(field_list:protocol.LoginAccess.weaponList)
  return _internal_weaponlist();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
LoginAccess::_internal_mutable_weaponlist() {
  return &weaponlist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
LoginAccess::mutable_weaponlist() {
  // @@protoc_insertion_point(field_mutable_list:protocol.LoginAccess.weaponList)
  return _internal_mutable_weaponlist();
}

// -------------------------------------------------------------------

// Charater

// int32 uuid = 1;
inline void Charater::clear_uuid() {
  uuid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Charater::_internal_uuid() const {
  return uuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Charater::uuid() const {
  // @@protoc_insertion_point(field_get:protocol.Charater.uuid)
  return _internal_uuid();
}
inline void Charater::_internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  uuid_ = value;
}
inline void Charater::set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:protocol.Charater.uuid)
}

// int32 code = 2;
inline void Charater::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Charater::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Charater::code() const {
  // @@protoc_insertion_point(field_get:protocol.Charater.code)
  return _internal_code();
}
inline void Charater::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void Charater::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:protocol.Charater.code)
}

// string name = 3;
inline void Charater::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Charater::name() const {
  // @@protoc_insertion_point(field_get:protocol.Charater.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Charater::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Charater.name)
}
inline std::string* Charater::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:protocol.Charater.name)
  return _s;
}
inline const std::string& Charater::_internal_name() const {
  return name_.Get();
}
inline void Charater::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Charater::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Charater::release_name() {
  // @@protoc_insertion_point(field_release:protocol.Charater.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Charater::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.Charater.name)
}

// int32 lv = 4;
inline void Charater::clear_lv() {
  lv_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Charater::_internal_lv() const {
  return lv_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Charater::lv() const {
  // @@protoc_insertion_point(field_get:protocol.Charater.lv)
  return _internal_lv();
}
inline void Charater::_internal_set_lv(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  lv_ = value;
}
inline void Charater::set_lv(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_lv(value);
  // @@protoc_insertion_point(field_set:protocol.Charater.lv)
}

// -------------------------------------------------------------------

// Position

// float x = 1;
inline void Position::clear_x() {
  x_ = 0;
}
inline float Position::_internal_x() const {
  return x_;
}
inline float Position::x() const {
  // @@protoc_insertion_point(field_get:protocol.Position.x)
  return _internal_x();
}
inline void Position::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Position::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:protocol.Position.x)
}

// float y = 2;
inline void Position::clear_y() {
  y_ = 0;
}
inline float Position::_internal_y() const {
  return y_;
}
inline float Position::y() const {
  // @@protoc_insertion_point(field_get:protocol.Position.y)
  return _internal_y();
}
inline void Position::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Position::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:protocol.Position.y)
}

// float z = 3;
inline void Position::clear_z() {
  z_ = 0;
}
inline float Position::_internal_z() const {
  return z_;
}
inline float Position::z() const {
  // @@protoc_insertion_point(field_get:protocol.Position.z)
  return _internal_z();
}
inline void Position::_internal_set_z(float value) {
  
  z_ = value;
}
inline void Position::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:protocol.Position.z)
}

// float yaw = 4;
inline void Position::clear_yaw() {
  yaw_ = 0;
}
inline float Position::_internal_yaw() const {
  return yaw_;
}
inline float Position::yaw() const {
  // @@protoc_insertion_point(field_get:protocol.Position.yaw)
  return _internal_yaw();
}
inline void Position::_internal_set_yaw(float value) {
  
  yaw_ = value;
}
inline void Position::set_yaw(float value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:protocol.Position.yaw)
}

// -------------------------------------------------------------------

// Unit

// uint32 uuid = 1;
inline void Unit::clear_uuid() {
  uuid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Unit::_internal_uuid() const {
  return uuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Unit::uuid() const {
  // @@protoc_insertion_point(field_get:protocol.Unit.uuid)
  return _internal_uuid();
}
inline void Unit::_internal_set_uuid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  uuid_ = value;
}
inline void Unit::set_uuid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:protocol.Unit.uuid)
}

// uint32 hp = 2;
inline void Unit::clear_hp() {
  hp_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Unit::_internal_hp() const {
  return hp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Unit::hp() const {
  // @@protoc_insertion_point(field_get:protocol.Unit.hp)
  return _internal_hp();
}
inline void Unit::_internal_set_hp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  hp_ = value;
}
inline void Unit::set_hp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:protocol.Unit.hp)
}

// int32 code = 3;
inline void Unit::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Unit::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Unit::code() const {
  // @@protoc_insertion_point(field_get:protocol.Unit.code)
  return _internal_code();
}
inline void Unit::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void Unit::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:protocol.Unit.code)
}

// .protocol.Position position = 4;
inline bool Unit::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool Unit::has_position() const {
  return _internal_has_position();
}
inline void Unit::clear_position() {
  if (GetArenaForAllocation() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::protocol::Position& Unit::_internal_position() const {
  const ::protocol::Position* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Position&>(
      ::protocol::_Position_default_instance_);
}
inline const ::protocol::Position& Unit::position() const {
  // @@protoc_insertion_point(field_get:protocol.Unit.position)
  return _internal_position();
}
inline void Unit::unsafe_arena_set_allocated_position(
    ::protocol::Position* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.Unit.position)
}
inline ::protocol::Position* Unit::release_position() {
  
  ::protocol::Position* temp = position_;
  position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Position* Unit::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:protocol.Unit.position)
  
  ::protocol::Position* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::protocol::Position* Unit::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Position>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::protocol::Position* Unit::mutable_position() {
  ::protocol::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:protocol.Unit.position)
  return _msg;
}
inline void Unit::set_allocated_position(::protocol::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Position>::GetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:protocol.Unit.position)
}

// string name = 5;
inline void Unit::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Unit::name() const {
  // @@protoc_insertion_point(field_get:protocol.Unit.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Unit::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Unit.name)
}
inline std::string* Unit::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:protocol.Unit.name)
  return _s;
}
inline const std::string& Unit::_internal_name() const {
  return name_.Get();
}
inline void Unit::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Unit::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Unit::release_name() {
  // @@protoc_insertion_point(field_release:protocol.Unit.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Unit::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.Unit.name)
}

// int32 lv = 6;
inline void Unit::clear_lv() {
  lv_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Unit::_internal_lv() const {
  return lv_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Unit::lv() const {
  // @@protoc_insertion_point(field_get:protocol.Unit.lv)
  return _internal_lv();
}
inline void Unit::_internal_set_lv(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  lv_ = value;
}
inline void Unit::set_lv(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_lv(value);
  // @@protoc_insertion_point(field_set:protocol.Unit.lv)
}

// int32 state = 7;
inline void Unit::clear_state() {
  state_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Unit::_internal_state() const {
  return state_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Unit::state() const {
  // @@protoc_insertion_point(field_get:protocol.Unit.state)
  return _internal_state();
}
inline void Unit::_internal_set_state(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  state_ = value;
}
inline void Unit::set_state(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:protocol.Unit.state)
}

// int32 weaponCode = 8;
inline void Unit::clear_weaponcode() {
  weaponcode_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Unit::_internal_weaponcode() const {
  return weaponcode_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Unit::weaponcode() const {
  // @@protoc_insertion_point(field_get:protocol.Unit.weaponCode)
  return _internal_weaponcode();
}
inline void Unit::_internal_set_weaponcode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  weaponcode_ = value;
}
inline void Unit::set_weaponcode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_weaponcode(value);
  // @@protoc_insertion_point(field_set:protocol.Unit.weaponCode)
}

// -------------------------------------------------------------------

// SLoad

// repeated .protocol.UnitState unit = 1;
inline int SLoad::_internal_unit_size() const {
  return unit_.size();
}
inline int SLoad::unit_size() const {
  return _internal_unit_size();
}
inline void SLoad::clear_unit() {
  unit_.Clear();
}
inline ::protocol::UnitState* SLoad::mutable_unit(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.SLoad.unit)
  return unit_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::UnitState >*
SLoad::mutable_unit() {
  // @@protoc_insertion_point(field_mutable_list:protocol.SLoad.unit)
  return &unit_;
}
inline const ::protocol::UnitState& SLoad::_internal_unit(int index) const {
  return unit_.Get(index);
}
inline const ::protocol::UnitState& SLoad::unit(int index) const {
  // @@protoc_insertion_point(field_get:protocol.SLoad.unit)
  return _internal_unit(index);
}
inline ::protocol::UnitState* SLoad::_internal_add_unit() {
  return unit_.Add();
}
inline ::protocol::UnitState* SLoad::add_unit() {
  ::protocol::UnitState* _add = _internal_add_unit();
  // @@protoc_insertion_point(field_add:protocol.SLoad.unit)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::UnitState >&
SLoad::unit() const {
  // @@protoc_insertion_point(field_list:protocol.SLoad.unit)
  return unit_;
}

// int32 room_id = 3;
inline void SLoad::clear_room_id() {
  room_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SLoad::_internal_room_id() const {
  return room_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SLoad::room_id() const {
  // @@protoc_insertion_point(field_get:protocol.SLoad.room_id)
  return _internal_room_id();
}
inline void SLoad::_internal_set_room_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  room_id_ = value;
}
inline void SLoad::set_room_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_room_id(value);
  // @@protoc_insertion_point(field_set:protocol.SLoad.room_id)
}

// -------------------------------------------------------------------

// CLoad

// int32 uuid = 1;
inline void CLoad::clear_uuid() {
  uuid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CLoad::_internal_uuid() const {
  return uuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CLoad::uuid() const {
  // @@protoc_insertion_point(field_get:protocol.CLoad.uuid)
  return _internal_uuid();
}
inline void CLoad::_internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  uuid_ = value;
}
inline void CLoad::set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:protocol.CLoad.uuid)
}

// .protocol.Position position = 100;
inline bool CLoad::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool CLoad::has_position() const {
  return _internal_has_position();
}
inline void CLoad::clear_position() {
  if (GetArenaForAllocation() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::protocol::Position& CLoad::_internal_position() const {
  const ::protocol::Position* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Position&>(
      ::protocol::_Position_default_instance_);
}
inline const ::protocol::Position& CLoad::position() const {
  // @@protoc_insertion_point(field_get:protocol.CLoad.position)
  return _internal_position();
}
inline void CLoad::unsafe_arena_set_allocated_position(
    ::protocol::Position* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.CLoad.position)
}
inline ::protocol::Position* CLoad::release_position() {
  
  ::protocol::Position* temp = position_;
  position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Position* CLoad::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:protocol.CLoad.position)
  
  ::protocol::Position* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::protocol::Position* CLoad::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Position>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::protocol::Position* CLoad::mutable_position() {
  ::protocol::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:protocol.CLoad.position)
  return _msg;
}
inline void CLoad::set_allocated_position(::protocol::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Position>::GetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:protocol.CLoad.position)
}

// -------------------------------------------------------------------

// SInsertplayer

// .protocol.Unit player = 1;
inline bool SInsertplayer::_internal_has_player() const {
  return this != internal_default_instance() && player_ != nullptr;
}
inline bool SInsertplayer::has_player() const {
  return _internal_has_player();
}
inline void SInsertplayer::clear_player() {
  if (GetArenaForAllocation() == nullptr && player_ != nullptr) {
    delete player_;
  }
  player_ = nullptr;
}
inline const ::protocol::Unit& SInsertplayer::_internal_player() const {
  const ::protocol::Unit* p = player_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Unit&>(
      ::protocol::_Unit_default_instance_);
}
inline const ::protocol::Unit& SInsertplayer::player() const {
  // @@protoc_insertion_point(field_get:protocol.SInsertplayer.player)
  return _internal_player();
}
inline void SInsertplayer::unsafe_arena_set_allocated_player(
    ::protocol::Unit* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_);
  }
  player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.SInsertplayer.player)
}
inline ::protocol::Unit* SInsertplayer::release_player() {
  
  ::protocol::Unit* temp = player_;
  player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Unit* SInsertplayer::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:protocol.SInsertplayer.player)
  
  ::protocol::Unit* temp = player_;
  player_ = nullptr;
  return temp;
}
inline ::protocol::Unit* SInsertplayer::_internal_mutable_player() {
  
  if (player_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Unit>(GetArenaForAllocation());
    player_ = p;
  }
  return player_;
}
inline ::protocol::Unit* SInsertplayer::mutable_player() {
  ::protocol::Unit* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:protocol.SInsertplayer.player)
  return _msg;
}
inline void SInsertplayer::set_allocated_player(::protocol::Unit* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Unit>::GetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:protocol.SInsertplayer.player)
}

// -------------------------------------------------------------------

// SMove

// int32 uuid = 1;
inline void SMove::clear_uuid() {
  uuid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SMove::_internal_uuid() const {
  return uuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SMove::uuid() const {
  // @@protoc_insertion_point(field_get:protocol.SMove.uuid)
  return _internal_uuid();
}
inline void SMove::_internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  uuid_ = value;
}
inline void SMove::set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:protocol.SMove.uuid)
}

// .protocol.Position position = 2;
inline bool SMove::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool SMove::has_position() const {
  return _internal_has_position();
}
inline void SMove::clear_position() {
  if (GetArenaForAllocation() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::protocol::Position& SMove::_internal_position() const {
  const ::protocol::Position* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Position&>(
      ::protocol::_Position_default_instance_);
}
inline const ::protocol::Position& SMove::position() const {
  // @@protoc_insertion_point(field_get:protocol.SMove.position)
  return _internal_position();
}
inline void SMove::unsafe_arena_set_allocated_position(
    ::protocol::Position* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.SMove.position)
}
inline ::protocol::Position* SMove::release_position() {
  
  ::protocol::Position* temp = position_;
  position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Position* SMove::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:protocol.SMove.position)
  
  ::protocol::Position* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::protocol::Position* SMove::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Position>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::protocol::Position* SMove::mutable_position() {
  ::protocol::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:protocol.SMove.position)
  return _msg;
}
inline void SMove::set_allocated_position(::protocol::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Position>::GetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:protocol.SMove.position)
}

// bool is_monster = 3;
inline void SMove::clear_is_monster() {
  is_monster_ = false;
}
inline bool SMove::_internal_is_monster() const {
  return is_monster_;
}
inline bool SMove::is_monster() const {
  // @@protoc_insertion_point(field_get:protocol.SMove.is_monster)
  return _internal_is_monster();
}
inline void SMove::_internal_set_is_monster(bool value) {
  
  is_monster_ = value;
}
inline void SMove::set_is_monster(bool value) {
  _internal_set_is_monster(value);
  // @@protoc_insertion_point(field_set:protocol.SMove.is_monster)
}

// -------------------------------------------------------------------

// SChat

// uint32 type = 1;
inline void SChat::clear_type() {
  type_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SChat::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SChat::type() const {
  // @@protoc_insertion_point(field_get:protocol.SChat.type)
  return _internal_type();
}
inline void SChat::_internal_set_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  type_ = value;
}
inline void SChat::set_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:protocol.SChat.type)
}

// int32 uuid = 2;
inline void SChat::clear_uuid() {
  uuid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SChat::_internal_uuid() const {
  return uuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SChat::uuid() const {
  // @@protoc_insertion_point(field_get:protocol.SChat.uuid)
  return _internal_uuid();
}
inline void SChat::_internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  uuid_ = value;
}
inline void SChat::set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:protocol.SChat.uuid)
}

// string text = 5;
inline void SChat::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& SChat::text() const {
  // @@protoc_insertion_point(field_get:protocol.SChat.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SChat::set_text(ArgT0&& arg0, ArgT... args) {
 
 text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.SChat.text)
}
inline std::string* SChat::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:protocol.SChat.text)
  return _s;
}
inline const std::string& SChat::_internal_text() const {
  return text_.Get();
}
inline void SChat::_internal_set_text(const std::string& value) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SChat::_internal_mutable_text() {
  
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SChat::release_text() {
  // @@protoc_insertion_point(field_release:protocol.SChat.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SChat::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.SChat.text)
}

// -------------------------------------------------------------------

// SPlayerData

// .protocol.Unit player = 1;
inline bool SPlayerData::_internal_has_player() const {
  return this != internal_default_instance() && player_ != nullptr;
}
inline bool SPlayerData::has_player() const {
  return _internal_has_player();
}
inline void SPlayerData::clear_player() {
  if (GetArenaForAllocation() == nullptr && player_ != nullptr) {
    delete player_;
  }
  player_ = nullptr;
}
inline const ::protocol::Unit& SPlayerData::_internal_player() const {
  const ::protocol::Unit* p = player_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Unit&>(
      ::protocol::_Unit_default_instance_);
}
inline const ::protocol::Unit& SPlayerData::player() const {
  // @@protoc_insertion_point(field_get:protocol.SPlayerData.player)
  return _internal_player();
}
inline void SPlayerData::unsafe_arena_set_allocated_player(
    ::protocol::Unit* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_);
  }
  player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.SPlayerData.player)
}
inline ::protocol::Unit* SPlayerData::release_player() {
  
  ::protocol::Unit* temp = player_;
  player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Unit* SPlayerData::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:protocol.SPlayerData.player)
  
  ::protocol::Unit* temp = player_;
  player_ = nullptr;
  return temp;
}
inline ::protocol::Unit* SPlayerData::_internal_mutable_player() {
  
  if (player_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Unit>(GetArenaForAllocation());
    player_ = p;
  }
  return player_;
}
inline ::protocol::Unit* SPlayerData::mutable_player() {
  ::protocol::Unit* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:protocol.SPlayerData.player)
  return _msg;
}
inline void SPlayerData::set_allocated_player(::protocol::Unit* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Unit>::GetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:protocol.SPlayerData.player)
}

// int32 exp = 2;
inline void SPlayerData::clear_exp() {
  exp_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SPlayerData::_internal_exp() const {
  return exp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SPlayerData::exp() const {
  // @@protoc_insertion_point(field_get:protocol.SPlayerData.exp)
  return _internal_exp();
}
inline void SPlayerData::_internal_set_exp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  exp_ = value;
}
inline void SPlayerData::set_exp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:protocol.SPlayerData.exp)
}

// -------------------------------------------------------------------

// SClosePlayer

// int32 uuid = 1;
inline void SClosePlayer::clear_uuid() {
  uuid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SClosePlayer::_internal_uuid() const {
  return uuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SClosePlayer::uuid() const {
  // @@protoc_insertion_point(field_get:protocol.SClosePlayer.uuid)
  return _internal_uuid();
}
inline void SClosePlayer::_internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  uuid_ = value;
}
inline void SClosePlayer::set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:protocol.SClosePlayer.uuid)
}

// -------------------------------------------------------------------

// UnitState

// .protocol.Unit unit = 1;
inline bool UnitState::_internal_has_unit() const {
  return this != internal_default_instance() && unit_ != nullptr;
}
inline bool UnitState::has_unit() const {
  return _internal_has_unit();
}
inline void UnitState::clear_unit() {
  if (GetArenaForAllocation() == nullptr && unit_ != nullptr) {
    delete unit_;
  }
  unit_ = nullptr;
}
inline const ::protocol::Unit& UnitState::_internal_unit() const {
  const ::protocol::Unit* p = unit_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Unit&>(
      ::protocol::_Unit_default_instance_);
}
inline const ::protocol::Unit& UnitState::unit() const {
  // @@protoc_insertion_point(field_get:protocol.UnitState.unit)
  return _internal_unit();
}
inline void UnitState::unsafe_arena_set_allocated_unit(
    ::protocol::Unit* unit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(unit_);
  }
  unit_ = unit;
  if (unit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.UnitState.unit)
}
inline ::protocol::Unit* UnitState::release_unit() {
  
  ::protocol::Unit* temp = unit_;
  unit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Unit* UnitState::unsafe_arena_release_unit() {
  // @@protoc_insertion_point(field_release:protocol.UnitState.unit)
  
  ::protocol::Unit* temp = unit_;
  unit_ = nullptr;
  return temp;
}
inline ::protocol::Unit* UnitState::_internal_mutable_unit() {
  
  if (unit_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Unit>(GetArenaForAllocation());
    unit_ = p;
  }
  return unit_;
}
inline ::protocol::Unit* UnitState::mutable_unit() {
  ::protocol::Unit* _msg = _internal_mutable_unit();
  // @@protoc_insertion_point(field_mutable:protocol.UnitState.unit)
  return _msg;
}
inline void UnitState::set_allocated_unit(::protocol::Unit* unit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete unit_;
  }
  if (unit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Unit>::GetOwningArena(unit);
    if (message_arena != submessage_arena) {
      unit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unit, submessage_arena);
    }
    
  } else {
    
  }
  unit_ = unit;
  // @@protoc_insertion_point(field_set_allocated:protocol.UnitState.unit)
}

// bool is_monster = 10;
inline void UnitState::clear_is_monster() {
  is_monster_ = false;
}
inline bool UnitState::_internal_is_monster() const {
  return is_monster_;
}
inline bool UnitState::is_monster() const {
  // @@protoc_insertion_point(field_get:protocol.UnitState.is_monster)
  return _internal_is_monster();
}
inline void UnitState::_internal_set_is_monster(bool value) {
  
  is_monster_ = value;
}
inline void UnitState::set_is_monster(bool value) {
  _internal_set_is_monster(value);
  // @@protoc_insertion_point(field_set:protocol.UnitState.is_monster)
}

// .protocol.Attack attack = 11;
inline bool UnitState::_internal_has_attack() const {
  return this != internal_default_instance() && attack_ != nullptr;
}
inline bool UnitState::has_attack() const {
  return _internal_has_attack();
}
inline void UnitState::clear_attack() {
  if (GetArenaForAllocation() == nullptr && attack_ != nullptr) {
    delete attack_;
  }
  attack_ = nullptr;
}
inline const ::protocol::Attack& UnitState::_internal_attack() const {
  const ::protocol::Attack* p = attack_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Attack&>(
      ::protocol::_Attack_default_instance_);
}
inline const ::protocol::Attack& UnitState::attack() const {
  // @@protoc_insertion_point(field_get:protocol.UnitState.attack)
  return _internal_attack();
}
inline void UnitState::unsafe_arena_set_allocated_attack(
    ::protocol::Attack* attack) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attack_);
  }
  attack_ = attack;
  if (attack) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.UnitState.attack)
}
inline ::protocol::Attack* UnitState::release_attack() {
  
  ::protocol::Attack* temp = attack_;
  attack_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Attack* UnitState::unsafe_arena_release_attack() {
  // @@protoc_insertion_point(field_release:protocol.UnitState.attack)
  
  ::protocol::Attack* temp = attack_;
  attack_ = nullptr;
  return temp;
}
inline ::protocol::Attack* UnitState::_internal_mutable_attack() {
  
  if (attack_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Attack>(GetArenaForAllocation());
    attack_ = p;
  }
  return attack_;
}
inline ::protocol::Attack* UnitState::mutable_attack() {
  ::protocol::Attack* _msg = _internal_mutable_attack();
  // @@protoc_insertion_point(field_mutable:protocol.UnitState.attack)
  return _msg;
}
inline void UnitState::set_allocated_attack(::protocol::Attack* attack) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete attack_;
  }
  if (attack) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Attack>::GetOwningArena(attack);
    if (message_arena != submessage_arena) {
      attack = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attack, submessage_arena);
    }
    
  } else {
    
  }
  attack_ = attack;
  // @@protoc_insertion_point(field_set_allocated:protocol.UnitState.attack)
}

// -------------------------------------------------------------------

// SUnitStates

// repeated .protocol.UnitState unit_state = 1;
inline int SUnitStates::_internal_unit_state_size() const {
  return unit_state_.size();
}
inline int SUnitStates::unit_state_size() const {
  return _internal_unit_state_size();
}
inline void SUnitStates::clear_unit_state() {
  unit_state_.Clear();
}
inline ::protocol::UnitState* SUnitStates::mutable_unit_state(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.SUnitStates.unit_state)
  return unit_state_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::UnitState >*
SUnitStates::mutable_unit_state() {
  // @@protoc_insertion_point(field_mutable_list:protocol.SUnitStates.unit_state)
  return &unit_state_;
}
inline const ::protocol::UnitState& SUnitStates::_internal_unit_state(int index) const {
  return unit_state_.Get(index);
}
inline const ::protocol::UnitState& SUnitStates::unit_state(int index) const {
  // @@protoc_insertion_point(field_get:protocol.SUnitStates.unit_state)
  return _internal_unit_state(index);
}
inline ::protocol::UnitState* SUnitStates::_internal_add_unit_state() {
  return unit_state_.Add();
}
inline ::protocol::UnitState* SUnitStates::add_unit_state() {
  ::protocol::UnitState* _add = _internal_add_unit_state();
  // @@protoc_insertion_point(field_add:protocol.SUnitStates.unit_state)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::UnitState >&
SUnitStates::unit_state() const {
  // @@protoc_insertion_point(field_list:protocol.SUnitStates.unit_state)
  return unit_state_;
}

// -------------------------------------------------------------------

// Attack

// int32 uuid = 1;
inline void Attack::clear_uuid() {
  uuid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Attack::_internal_uuid() const {
  return uuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Attack::uuid() const {
  // @@protoc_insertion_point(field_get:protocol.Attack.uuid)
  return _internal_uuid();
}
inline void Attack::_internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  uuid_ = value;
}
inline void Attack::set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:protocol.Attack.uuid)
}

// int32 skill_code = 2;
inline void Attack::clear_skill_code() {
  skill_code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Attack::_internal_skill_code() const {
  return skill_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Attack::skill_code() const {
  // @@protoc_insertion_point(field_get:protocol.Attack.skill_code)
  return _internal_skill_code();
}
inline void Attack::_internal_set_skill_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  skill_code_ = value;
}
inline void Attack::set_skill_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_skill_code(value);
  // @@protoc_insertion_point(field_set:protocol.Attack.skill_code)
}

// int32 target_uuid = 3;
inline void Attack::clear_target_uuid() {
  target_uuid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Attack::_internal_target_uuid() const {
  return target_uuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Attack::target_uuid() const {
  // @@protoc_insertion_point(field_get:protocol.Attack.target_uuid)
  return _internal_target_uuid();
}
inline void Attack::_internal_set_target_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  target_uuid_ = value;
}
inline void Attack::set_target_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_target_uuid(value);
  // @@protoc_insertion_point(field_set:protocol.Attack.target_uuid)
}

// -------------------------------------------------------------------

// Demage

// int32 uuid = 1;
inline void Demage::clear_uuid() {
  uuid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Demage::_internal_uuid() const {
  return uuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Demage::uuid() const {
  // @@protoc_insertion_point(field_get:protocol.Demage.uuid)
  return _internal_uuid();
}
inline void Demage::_internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  uuid_ = value;
}
inline void Demage::set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:protocol.Demage.uuid)
}

// int32 demage = 2;
inline void Demage::clear_demage() {
  demage_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Demage::_internal_demage() const {
  return demage_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Demage::demage() const {
  // @@protoc_insertion_point(field_get:protocol.Demage.demage)
  return _internal_demage();
}
inline void Demage::_internal_set_demage(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  demage_ = value;
}
inline void Demage::set_demage(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_demage(value);
  // @@protoc_insertion_point(field_set:protocol.Demage.demage)
}

// .protocol.Position position = 3;
inline bool Demage::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool Demage::has_position() const {
  return _internal_has_position();
}
inline void Demage::clear_position() {
  if (GetArenaForAllocation() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::protocol::Position& Demage::_internal_position() const {
  const ::protocol::Position* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Position&>(
      ::protocol::_Position_default_instance_);
}
inline const ::protocol::Position& Demage::position() const {
  // @@protoc_insertion_point(field_get:protocol.Demage.position)
  return _internal_position();
}
inline void Demage::unsafe_arena_set_allocated_position(
    ::protocol::Position* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.Demage.position)
}
inline ::protocol::Position* Demage::release_position() {
  
  ::protocol::Position* temp = position_;
  position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Position* Demage::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:protocol.Demage.position)
  
  ::protocol::Position* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::protocol::Position* Demage::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Position>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::protocol::Position* Demage::mutable_position() {
  ::protocol::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:protocol.Demage.position)
  return _msg;
}
inline void Demage::set_allocated_position(::protocol::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Position>::GetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:protocol.Demage.position)
}

// bool is_heal = 4;
inline void Demage::clear_is_heal() {
  is_heal_ = false;
}
inline bool Demage::_internal_is_heal() const {
  return is_heal_;
}
inline bool Demage::is_heal() const {
  // @@protoc_insertion_point(field_get:protocol.Demage.is_heal)
  return _internal_is_heal();
}
inline void Demage::_internal_set_is_heal(bool value) {
  
  is_heal_ = value;
}
inline void Demage::set_is_heal(bool value) {
  _internal_set_is_heal(value);
  // @@protoc_insertion_point(field_set:protocol.Demage.is_heal)
}

// bool is_monster = 10;
inline void Demage::clear_is_monster() {
  is_monster_ = false;
}
inline bool Demage::_internal_is_monster() const {
  return is_monster_;
}
inline bool Demage::is_monster() const {
  // @@protoc_insertion_point(field_get:protocol.Demage.is_monster)
  return _internal_is_monster();
}
inline void Demage::_internal_set_is_monster(bool value) {
  
  is_monster_ = value;
}
inline void Demage::set_is_monster(bool value) {
  _internal_set_is_monster(value);
  // @@protoc_insertion_point(field_set:protocol.Demage.is_monster)
}

// -------------------------------------------------------------------

// SUnitDemage

// int32 uuid = 1;
inline void SUnitDemage::clear_uuid() {
  uuid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SUnitDemage::_internal_uuid() const {
  return uuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SUnitDemage::uuid() const {
  // @@protoc_insertion_point(field_get:protocol.SUnitDemage.uuid)
  return _internal_uuid();
}
inline void SUnitDemage::_internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  uuid_ = value;
}
inline void SUnitDemage::set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:protocol.SUnitDemage.uuid)
}

// bool is_monster = 2;
inline void SUnitDemage::clear_is_monster() {
  is_monster_ = false;
}
inline bool SUnitDemage::_internal_is_monster() const {
  return is_monster_;
}
inline bool SUnitDemage::is_monster() const {
  // @@protoc_insertion_point(field_get:protocol.SUnitDemage.is_monster)
  return _internal_is_monster();
}
inline void SUnitDemage::_internal_set_is_monster(bool value) {
  
  is_monster_ = value;
}
inline void SUnitDemage::set_is_monster(bool value) {
  _internal_set_is_monster(value);
  // @@protoc_insertion_point(field_set:protocol.SUnitDemage.is_monster)
}

// repeated .protocol.Demage demage = 3;
inline int SUnitDemage::_internal_demage_size() const {
  return demage_.size();
}
inline int SUnitDemage::demage_size() const {
  return _internal_demage_size();
}
inline void SUnitDemage::clear_demage() {
  demage_.Clear();
}
inline ::protocol::Demage* SUnitDemage::mutable_demage(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.SUnitDemage.demage)
  return demage_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Demage >*
SUnitDemage::mutable_demage() {
  // @@protoc_insertion_point(field_mutable_list:protocol.SUnitDemage.demage)
  return &demage_;
}
inline const ::protocol::Demage& SUnitDemage::_internal_demage(int index) const {
  return demage_.Get(index);
}
inline const ::protocol::Demage& SUnitDemage::demage(int index) const {
  // @@protoc_insertion_point(field_get:protocol.SUnitDemage.demage)
  return _internal_demage(index);
}
inline ::protocol::Demage* SUnitDemage::_internal_add_demage() {
  return demage_.Add();
}
inline ::protocol::Demage* SUnitDemage::add_demage() {
  ::protocol::Demage* _add = _internal_add_demage();
  // @@protoc_insertion_point(field_add:protocol.SUnitDemage.demage)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Demage >&
SUnitDemage::demage() const {
  // @@protoc_insertion_point(field_list:protocol.SUnitDemage.demage)
  return demage_;
}

// -------------------------------------------------------------------

// SRoomQuest

// bool is_clear = 1;
inline void SRoomQuest::clear_is_clear() {
  is_clear_ = false;
}
inline bool SRoomQuest::_internal_is_clear() const {
  return is_clear_;
}
inline bool SRoomQuest::is_clear() const {
  // @@protoc_insertion_point(field_get:protocol.SRoomQuest.is_clear)
  return _internal_is_clear();
}
inline void SRoomQuest::_internal_set_is_clear(bool value) {
  
  is_clear_ = value;
}
inline void SRoomQuest::set_is_clear(bool value) {
  _internal_set_is_clear(value);
  // @@protoc_insertion_point(field_set:protocol.SRoomQuest.is_clear)
}

// int32 kill_count = 2;
inline void SRoomQuest::clear_kill_count() {
  kill_count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SRoomQuest::_internal_kill_count() const {
  return kill_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SRoomQuest::kill_count() const {
  // @@protoc_insertion_point(field_get:protocol.SRoomQuest.kill_count)
  return _internal_kill_count();
}
inline void SRoomQuest::_internal_set_kill_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  kill_count_ = value;
}
inline void SRoomQuest::set_kill_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_kill_count(value);
  // @@protoc_insertion_point(field_set:protocol.SRoomQuest.kill_count)
}

// int32 sum_kill = 3;
inline void SRoomQuest::clear_sum_kill() {
  sum_kill_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SRoomQuest::_internal_sum_kill() const {
  return sum_kill_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SRoomQuest::sum_kill() const {
  // @@protoc_insertion_point(field_get:protocol.SRoomQuest.sum_kill)
  return _internal_sum_kill();
}
inline void SRoomQuest::_internal_set_sum_kill(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  sum_kill_ = value;
}
inline void SRoomQuest::set_sum_kill(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_sum_kill(value);
  // @@protoc_insertion_point(field_set:protocol.SRoomQuest.sum_kill)
}

// -------------------------------------------------------------------

// CMovePotal

// int32 pre_room_id = 1;
inline void CMovePotal::clear_pre_room_id() {
  pre_room_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CMovePotal::_internal_pre_room_id() const {
  return pre_room_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CMovePotal::pre_room_id() const {
  // @@protoc_insertion_point(field_get:protocol.CMovePotal.pre_room_id)
  return _internal_pre_room_id();
}
inline void CMovePotal::_internal_set_pre_room_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  pre_room_id_ = value;
}
inline void CMovePotal::set_pre_room_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_pre_room_id(value);
  // @@protoc_insertion_point(field_set:protocol.CMovePotal.pre_room_id)
}

// int32 next_room_id = 2;
inline void CMovePotal::clear_next_room_id() {
  next_room_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CMovePotal::_internal_next_room_id() const {
  return next_room_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CMovePotal::next_room_id() const {
  // @@protoc_insertion_point(field_get:protocol.CMovePotal.next_room_id)
  return _internal_next_room_id();
}
inline void CMovePotal::_internal_set_next_room_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  next_room_id_ = value;
}
inline void CMovePotal::set_next_room_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_next_room_id(value);
  // @@protoc_insertion_point(field_set:protocol.CMovePotal.next_room_id)
}

// -------------------------------------------------------------------

// SEndGame

// bool end_game = 1;
inline void SEndGame::clear_end_game() {
  end_game_ = false;
}
inline bool SEndGame::_internal_end_game() const {
  return end_game_;
}
inline bool SEndGame::end_game() const {
  // @@protoc_insertion_point(field_get:protocol.SEndGame.end_game)
  return _internal_end_game();
}
inline void SEndGame::_internal_set_end_game(bool value) {
  
  end_game_ = value;
}
inline void SEndGame::set_end_game(bool value) {
  _internal_set_end_game(value);
  // @@protoc_insertion_point(field_set:protocol.SEndGame.end_game)
}

// -------------------------------------------------------------------

// CBuyCharater

// int32 CharaterType = 1;
inline void CBuyCharater::clear_charatertype() {
  charatertype_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CBuyCharater::_internal_charatertype() const {
  return charatertype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CBuyCharater::charatertype() const {
  // @@protoc_insertion_point(field_get:protocol.CBuyCharater.CharaterType)
  return _internal_charatertype();
}
inline void CBuyCharater::_internal_set_charatertype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  charatertype_ = value;
}
inline void CBuyCharater::set_charatertype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_charatertype(value);
  // @@protoc_insertion_point(field_set:protocol.CBuyCharater.CharaterType)
}

// int32 useCash = 2;
inline void CBuyCharater::clear_usecash() {
  usecash_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CBuyCharater::_internal_usecash() const {
  return usecash_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CBuyCharater::usecash() const {
  // @@protoc_insertion_point(field_get:protocol.CBuyCharater.useCash)
  return _internal_usecash();
}
inline void CBuyCharater::_internal_set_usecash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  usecash_ = value;
}
inline void CBuyCharater::set_usecash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_usecash(value);
  // @@protoc_insertion_point(field_set:protocol.CBuyCharater.useCash)
}

// string name = 3;
inline void CBuyCharater::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CBuyCharater::name() const {
  // @@protoc_insertion_point(field_get:protocol.CBuyCharater.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CBuyCharater::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.CBuyCharater.name)
}
inline std::string* CBuyCharater::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:protocol.CBuyCharater.name)
  return _s;
}
inline const std::string& CBuyCharater::_internal_name() const {
  return name_.Get();
}
inline void CBuyCharater::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CBuyCharater::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CBuyCharater::release_name() {
  // @@protoc_insertion_point(field_release:protocol.CBuyCharater.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CBuyCharater::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.CBuyCharater.name)
}

// -------------------------------------------------------------------

// CBuyWeapon

// int32 weaponType = 1;
inline void CBuyWeapon::clear_weapontype() {
  weapontype_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CBuyWeapon::_internal_weapontype() const {
  return weapontype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CBuyWeapon::weapontype() const {
  // @@protoc_insertion_point(field_get:protocol.CBuyWeapon.weaponType)
  return _internal_weapontype();
}
inline void CBuyWeapon::_internal_set_weapontype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  weapontype_ = value;
}
inline void CBuyWeapon::set_weapontype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_weapontype(value);
  // @@protoc_insertion_point(field_set:protocol.CBuyWeapon.weaponType)
}

// int32 useCash = 2;
inline void CBuyWeapon::clear_usecash() {
  usecash_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CBuyWeapon::_internal_usecash() const {
  return usecash_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CBuyWeapon::usecash() const {
  // @@protoc_insertion_point(field_get:protocol.CBuyWeapon.useCash)
  return _internal_usecash();
}
inline void CBuyWeapon::_internal_set_usecash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  usecash_ = value;
}
inline void CBuyWeapon::set_usecash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_usecash(value);
  // @@protoc_insertion_point(field_set:protocol.CBuyWeapon.useCash)
}

// -------------------------------------------------------------------

// SBuyResult

// int32 result = 1;
inline void SBuyResult::clear_result() {
  result_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SBuyResult::_internal_result() const {
  return result_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SBuyResult::result() const {
  // @@protoc_insertion_point(field_get:protocol.SBuyResult.result)
  return _internal_result();
}
inline void SBuyResult::_internal_set_result(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  result_ = value;
}
inline void SBuyResult::set_result(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:protocol.SBuyResult.result)
}

// repeated .protocol.Charater charater = 2;
inline int SBuyResult::_internal_charater_size() const {
  return charater_.size();
}
inline int SBuyResult::charater_size() const {
  return _internal_charater_size();
}
inline void SBuyResult::clear_charater() {
  charater_.Clear();
}
inline ::protocol::Charater* SBuyResult::mutable_charater(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.SBuyResult.charater)
  return charater_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Charater >*
SBuyResult::mutable_charater() {
  // @@protoc_insertion_point(field_mutable_list:protocol.SBuyResult.charater)
  return &charater_;
}
inline const ::protocol::Charater& SBuyResult::_internal_charater(int index) const {
  return charater_.Get(index);
}
inline const ::protocol::Charater& SBuyResult::charater(int index) const {
  // @@protoc_insertion_point(field_get:protocol.SBuyResult.charater)
  return _internal_charater(index);
}
inline ::protocol::Charater* SBuyResult::_internal_add_charater() {
  return charater_.Add();
}
inline ::protocol::Charater* SBuyResult::add_charater() {
  ::protocol::Charater* _add = _internal_add_charater();
  // @@protoc_insertion_point(field_add:protocol.SBuyResult.charater)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Charater >&
SBuyResult::charater() const {
  // @@protoc_insertion_point(field_list:protocol.SBuyResult.charater)
  return charater_;
}

// int32 curCharaterType = 3;
inline void SBuyResult::clear_curcharatertype() {
  curcharatertype_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SBuyResult::_internal_curcharatertype() const {
  return curcharatertype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SBuyResult::curcharatertype() const {
  // @@protoc_insertion_point(field_get:protocol.SBuyResult.curCharaterType)
  return _internal_curcharatertype();
}
inline void SBuyResult::_internal_set_curcharatertype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  curcharatertype_ = value;
}
inline void SBuyResult::set_curcharatertype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_curcharatertype(value);
  // @@protoc_insertion_point(field_set:protocol.SBuyResult.curCharaterType)
}

// int32 curWeaponType = 4;
inline void SBuyResult::clear_curweapontype() {
  curweapontype_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SBuyResult::_internal_curweapontype() const {
  return curweapontype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SBuyResult::curweapontype() const {
  // @@protoc_insertion_point(field_get:protocol.SBuyResult.curWeaponType)
  return _internal_curweapontype();
}
inline void SBuyResult::_internal_set_curweapontype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  curweapontype_ = value;
}
inline void SBuyResult::set_curweapontype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_curweapontype(value);
  // @@protoc_insertion_point(field_set:protocol.SBuyResult.curWeaponType)
}

// int32 cash = 5;
inline void SBuyResult::clear_cash() {
  cash_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SBuyResult::_internal_cash() const {
  return cash_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SBuyResult::cash() const {
  // @@protoc_insertion_point(field_get:protocol.SBuyResult.cash)
  return _internal_cash();
}
inline void SBuyResult::_internal_set_cash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  cash_ = value;
}
inline void SBuyResult::set_cash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cash(value);
  // @@protoc_insertion_point(field_set:protocol.SBuyResult.cash)
}

// repeated int32 weaponList = 6;
inline int SBuyResult::_internal_weaponlist_size() const {
  return weaponlist_.size();
}
inline int SBuyResult::weaponlist_size() const {
  return _internal_weaponlist_size();
}
inline void SBuyResult::clear_weaponlist() {
  weaponlist_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SBuyResult::_internal_weaponlist(int index) const {
  return weaponlist_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SBuyResult::weaponlist(int index) const {
  // @@protoc_insertion_point(field_get:protocol.SBuyResult.weaponList)
  return _internal_weaponlist(index);
}
inline void SBuyResult::set_weaponlist(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  weaponlist_.Set(index, value);
  // @@protoc_insertion_point(field_set:protocol.SBuyResult.weaponList)
}
inline void SBuyResult::_internal_add_weaponlist(::PROTOBUF_NAMESPACE_ID::int32 value) {
  weaponlist_.Add(value);
}
inline void SBuyResult::add_weaponlist(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_weaponlist(value);
  // @@protoc_insertion_point(field_add:protocol.SBuyResult.weaponList)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
SBuyResult::_internal_weaponlist() const {
  return weaponlist_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
SBuyResult::weaponlist() const {
  // @@protoc_insertion_point(field_list:protocol.SBuyResult.weaponList)
  return _internal_weaponlist();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
SBuyResult::_internal_mutable_weaponlist() {
  return &weaponlist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
SBuyResult::mutable_weaponlist() {
  // @@protoc_insertion_point(field_mutable_list:protocol.SBuyResult.weaponList)
  return _internal_mutable_weaponlist();
}

// -------------------------------------------------------------------

// CPlayerJump

// bool isJump = 1;
inline void CPlayerJump::clear_isjump() {
  isjump_ = false;
}
inline bool CPlayerJump::_internal_isjump() const {
  return isjump_;
}
inline bool CPlayerJump::isjump() const {
  // @@protoc_insertion_point(field_get:protocol.CPlayerJump.isJump)
  return _internal_isjump();
}
inline void CPlayerJump::_internal_set_isjump(bool value) {
  
  isjump_ = value;
}
inline void CPlayerJump::set_isjump(bool value) {
  _internal_set_isjump(value);
  // @@protoc_insertion_point(field_set:protocol.CPlayerJump.isJump)
}

// int32 uuid = 2;
inline void CPlayerJump::clear_uuid() {
  uuid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CPlayerJump::_internal_uuid() const {
  return uuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CPlayerJump::uuid() const {
  // @@protoc_insertion_point(field_get:protocol.CPlayerJump.uuid)
  return _internal_uuid();
}
inline void CPlayerJump::_internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  uuid_ = value;
}
inline void CPlayerJump::set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:protocol.CPlayerJump.uuid)
}

// -------------------------------------------------------------------

// CPlayerAim

// bool isAim = 1;
inline void CPlayerAim::clear_isaim() {
  isaim_ = false;
}
inline bool CPlayerAim::_internal_isaim() const {
  return isaim_;
}
inline bool CPlayerAim::isaim() const {
  // @@protoc_insertion_point(field_get:protocol.CPlayerAim.isAim)
  return _internal_isaim();
}
inline void CPlayerAim::_internal_set_isaim(bool value) {
  
  isaim_ = value;
}
inline void CPlayerAim::set_isaim(bool value) {
  _internal_set_isaim(value);
  // @@protoc_insertion_point(field_set:protocol.CPlayerAim.isAim)
}

// int32 uuid = 2;
inline void CPlayerAim::clear_uuid() {
  uuid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CPlayerAim::_internal_uuid() const {
  return uuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CPlayerAim::uuid() const {
  // @@protoc_insertion_point(field_get:protocol.CPlayerAim.uuid)
  return _internal_uuid();
}
inline void CPlayerAim::_internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  uuid_ = value;
}
inline void CPlayerAim::set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:protocol.CPlayerAim.uuid)
}

// -------------------------------------------------------------------

// SExpLv

// int32 uuid = 1;
inline void SExpLv::clear_uuid() {
  uuid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SExpLv::_internal_uuid() const {
  return uuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SExpLv::uuid() const {
  // @@protoc_insertion_point(field_get:protocol.SExpLv.uuid)
  return _internal_uuid();
}
inline void SExpLv::_internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  uuid_ = value;
}
inline void SExpLv::set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:protocol.SExpLv.uuid)
}

// int32 lv = 2;
inline void SExpLv::clear_lv() {
  lv_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SExpLv::_internal_lv() const {
  return lv_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SExpLv::lv() const {
  // @@protoc_insertion_point(field_get:protocol.SExpLv.lv)
  return _internal_lv();
}
inline void SExpLv::_internal_set_lv(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  lv_ = value;
}
inline void SExpLv::set_lv(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_lv(value);
  // @@protoc_insertion_point(field_set:protocol.SExpLv.lv)
}

// int32 exp = 3;
inline void SExpLv::clear_exp() {
  exp_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SExpLv::_internal_exp() const {
  return exp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SExpLv::exp() const {
  // @@protoc_insertion_point(field_get:protocol.SExpLv.exp)
  return _internal_exp();
}
inline void SExpLv::_internal_set_exp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  exp_ = value;
}
inline void SExpLv::set_exp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:protocol.SExpLv.exp)
}

// -------------------------------------------------------------------

// ItemEquip

// int32 item_code = 1;
inline void ItemEquip::clear_item_code() {
  item_code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ItemEquip::_internal_item_code() const {
  return item_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ItemEquip::item_code() const {
  // @@protoc_insertion_point(field_get:protocol.ItemEquip.item_code)
  return _internal_item_code();
}
inline void ItemEquip::_internal_set_item_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  item_code_ = value;
}
inline void ItemEquip::set_item_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_item_code(value);
  // @@protoc_insertion_point(field_set:protocol.ItemEquip.item_code)
}

// int32 item_type = 2;
inline void ItemEquip::clear_item_type() {
  item_type_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ItemEquip::_internal_item_type() const {
  return item_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ItemEquip::item_type() const {
  // @@protoc_insertion_point(field_get:protocol.ItemEquip.item_type)
  return _internal_item_type();
}
inline void ItemEquip::_internal_set_item_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  item_type_ = value;
}
inline void ItemEquip::set_item_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_item_type(value);
  // @@protoc_insertion_point(field_set:protocol.ItemEquip.item_type)
}

// int32 attack = 3;
inline void ItemEquip::clear_attack() {
  attack_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ItemEquip::_internal_attack() const {
  return attack_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ItemEquip::attack() const {
  // @@protoc_insertion_point(field_get:protocol.ItemEquip.attack)
  return _internal_attack();
}
inline void ItemEquip::_internal_set_attack(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  attack_ = value;
}
inline void ItemEquip::set_attack(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_attack(value);
  // @@protoc_insertion_point(field_set:protocol.ItemEquip.attack)
}

// int32 speed = 4;
inline void ItemEquip::clear_speed() {
  speed_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ItemEquip::_internal_speed() const {
  return speed_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ItemEquip::speed() const {
  // @@protoc_insertion_point(field_get:protocol.ItemEquip.speed)
  return _internal_speed();
}
inline void ItemEquip::_internal_set_speed(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  speed_ = value;
}
inline void ItemEquip::set_speed(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:protocol.ItemEquip.speed)
}

// int32 equipPos = 5;
inline void ItemEquip::clear_equippos() {
  equippos_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ItemEquip::_internal_equippos() const {
  return equippos_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ItemEquip::equippos() const {
  // @@protoc_insertion_point(field_get:protocol.ItemEquip.equipPos)
  return _internal_equippos();
}
inline void ItemEquip::_internal_set_equippos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  equippos_ = value;
}
inline void ItemEquip::set_equippos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_equippos(value);
  // @@protoc_insertion_point(field_set:protocol.ItemEquip.equipPos)
}

// int32 invenPos = 7;
inline void ItemEquip::clear_invenpos() {
  invenpos_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ItemEquip::_internal_invenpos() const {
  return invenpos_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ItemEquip::invenpos() const {
  // @@protoc_insertion_point(field_get:protocol.ItemEquip.invenPos)
  return _internal_invenpos();
}
inline void ItemEquip::_internal_set_invenpos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  invenpos_ = value;
}
inline void ItemEquip::set_invenpos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_invenpos(value);
  // @@protoc_insertion_point(field_set:protocol.ItemEquip.invenPos)
}

// -------------------------------------------------------------------

// ItemEtc

// int32 item_code = 1;
inline void ItemEtc::clear_item_code() {
  item_code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ItemEtc::_internal_item_code() const {
  return item_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ItemEtc::item_code() const {
  // @@protoc_insertion_point(field_get:protocol.ItemEtc.item_code)
  return _internal_item_code();
}
inline void ItemEtc::_internal_set_item_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  item_code_ = value;
}
inline void ItemEtc::set_item_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_item_code(value);
  // @@protoc_insertion_point(field_set:protocol.ItemEtc.item_code)
}

// int32 item_count = 2;
inline void ItemEtc::clear_item_count() {
  item_count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ItemEtc::_internal_item_count() const {
  return item_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ItemEtc::item_count() const {
  // @@protoc_insertion_point(field_get:protocol.ItemEtc.item_count)
  return _internal_item_count();
}
inline void ItemEtc::_internal_set_item_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  item_count_ = value;
}
inline void ItemEtc::set_item_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_item_count(value);
  // @@protoc_insertion_point(field_set:protocol.ItemEtc.item_count)
}

// int32 item_type = 3;
inline void ItemEtc::clear_item_type() {
  item_type_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ItemEtc::_internal_item_type() const {
  return item_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ItemEtc::item_type() const {
  // @@protoc_insertion_point(field_get:protocol.ItemEtc.item_type)
  return _internal_item_type();
}
inline void ItemEtc::_internal_set_item_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  item_type_ = value;
}
inline void ItemEtc::set_item_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_item_type(value);
  // @@protoc_insertion_point(field_set:protocol.ItemEtc.item_type)
}

// int32 invenPos = 4;
inline void ItemEtc::clear_invenpos() {
  invenpos_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ItemEtc::_internal_invenpos() const {
  return invenpos_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ItemEtc::invenpos() const {
  // @@protoc_insertion_point(field_get:protocol.ItemEtc.invenPos)
  return _internal_invenpos();
}
inline void ItemEtc::_internal_set_invenpos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  invenpos_ = value;
}
inline void ItemEtc::set_invenpos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_invenpos(value);
  // @@protoc_insertion_point(field_set:protocol.ItemEtc.invenPos)
}

// -------------------------------------------------------------------

// UpdateInventory

// repeated .protocol.ItemEquip itemEquips = 1;
inline int UpdateInventory::_internal_itemequips_size() const {
  return itemequips_.size();
}
inline int UpdateInventory::itemequips_size() const {
  return _internal_itemequips_size();
}
inline void UpdateInventory::clear_itemequips() {
  itemequips_.Clear();
}
inline ::protocol::ItemEquip* UpdateInventory::mutable_itemequips(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.UpdateInventory.itemEquips)
  return itemequips_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >*
UpdateInventory::mutable_itemequips() {
  // @@protoc_insertion_point(field_mutable_list:protocol.UpdateInventory.itemEquips)
  return &itemequips_;
}
inline const ::protocol::ItemEquip& UpdateInventory::_internal_itemequips(int index) const {
  return itemequips_.Get(index);
}
inline const ::protocol::ItemEquip& UpdateInventory::itemequips(int index) const {
  // @@protoc_insertion_point(field_get:protocol.UpdateInventory.itemEquips)
  return _internal_itemequips(index);
}
inline ::protocol::ItemEquip* UpdateInventory::_internal_add_itemequips() {
  return itemequips_.Add();
}
inline ::protocol::ItemEquip* UpdateInventory::add_itemequips() {
  ::protocol::ItemEquip* _add = _internal_add_itemequips();
  // @@protoc_insertion_point(field_add:protocol.UpdateInventory.itemEquips)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >&
UpdateInventory::itemequips() const {
  // @@protoc_insertion_point(field_list:protocol.UpdateInventory.itemEquips)
  return itemequips_;
}

// repeated .protocol.ItemEtc itemEtcs = 2;
inline int UpdateInventory::_internal_itemetcs_size() const {
  return itemetcs_.size();
}
inline int UpdateInventory::itemetcs_size() const {
  return _internal_itemetcs_size();
}
inline void UpdateInventory::clear_itemetcs() {
  itemetcs_.Clear();
}
inline ::protocol::ItemEtc* UpdateInventory::mutable_itemetcs(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.UpdateInventory.itemEtcs)
  return itemetcs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEtc >*
UpdateInventory::mutable_itemetcs() {
  // @@protoc_insertion_point(field_mutable_list:protocol.UpdateInventory.itemEtcs)
  return &itemetcs_;
}
inline const ::protocol::ItemEtc& UpdateInventory::_internal_itemetcs(int index) const {
  return itemetcs_.Get(index);
}
inline const ::protocol::ItemEtc& UpdateInventory::itemetcs(int index) const {
  // @@protoc_insertion_point(field_get:protocol.UpdateInventory.itemEtcs)
  return _internal_itemetcs(index);
}
inline ::protocol::ItemEtc* UpdateInventory::_internal_add_itemetcs() {
  return itemetcs_.Add();
}
inline ::protocol::ItemEtc* UpdateInventory::add_itemetcs() {
  ::protocol::ItemEtc* _add = _internal_add_itemetcs();
  // @@protoc_insertion_point(field_add:protocol.UpdateInventory.itemEtcs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEtc >&
UpdateInventory::itemetcs() const {
  // @@protoc_insertion_point(field_list:protocol.UpdateInventory.itemEtcs)
  return itemetcs_;
}

// int32 gold = 3;
inline void UpdateInventory::clear_gold() {
  gold_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateInventory::_internal_gold() const {
  return gold_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UpdateInventory::gold() const {
  // @@protoc_insertion_point(field_get:protocol.UpdateInventory.gold)
  return _internal_gold();
}
inline void UpdateInventory::_internal_set_gold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  gold_ = value;
}
inline void UpdateInventory::set_gold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:protocol.UpdateInventory.gold)
}

// -------------------------------------------------------------------

// SLoadInventory

// repeated .protocol.ItemEquip itemEquips = 1;
inline int SLoadInventory::_internal_itemequips_size() const {
  return itemequips_.size();
}
inline int SLoadInventory::itemequips_size() const {
  return _internal_itemequips_size();
}
inline void SLoadInventory::clear_itemequips() {
  itemequips_.Clear();
}
inline ::protocol::ItemEquip* SLoadInventory::mutable_itemequips(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.SLoadInventory.itemEquips)
  return itemequips_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >*
SLoadInventory::mutable_itemequips() {
  // @@protoc_insertion_point(field_mutable_list:protocol.SLoadInventory.itemEquips)
  return &itemequips_;
}
inline const ::protocol::ItemEquip& SLoadInventory::_internal_itemequips(int index) const {
  return itemequips_.Get(index);
}
inline const ::protocol::ItemEquip& SLoadInventory::itemequips(int index) const {
  // @@protoc_insertion_point(field_get:protocol.SLoadInventory.itemEquips)
  return _internal_itemequips(index);
}
inline ::protocol::ItemEquip* SLoadInventory::_internal_add_itemequips() {
  return itemequips_.Add();
}
inline ::protocol::ItemEquip* SLoadInventory::add_itemequips() {
  ::protocol::ItemEquip* _add = _internal_add_itemequips();
  // @@protoc_insertion_point(field_add:protocol.SLoadInventory.itemEquips)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >&
SLoadInventory::itemequips() const {
  // @@protoc_insertion_point(field_list:protocol.SLoadInventory.itemEquips)
  return itemequips_;
}

// repeated .protocol.ItemEtc itemEtcs = 2;
inline int SLoadInventory::_internal_itemetcs_size() const {
  return itemetcs_.size();
}
inline int SLoadInventory::itemetcs_size() const {
  return _internal_itemetcs_size();
}
inline void SLoadInventory::clear_itemetcs() {
  itemetcs_.Clear();
}
inline ::protocol::ItemEtc* SLoadInventory::mutable_itemetcs(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.SLoadInventory.itemEtcs)
  return itemetcs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEtc >*
SLoadInventory::mutable_itemetcs() {
  // @@protoc_insertion_point(field_mutable_list:protocol.SLoadInventory.itemEtcs)
  return &itemetcs_;
}
inline const ::protocol::ItemEtc& SLoadInventory::_internal_itemetcs(int index) const {
  return itemetcs_.Get(index);
}
inline const ::protocol::ItemEtc& SLoadInventory::itemetcs(int index) const {
  // @@protoc_insertion_point(field_get:protocol.SLoadInventory.itemEtcs)
  return _internal_itemetcs(index);
}
inline ::protocol::ItemEtc* SLoadInventory::_internal_add_itemetcs() {
  return itemetcs_.Add();
}
inline ::protocol::ItemEtc* SLoadInventory::add_itemetcs() {
  ::protocol::ItemEtc* _add = _internal_add_itemetcs();
  // @@protoc_insertion_point(field_add:protocol.SLoadInventory.itemEtcs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEtc >&
SLoadInventory::itemetcs() const {
  // @@protoc_insertion_point(field_list:protocol.SLoadInventory.itemEtcs)
  return itemetcs_;
}

// int32 gold = 3;
inline void SLoadInventory::clear_gold() {
  gold_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SLoadInventory::_internal_gold() const {
  return gold_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SLoadInventory::gold() const {
  // @@protoc_insertion_point(field_get:protocol.SLoadInventory.gold)
  return _internal_gold();
}
inline void SLoadInventory::_internal_set_gold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  gold_ = value;
}
inline void SLoadInventory::set_gold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:protocol.SLoadInventory.gold)
}

// -------------------------------------------------------------------

// CSellItems

// repeated .protocol.ItemEquip itemEquips = 1;
inline int CSellItems::_internal_itemequips_size() const {
  return itemequips_.size();
}
inline int CSellItems::itemequips_size() const {
  return _internal_itemequips_size();
}
inline void CSellItems::clear_itemequips() {
  itemequips_.Clear();
}
inline ::protocol::ItemEquip* CSellItems::mutable_itemequips(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.CSellItems.itemEquips)
  return itemequips_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >*
CSellItems::mutable_itemequips() {
  // @@protoc_insertion_point(field_mutable_list:protocol.CSellItems.itemEquips)
  return &itemequips_;
}
inline const ::protocol::ItemEquip& CSellItems::_internal_itemequips(int index) const {
  return itemequips_.Get(index);
}
inline const ::protocol::ItemEquip& CSellItems::itemequips(int index) const {
  // @@protoc_insertion_point(field_get:protocol.CSellItems.itemEquips)
  return _internal_itemequips(index);
}
inline ::protocol::ItemEquip* CSellItems::_internal_add_itemequips() {
  return itemequips_.Add();
}
inline ::protocol::ItemEquip* CSellItems::add_itemequips() {
  ::protocol::ItemEquip* _add = _internal_add_itemequips();
  // @@protoc_insertion_point(field_add:protocol.CSellItems.itemEquips)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >&
CSellItems::itemequips() const {
  // @@protoc_insertion_point(field_list:protocol.CSellItems.itemEquips)
  return itemequips_;
}

// repeated .protocol.ItemEtc itemEtcs = 2;
inline int CSellItems::_internal_itemetcs_size() const {
  return itemetcs_.size();
}
inline int CSellItems::itemetcs_size() const {
  return _internal_itemetcs_size();
}
inline void CSellItems::clear_itemetcs() {
  itemetcs_.Clear();
}
inline ::protocol::ItemEtc* CSellItems::mutable_itemetcs(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.CSellItems.itemEtcs)
  return itemetcs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEtc >*
CSellItems::mutable_itemetcs() {
  // @@protoc_insertion_point(field_mutable_list:protocol.CSellItems.itemEtcs)
  return &itemetcs_;
}
inline const ::protocol::ItemEtc& CSellItems::_internal_itemetcs(int index) const {
  return itemetcs_.Get(index);
}
inline const ::protocol::ItemEtc& CSellItems::itemetcs(int index) const {
  // @@protoc_insertion_point(field_get:protocol.CSellItems.itemEtcs)
  return _internal_itemetcs(index);
}
inline ::protocol::ItemEtc* CSellItems::_internal_add_itemetcs() {
  return itemetcs_.Add();
}
inline ::protocol::ItemEtc* CSellItems::add_itemetcs() {
  ::protocol::ItemEtc* _add = _internal_add_itemetcs();
  // @@protoc_insertion_point(field_add:protocol.CSellItems.itemEtcs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEtc >&
CSellItems::itemetcs() const {
  // @@protoc_insertion_point(field_list:protocol.CSellItems.itemEtcs)
  return itemetcs_;
}

// int32 gold = 3;
inline void CSellItems::clear_gold() {
  gold_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CSellItems::_internal_gold() const {
  return gold_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CSellItems::gold() const {
  // @@protoc_insertion_point(field_get:protocol.CSellItems.gold)
  return _internal_gold();
}
inline void CSellItems::_internal_set_gold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  gold_ = value;
}
inline void CSellItems::set_gold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:protocol.CSellItems.gold)
}

// bool result = 4;
inline void CSellItems::clear_result() {
  result_ = false;
}
inline bool CSellItems::_internal_result() const {
  return result_;
}
inline bool CSellItems::result() const {
  // @@protoc_insertion_point(field_get:protocol.CSellItems.result)
  return _internal_result();
}
inline void CSellItems::_internal_set_result(bool value) {
  
  result_ = value;
}
inline void CSellItems::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:protocol.CSellItems.result)
}

// -------------------------------------------------------------------

// DLoad

// .protocol.Unit unit = 101;
inline bool DLoad::_internal_has_unit() const {
  return this != internal_default_instance() && unit_ != nullptr;
}
inline bool DLoad::has_unit() const {
  return _internal_has_unit();
}
inline void DLoad::clear_unit() {
  if (GetArenaForAllocation() == nullptr && unit_ != nullptr) {
    delete unit_;
  }
  unit_ = nullptr;
}
inline const ::protocol::Unit& DLoad::_internal_unit() const {
  const ::protocol::Unit* p = unit_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Unit&>(
      ::protocol::_Unit_default_instance_);
}
inline const ::protocol::Unit& DLoad::unit() const {
  // @@protoc_insertion_point(field_get:protocol.DLoad.unit)
  return _internal_unit();
}
inline void DLoad::unsafe_arena_set_allocated_unit(
    ::protocol::Unit* unit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(unit_);
  }
  unit_ = unit;
  if (unit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.DLoad.unit)
}
inline ::protocol::Unit* DLoad::release_unit() {
  
  ::protocol::Unit* temp = unit_;
  unit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Unit* DLoad::unsafe_arena_release_unit() {
  // @@protoc_insertion_point(field_release:protocol.DLoad.unit)
  
  ::protocol::Unit* temp = unit_;
  unit_ = nullptr;
  return temp;
}
inline ::protocol::Unit* DLoad::_internal_mutable_unit() {
  
  if (unit_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Unit>(GetArenaForAllocation());
    unit_ = p;
  }
  return unit_;
}
inline ::protocol::Unit* DLoad::mutable_unit() {
  ::protocol::Unit* _msg = _internal_mutable_unit();
  // @@protoc_insertion_point(field_mutable:protocol.DLoad.unit)
  return _msg;
}
inline void DLoad::set_allocated_unit(::protocol::Unit* unit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete unit_;
  }
  if (unit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Unit>::GetOwningArena(unit);
    if (message_arena != submessage_arena) {
      unit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unit, submessage_arena);
    }
    
  } else {
    
  }
  unit_ = unit;
  // @@protoc_insertion_point(field_set_allocated:protocol.DLoad.unit)
}

// -------------------------------------------------------------------

// Friend

// int32 playerCode = 1;
inline void Friend::clear_playercode() {
  playercode_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Friend::_internal_playercode() const {
  return playercode_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Friend::playercode() const {
  // @@protoc_insertion_point(field_get:protocol.Friend.playerCode)
  return _internal_playercode();
}
inline void Friend::_internal_set_playercode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  playercode_ = value;
}
inline void Friend::set_playercode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_playercode(value);
  // @@protoc_insertion_point(field_set:protocol.Friend.playerCode)
}

// string playerName = 2;
inline void Friend::clear_playername() {
  playername_.ClearToEmpty();
}
inline const std::string& Friend::playername() const {
  // @@protoc_insertion_point(field_get:protocol.Friend.playerName)
  return _internal_playername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Friend::set_playername(ArgT0&& arg0, ArgT... args) {
 
 playername_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Friend.playerName)
}
inline std::string* Friend::mutable_playername() {
  std::string* _s = _internal_mutable_playername();
  // @@protoc_insertion_point(field_mutable:protocol.Friend.playerName)
  return _s;
}
inline const std::string& Friend::_internal_playername() const {
  return playername_.Get();
}
inline void Friend::_internal_set_playername(const std::string& value) {
  
  playername_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Friend::_internal_mutable_playername() {
  
  return playername_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Friend::release_playername() {
  // @@protoc_insertion_point(field_release:protocol.Friend.playerName)
  return playername_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Friend::set_allocated_playername(std::string* playername) {
  if (playername != nullptr) {
    
  } else {
    
  }
  playername_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), playername,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.Friend.playerName)
}

// bool access = 3;
inline void Friend::clear_access() {
  access_ = false;
}
inline bool Friend::_internal_access() const {
  return access_;
}
inline bool Friend::access() const {
  // @@protoc_insertion_point(field_get:protocol.Friend.access)
  return _internal_access();
}
inline void Friend::_internal_set_access(bool value) {
  
  access_ = value;
}
inline void Friend::set_access(bool value) {
  _internal_set_access(value);
  // @@protoc_insertion_point(field_set:protocol.Friend.access)
}

// bool add = 4;
inline void Friend::clear_add() {
  add_ = false;
}
inline bool Friend::_internal_add() const {
  return add_;
}
inline bool Friend::add() const {
  // @@protoc_insertion_point(field_get:protocol.Friend.add)
  return _internal_add();
}
inline void Friend::_internal_set_add(bool value) {
  
  add_ = value;
}
inline void Friend::set_add(bool value) {
  _internal_set_add(value);
  // @@protoc_insertion_point(field_set:protocol.Friend.add)
}

// -------------------------------------------------------------------

// SFriendSystem

// repeated .protocol.Friend friend = 1;
inline int SFriendSystem::_internal_friend__size() const {
  return friend__.size();
}
inline int SFriendSystem::friend__size() const {
  return _internal_friend__size();
}
inline void SFriendSystem::clear_friend_() {
  friend__.Clear();
}
inline ::protocol::Friend* SFriendSystem::mutable_friend_(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.SFriendSystem.friend)
  return friend__.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Friend >*
SFriendSystem::mutable_friend_() {
  // @@protoc_insertion_point(field_mutable_list:protocol.SFriendSystem.friend)
  return &friend__;
}
inline const ::protocol::Friend& SFriendSystem::_internal_friend_(int index) const {
  return friend__.Get(index);
}
inline const ::protocol::Friend& SFriendSystem::friend_(int index) const {
  // @@protoc_insertion_point(field_get:protocol.SFriendSystem.friend)
  return _internal_friend_(index);
}
inline ::protocol::Friend* SFriendSystem::_internal_add_friend_() {
  return friend__.Add();
}
inline ::protocol::Friend* SFriendSystem::add_friend_() {
  ::protocol::Friend* _add = _internal_add_friend_();
  // @@protoc_insertion_point(field_add:protocol.SFriendSystem.friend)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Friend >&
SFriendSystem::friend_() const {
  // @@protoc_insertion_point(field_list:protocol.SFriendSystem.friend)
  return friend__;
}

// int32 result = 3;
inline void SFriendSystem::clear_result() {
  result_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SFriendSystem::_internal_result() const {
  return result_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SFriendSystem::result() const {
  // @@protoc_insertion_point(field_get:protocol.SFriendSystem.result)
  return _internal_result();
}
inline void SFriendSystem::_internal_set_result(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  result_ = value;
}
inline void SFriendSystem::set_result(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:protocol.SFriendSystem.result)
}

// -------------------------------------------------------------------

// CFriend

// int32 type = 1;
inline void CFriend::clear_type() {
  type_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CFriend::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CFriend::type() const {
  // @@protoc_insertion_point(field_get:protocol.CFriend.type)
  return _internal_type();
}
inline void CFriend::_internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  type_ = value;
}
inline void CFriend::set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:protocol.CFriend.type)
}

// .protocol.Friend friend = 2;
inline bool CFriend::_internal_has_friend_() const {
  return this != internal_default_instance() && friend__ != nullptr;
}
inline bool CFriend::has_friend_() const {
  return _internal_has_friend_();
}
inline void CFriend::clear_friend_() {
  if (GetArenaForAllocation() == nullptr && friend__ != nullptr) {
    delete friend__;
  }
  friend__ = nullptr;
}
inline const ::protocol::Friend& CFriend::_internal_friend_() const {
  const ::protocol::Friend* p = friend__;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Friend&>(
      ::protocol::_Friend_default_instance_);
}
inline const ::protocol::Friend& CFriend::friend_() const {
  // @@protoc_insertion_point(field_get:protocol.CFriend.friend)
  return _internal_friend_();
}
inline void CFriend::unsafe_arena_set_allocated_friend_(
    ::protocol::Friend* friend_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(friend__);
  }
  friend__ = friend_;
  if (friend_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.CFriend.friend)
}
inline ::protocol::Friend* CFriend::release_friend_() {
  
  ::protocol::Friend* temp = friend__;
  friend__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Friend* CFriend::unsafe_arena_release_friend_() {
  // @@protoc_insertion_point(field_release:protocol.CFriend.friend)
  
  ::protocol::Friend* temp = friend__;
  friend__ = nullptr;
  return temp;
}
inline ::protocol::Friend* CFriend::_internal_mutable_friend_() {
  
  if (friend__ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Friend>(GetArenaForAllocation());
    friend__ = p;
  }
  return friend__;
}
inline ::protocol::Friend* CFriend::mutable_friend_() {
  ::protocol::Friend* _msg = _internal_mutable_friend_();
  // @@protoc_insertion_point(field_mutable:protocol.CFriend.friend)
  return _msg;
}
inline void CFriend::set_allocated_friend_(::protocol::Friend* friend_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete friend__;
  }
  if (friend_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Friend>::GetOwningArena(friend_);
    if (message_arena != submessage_arena) {
      friend_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, friend_, submessage_arena);
    }
    
  } else {
    
  }
  friend__ = friend_;
  // @@protoc_insertion_point(field_set_allocated:protocol.CFriend.friend)
}

// -------------------------------------------------------------------

// CUpdateItems

// int32 invenPos = 1;
inline void CUpdateItems::clear_invenpos() {
  invenpos_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CUpdateItems::_internal_invenpos() const {
  return invenpos_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CUpdateItems::invenpos() const {
  // @@protoc_insertion_point(field_get:protocol.CUpdateItems.invenPos)
  return _internal_invenpos();
}
inline void CUpdateItems::_internal_set_invenpos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  invenpos_ = value;
}
inline void CUpdateItems::set_invenpos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_invenpos(value);
  // @@protoc_insertion_point(field_set:protocol.CUpdateItems.invenPos)
}

// int32 equipPos = 2;
inline void CUpdateItems::clear_equippos() {
  equippos_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CUpdateItems::_internal_equippos() const {
  return equippos_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CUpdateItems::equippos() const {
  // @@protoc_insertion_point(field_get:protocol.CUpdateItems.equipPos)
  return _internal_equippos();
}
inline void CUpdateItems::_internal_set_equippos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  equippos_ = value;
}
inline void CUpdateItems::set_equippos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_equippos(value);
  // @@protoc_insertion_point(field_set:protocol.CUpdateItems.equipPos)
}

// -------------------------------------------------------------------

// Mail

// int32 code = 1;
inline void Mail::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Mail::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Mail::code() const {
  // @@protoc_insertion_point(field_get:protocol.Mail.code)
  return _internal_code();
}
inline void Mail::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void Mail::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:protocol.Mail.code)
}

// int32 read = 2;
inline void Mail::clear_read() {
  read_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Mail::_internal_read() const {
  return read_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Mail::read() const {
  // @@protoc_insertion_point(field_get:protocol.Mail.read)
  return _internal_read();
}
inline void Mail::_internal_set_read(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  read_ = value;
}
inline void Mail::set_read(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_read(value);
  // @@protoc_insertion_point(field_set:protocol.Mail.read)
}

// int32 gold = 3;
inline void Mail::clear_gold() {
  gold_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Mail::_internal_gold() const {
  return gold_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Mail::gold() const {
  // @@protoc_insertion_point(field_get:protocol.Mail.gold)
  return _internal_gold();
}
inline void Mail::_internal_set_gold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  gold_ = value;
}
inline void Mail::set_gold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:protocol.Mail.gold)
}

// int32 socket1 = 4;
inline void Mail::clear_socket1() {
  socket1_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Mail::_internal_socket1() const {
  return socket1_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Mail::socket1() const {
  // @@protoc_insertion_point(field_get:protocol.Mail.socket1)
  return _internal_socket1();
}
inline void Mail::_internal_set_socket1(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  socket1_ = value;
}
inline void Mail::set_socket1(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_socket1(value);
  // @@protoc_insertion_point(field_set:protocol.Mail.socket1)
}

// int32 socket1Type = 5;
inline void Mail::clear_socket1type() {
  socket1type_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Mail::_internal_socket1type() const {
  return socket1type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Mail::socket1type() const {
  // @@protoc_insertion_point(field_get:protocol.Mail.socket1Type)
  return _internal_socket1type();
}
inline void Mail::_internal_set_socket1type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  socket1type_ = value;
}
inline void Mail::set_socket1type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_socket1type(value);
  // @@protoc_insertion_point(field_set:protocol.Mail.socket1Type)
}

// int32 socket2 = 6;
inline void Mail::clear_socket2() {
  socket2_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Mail::_internal_socket2() const {
  return socket2_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Mail::socket2() const {
  // @@protoc_insertion_point(field_get:protocol.Mail.socket2)
  return _internal_socket2();
}
inline void Mail::_internal_set_socket2(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  socket2_ = value;
}
inline void Mail::set_socket2(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_socket2(value);
  // @@protoc_insertion_point(field_set:protocol.Mail.socket2)
}

// int32 socket2Type = 7;
inline void Mail::clear_socket2type() {
  socket2type_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Mail::_internal_socket2type() const {
  return socket2type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Mail::socket2type() const {
  // @@protoc_insertion_point(field_get:protocol.Mail.socket2Type)
  return _internal_socket2type();
}
inline void Mail::_internal_set_socket2type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  socket2type_ = value;
}
inline void Mail::set_socket2type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_socket2type(value);
  // @@protoc_insertion_point(field_set:protocol.Mail.socket2Type)
}

// string title = 9;
inline void Mail::clear_title() {
  title_.ClearToEmpty();
}
inline const std::string& Mail::title() const {
  // @@protoc_insertion_point(field_get:protocol.Mail.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Mail::set_title(ArgT0&& arg0, ArgT... args) {
 
 title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Mail.title)
}
inline std::string* Mail::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:protocol.Mail.title)
  return _s;
}
inline const std::string& Mail::_internal_title() const {
  return title_.Get();
}
inline void Mail::_internal_set_title(const std::string& value) {
  
  title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Mail::_internal_mutable_title() {
  
  return title_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Mail::release_title() {
  // @@protoc_insertion_point(field_release:protocol.Mail.title)
  return title_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Mail::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  title_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), title,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.Mail.title)
}

// string message = 10;
inline void Mail::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& Mail::message() const {
  // @@protoc_insertion_point(field_get:protocol.Mail.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Mail::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Mail.message)
}
inline std::string* Mail::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:protocol.Mail.message)
  return _s;
}
inline const std::string& Mail::_internal_message() const {
  return message_.Get();
}
inline void Mail::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Mail::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Mail::release_message() {
  // @@protoc_insertion_point(field_release:protocol.Mail.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Mail::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.Mail.message)
}

// -------------------------------------------------------------------

// MailEquipItem

// int32 mailCode = 1;
inline void MailEquipItem::clear_mailcode() {
  mailcode_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MailEquipItem::_internal_mailcode() const {
  return mailcode_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MailEquipItem::mailcode() const {
  // @@protoc_insertion_point(field_get:protocol.MailEquipItem.mailCode)
  return _internal_mailcode();
}
inline void MailEquipItem::_internal_set_mailcode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  mailcode_ = value;
}
inline void MailEquipItem::set_mailcode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_mailcode(value);
  // @@protoc_insertion_point(field_set:protocol.MailEquipItem.mailCode)
}

// int32 socket = 2;
inline void MailEquipItem::clear_socket() {
  socket_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MailEquipItem::_internal_socket() const {
  return socket_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MailEquipItem::socket() const {
  // @@protoc_insertion_point(field_get:protocol.MailEquipItem.socket)
  return _internal_socket();
}
inline void MailEquipItem::_internal_set_socket(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  socket_ = value;
}
inline void MailEquipItem::set_socket(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_socket(value);
  // @@protoc_insertion_point(field_set:protocol.MailEquipItem.socket)
}

// .protocol.ItemEquip item = 3;
inline bool MailEquipItem::_internal_has_item() const {
  return this != internal_default_instance() && item_ != nullptr;
}
inline bool MailEquipItem::has_item() const {
  return _internal_has_item();
}
inline void MailEquipItem::clear_item() {
  if (GetArenaForAllocation() == nullptr && item_ != nullptr) {
    delete item_;
  }
  item_ = nullptr;
}
inline const ::protocol::ItemEquip& MailEquipItem::_internal_item() const {
  const ::protocol::ItemEquip* p = item_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::ItemEquip&>(
      ::protocol::_ItemEquip_default_instance_);
}
inline const ::protocol::ItemEquip& MailEquipItem::item() const {
  // @@protoc_insertion_point(field_get:protocol.MailEquipItem.item)
  return _internal_item();
}
inline void MailEquipItem::unsafe_arena_set_allocated_item(
    ::protocol::ItemEquip* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_);
  }
  item_ = item;
  if (item) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.MailEquipItem.item)
}
inline ::protocol::ItemEquip* MailEquipItem::release_item() {
  
  ::protocol::ItemEquip* temp = item_;
  item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::ItemEquip* MailEquipItem::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:protocol.MailEquipItem.item)
  
  ::protocol::ItemEquip* temp = item_;
  item_ = nullptr;
  return temp;
}
inline ::protocol::ItemEquip* MailEquipItem::_internal_mutable_item() {
  
  if (item_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::ItemEquip>(GetArenaForAllocation());
    item_ = p;
  }
  return item_;
}
inline ::protocol::ItemEquip* MailEquipItem::mutable_item() {
  ::protocol::ItemEquip* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:protocol.MailEquipItem.item)
  return _msg;
}
inline void MailEquipItem::set_allocated_item(::protocol::ItemEquip* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete item_;
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::ItemEquip>::GetOwningArena(item);
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  item_ = item;
  // @@protoc_insertion_point(field_set_allocated:protocol.MailEquipItem.item)
}

// -------------------------------------------------------------------

// MailEtcItem

// int32 mailCode = 1;
inline void MailEtcItem::clear_mailcode() {
  mailcode_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MailEtcItem::_internal_mailcode() const {
  return mailcode_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MailEtcItem::mailcode() const {
  // @@protoc_insertion_point(field_get:protocol.MailEtcItem.mailCode)
  return _internal_mailcode();
}
inline void MailEtcItem::_internal_set_mailcode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  mailcode_ = value;
}
inline void MailEtcItem::set_mailcode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_mailcode(value);
  // @@protoc_insertion_point(field_set:protocol.MailEtcItem.mailCode)
}

// int32 socket = 2;
inline void MailEtcItem::clear_socket() {
  socket_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MailEtcItem::_internal_socket() const {
  return socket_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MailEtcItem::socket() const {
  // @@protoc_insertion_point(field_get:protocol.MailEtcItem.socket)
  return _internal_socket();
}
inline void MailEtcItem::_internal_set_socket(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  socket_ = value;
}
inline void MailEtcItem::set_socket(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_socket(value);
  // @@protoc_insertion_point(field_set:protocol.MailEtcItem.socket)
}

// .protocol.ItemEtc item = 3;
inline bool MailEtcItem::_internal_has_item() const {
  return this != internal_default_instance() && item_ != nullptr;
}
inline bool MailEtcItem::has_item() const {
  return _internal_has_item();
}
inline void MailEtcItem::clear_item() {
  if (GetArenaForAllocation() == nullptr && item_ != nullptr) {
    delete item_;
  }
  item_ = nullptr;
}
inline const ::protocol::ItemEtc& MailEtcItem::_internal_item() const {
  const ::protocol::ItemEtc* p = item_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::ItemEtc&>(
      ::protocol::_ItemEtc_default_instance_);
}
inline const ::protocol::ItemEtc& MailEtcItem::item() const {
  // @@protoc_insertion_point(field_get:protocol.MailEtcItem.item)
  return _internal_item();
}
inline void MailEtcItem::unsafe_arena_set_allocated_item(
    ::protocol::ItemEtc* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_);
  }
  item_ = item;
  if (item) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.MailEtcItem.item)
}
inline ::protocol::ItemEtc* MailEtcItem::release_item() {
  
  ::protocol::ItemEtc* temp = item_;
  item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::ItemEtc* MailEtcItem::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:protocol.MailEtcItem.item)
  
  ::protocol::ItemEtc* temp = item_;
  item_ = nullptr;
  return temp;
}
inline ::protocol::ItemEtc* MailEtcItem::_internal_mutable_item() {
  
  if (item_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::ItemEtc>(GetArenaForAllocation());
    item_ = p;
  }
  return item_;
}
inline ::protocol::ItemEtc* MailEtcItem::mutable_item() {
  ::protocol::ItemEtc* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:protocol.MailEtcItem.item)
  return _msg;
}
inline void MailEtcItem::set_allocated_item(::protocol::ItemEtc* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete item_;
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::ItemEtc>::GetOwningArena(item);
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  item_ = item;
  // @@protoc_insertion_point(field_set_allocated:protocol.MailEtcItem.item)
}

// -------------------------------------------------------------------

// CLoadMail

// int32 type = 1;
inline void CLoadMail::clear_type() {
  type_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CLoadMail::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CLoadMail::type() const {
  // @@protoc_insertion_point(field_get:protocol.CLoadMail.type)
  return _internal_type();
}
inline void CLoadMail::_internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  type_ = value;
}
inline void CLoadMail::set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:protocol.CLoadMail.type)
}

// repeated .protocol.Mail mails = 2;
inline int CLoadMail::_internal_mails_size() const {
  return mails_.size();
}
inline int CLoadMail::mails_size() const {
  return _internal_mails_size();
}
inline void CLoadMail::clear_mails() {
  mails_.Clear();
}
inline ::protocol::Mail* CLoadMail::mutable_mails(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.CLoadMail.mails)
  return mails_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Mail >*
CLoadMail::mutable_mails() {
  // @@protoc_insertion_point(field_mutable_list:protocol.CLoadMail.mails)
  return &mails_;
}
inline const ::protocol::Mail& CLoadMail::_internal_mails(int index) const {
  return mails_.Get(index);
}
inline const ::protocol::Mail& CLoadMail::mails(int index) const {
  // @@protoc_insertion_point(field_get:protocol.CLoadMail.mails)
  return _internal_mails(index);
}
inline ::protocol::Mail* CLoadMail::_internal_add_mails() {
  return mails_.Add();
}
inline ::protocol::Mail* CLoadMail::add_mails() {
  ::protocol::Mail* _add = _internal_add_mails();
  // @@protoc_insertion_point(field_add:protocol.CLoadMail.mails)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Mail >&
CLoadMail::mails() const {
  // @@protoc_insertion_point(field_list:protocol.CLoadMail.mails)
  return mails_;
}

// repeated .protocol.MailEquipItem equipItems = 3;
inline int CLoadMail::_internal_equipitems_size() const {
  return equipitems_.size();
}
inline int CLoadMail::equipitems_size() const {
  return _internal_equipitems_size();
}
inline void CLoadMail::clear_equipitems() {
  equipitems_.Clear();
}
inline ::protocol::MailEquipItem* CLoadMail::mutable_equipitems(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.CLoadMail.equipItems)
  return equipitems_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MailEquipItem >*
CLoadMail::mutable_equipitems() {
  // @@protoc_insertion_point(field_mutable_list:protocol.CLoadMail.equipItems)
  return &equipitems_;
}
inline const ::protocol::MailEquipItem& CLoadMail::_internal_equipitems(int index) const {
  return equipitems_.Get(index);
}
inline const ::protocol::MailEquipItem& CLoadMail::equipitems(int index) const {
  // @@protoc_insertion_point(field_get:protocol.CLoadMail.equipItems)
  return _internal_equipitems(index);
}
inline ::protocol::MailEquipItem* CLoadMail::_internal_add_equipitems() {
  return equipitems_.Add();
}
inline ::protocol::MailEquipItem* CLoadMail::add_equipitems() {
  ::protocol::MailEquipItem* _add = _internal_add_equipitems();
  // @@protoc_insertion_point(field_add:protocol.CLoadMail.equipItems)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MailEquipItem >&
CLoadMail::equipitems() const {
  // @@protoc_insertion_point(field_list:protocol.CLoadMail.equipItems)
  return equipitems_;
}

// repeated .protocol.MailEtcItem etcItems = 4;
inline int CLoadMail::_internal_etcitems_size() const {
  return etcitems_.size();
}
inline int CLoadMail::etcitems_size() const {
  return _internal_etcitems_size();
}
inline void CLoadMail::clear_etcitems() {
  etcitems_.Clear();
}
inline ::protocol::MailEtcItem* CLoadMail::mutable_etcitems(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.CLoadMail.etcItems)
  return etcitems_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MailEtcItem >*
CLoadMail::mutable_etcitems() {
  // @@protoc_insertion_point(field_mutable_list:protocol.CLoadMail.etcItems)
  return &etcitems_;
}
inline const ::protocol::MailEtcItem& CLoadMail::_internal_etcitems(int index) const {
  return etcitems_.Get(index);
}
inline const ::protocol::MailEtcItem& CLoadMail::etcitems(int index) const {
  // @@protoc_insertion_point(field_get:protocol.CLoadMail.etcItems)
  return _internal_etcitems(index);
}
inline ::protocol::MailEtcItem* CLoadMail::_internal_add_etcitems() {
  return etcitems_.Add();
}
inline ::protocol::MailEtcItem* CLoadMail::add_etcitems() {
  ::protocol::MailEtcItem* _add = _internal_add_etcitems();
  // @@protoc_insertion_point(field_add:protocol.CLoadMail.etcItems)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MailEtcItem >&
CLoadMail::etcitems() const {
  // @@protoc_insertion_point(field_list:protocol.CLoadMail.etcItems)
  return etcitems_;
}

// -------------------------------------------------------------------

// CUpdateMail

// int32 type = 1;
inline void CUpdateMail::clear_type() {
  type_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CUpdateMail::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CUpdateMail::type() const {
  // @@protoc_insertion_point(field_get:protocol.CUpdateMail.type)
  return _internal_type();
}
inline void CUpdateMail::_internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  type_ = value;
}
inline void CUpdateMail::set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:protocol.CUpdateMail.type)
}

// .protocol.Mail mail = 2;
inline bool CUpdateMail::_internal_has_mail() const {
  return this != internal_default_instance() && mail_ != nullptr;
}
inline bool CUpdateMail::has_mail() const {
  return _internal_has_mail();
}
inline void CUpdateMail::clear_mail() {
  if (GetArenaForAllocation() == nullptr && mail_ != nullptr) {
    delete mail_;
  }
  mail_ = nullptr;
}
inline const ::protocol::Mail& CUpdateMail::_internal_mail() const {
  const ::protocol::Mail* p = mail_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Mail&>(
      ::protocol::_Mail_default_instance_);
}
inline const ::protocol::Mail& CUpdateMail::mail() const {
  // @@protoc_insertion_point(field_get:protocol.CUpdateMail.mail)
  return _internal_mail();
}
inline void CUpdateMail::unsafe_arena_set_allocated_mail(
    ::protocol::Mail* mail) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mail_);
  }
  mail_ = mail;
  if (mail) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.CUpdateMail.mail)
}
inline ::protocol::Mail* CUpdateMail::release_mail() {
  
  ::protocol::Mail* temp = mail_;
  mail_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Mail* CUpdateMail::unsafe_arena_release_mail() {
  // @@protoc_insertion_point(field_release:protocol.CUpdateMail.mail)
  
  ::protocol::Mail* temp = mail_;
  mail_ = nullptr;
  return temp;
}
inline ::protocol::Mail* CUpdateMail::_internal_mutable_mail() {
  
  if (mail_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Mail>(GetArenaForAllocation());
    mail_ = p;
  }
  return mail_;
}
inline ::protocol::Mail* CUpdateMail::mutable_mail() {
  ::protocol::Mail* _msg = _internal_mutable_mail();
  // @@protoc_insertion_point(field_mutable:protocol.CUpdateMail.mail)
  return _msg;
}
inline void CUpdateMail::set_allocated_mail(::protocol::Mail* mail) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete mail_;
  }
  if (mail) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Mail>::GetOwningArena(mail);
    if (message_arena != submessage_arena) {
      mail = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mail, submessage_arena);
    }
    
  } else {
    
  }
  mail_ = mail;
  // @@protoc_insertion_point(field_set_allocated:protocol.CUpdateMail.mail)
}

// -------------------------------------------------------------------

// CAllUpdateMail

// int32 type = 1;
inline void CAllUpdateMail::clear_type() {
  type_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CAllUpdateMail::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CAllUpdateMail::type() const {
  // @@protoc_insertion_point(field_get:protocol.CAllUpdateMail.type)
  return _internal_type();
}
inline void CAllUpdateMail::_internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  type_ = value;
}
inline void CAllUpdateMail::set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:protocol.CAllUpdateMail.type)
}

// repeated .protocol.Mail mails = 2;
inline int CAllUpdateMail::_internal_mails_size() const {
  return mails_.size();
}
inline int CAllUpdateMail::mails_size() const {
  return _internal_mails_size();
}
inline void CAllUpdateMail::clear_mails() {
  mails_.Clear();
}
inline ::protocol::Mail* CAllUpdateMail::mutable_mails(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.CAllUpdateMail.mails)
  return mails_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Mail >*
CAllUpdateMail::mutable_mails() {
  // @@protoc_insertion_point(field_mutable_list:protocol.CAllUpdateMail.mails)
  return &mails_;
}
inline const ::protocol::Mail& CAllUpdateMail::_internal_mails(int index) const {
  return mails_.Get(index);
}
inline const ::protocol::Mail& CAllUpdateMail::mails(int index) const {
  // @@protoc_insertion_point(field_get:protocol.CAllUpdateMail.mails)
  return _internal_mails(index);
}
inline ::protocol::Mail* CAllUpdateMail::_internal_add_mails() {
  return mails_.Add();
}
inline ::protocol::Mail* CAllUpdateMail::add_mails() {
  ::protocol::Mail* _add = _internal_add_mails();
  // @@protoc_insertion_point(field_add:protocol.CAllUpdateMail.mails)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Mail >&
CAllUpdateMail::mails() const {
  // @@protoc_insertion_point(field_list:protocol.CAllUpdateMail.mails)
  return mails_;
}

// repeated .protocol.MailEquipItem equipItems = 3;
inline int CAllUpdateMail::_internal_equipitems_size() const {
  return equipitems_.size();
}
inline int CAllUpdateMail::equipitems_size() const {
  return _internal_equipitems_size();
}
inline void CAllUpdateMail::clear_equipitems() {
  equipitems_.Clear();
}
inline ::protocol::MailEquipItem* CAllUpdateMail::mutable_equipitems(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.CAllUpdateMail.equipItems)
  return equipitems_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MailEquipItem >*
CAllUpdateMail::mutable_equipitems() {
  // @@protoc_insertion_point(field_mutable_list:protocol.CAllUpdateMail.equipItems)
  return &equipitems_;
}
inline const ::protocol::MailEquipItem& CAllUpdateMail::_internal_equipitems(int index) const {
  return equipitems_.Get(index);
}
inline const ::protocol::MailEquipItem& CAllUpdateMail::equipitems(int index) const {
  // @@protoc_insertion_point(field_get:protocol.CAllUpdateMail.equipItems)
  return _internal_equipitems(index);
}
inline ::protocol::MailEquipItem* CAllUpdateMail::_internal_add_equipitems() {
  return equipitems_.Add();
}
inline ::protocol::MailEquipItem* CAllUpdateMail::add_equipitems() {
  ::protocol::MailEquipItem* _add = _internal_add_equipitems();
  // @@protoc_insertion_point(field_add:protocol.CAllUpdateMail.equipItems)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MailEquipItem >&
CAllUpdateMail::equipitems() const {
  // @@protoc_insertion_point(field_list:protocol.CAllUpdateMail.equipItems)
  return equipitems_;
}

// repeated .protocol.MailEtcItem etcItems = 4;
inline int CAllUpdateMail::_internal_etcitems_size() const {
  return etcitems_.size();
}
inline int CAllUpdateMail::etcitems_size() const {
  return _internal_etcitems_size();
}
inline void CAllUpdateMail::clear_etcitems() {
  etcitems_.Clear();
}
inline ::protocol::MailEtcItem* CAllUpdateMail::mutable_etcitems(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.CAllUpdateMail.etcItems)
  return etcitems_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MailEtcItem >*
CAllUpdateMail::mutable_etcitems() {
  // @@protoc_insertion_point(field_mutable_list:protocol.CAllUpdateMail.etcItems)
  return &etcitems_;
}
inline const ::protocol::MailEtcItem& CAllUpdateMail::_internal_etcitems(int index) const {
  return etcitems_.Get(index);
}
inline const ::protocol::MailEtcItem& CAllUpdateMail::etcitems(int index) const {
  // @@protoc_insertion_point(field_get:protocol.CAllUpdateMail.etcItems)
  return _internal_etcitems(index);
}
inline ::protocol::MailEtcItem* CAllUpdateMail::_internal_add_etcitems() {
  return etcitems_.Add();
}
inline ::protocol::MailEtcItem* CAllUpdateMail::add_etcitems() {
  ::protocol::MailEtcItem* _add = _internal_add_etcitems();
  // @@protoc_insertion_point(field_add:protocol.CAllUpdateMail.etcItems)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MailEtcItem >&
CAllUpdateMail::etcitems() const {
  // @@protoc_insertion_point(field_list:protocol.CAllUpdateMail.etcItems)
  return etcitems_;
}

// -------------------------------------------------------------------

// CSendMail

// int32 type = 1;
inline void CSendMail::clear_type() {
  type_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CSendMail::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CSendMail::type() const {
  // @@protoc_insertion_point(field_get:protocol.CSendMail.type)
  return _internal_type();
}
inline void CSendMail::_internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  type_ = value;
}
inline void CSendMail::set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:protocol.CSendMail.type)
}

// .protocol.Mail mails = 2;
inline bool CSendMail::_internal_has_mails() const {
  return this != internal_default_instance() && mails_ != nullptr;
}
inline bool CSendMail::has_mails() const {
  return _internal_has_mails();
}
inline void CSendMail::clear_mails() {
  if (GetArenaForAllocation() == nullptr && mails_ != nullptr) {
    delete mails_;
  }
  mails_ = nullptr;
}
inline const ::protocol::Mail& CSendMail::_internal_mails() const {
  const ::protocol::Mail* p = mails_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Mail&>(
      ::protocol::_Mail_default_instance_);
}
inline const ::protocol::Mail& CSendMail::mails() const {
  // @@protoc_insertion_point(field_get:protocol.CSendMail.mails)
  return _internal_mails();
}
inline void CSendMail::unsafe_arena_set_allocated_mails(
    ::protocol::Mail* mails) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mails_);
  }
  mails_ = mails;
  if (mails) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.CSendMail.mails)
}
inline ::protocol::Mail* CSendMail::release_mails() {
  
  ::protocol::Mail* temp = mails_;
  mails_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Mail* CSendMail::unsafe_arena_release_mails() {
  // @@protoc_insertion_point(field_release:protocol.CSendMail.mails)
  
  ::protocol::Mail* temp = mails_;
  mails_ = nullptr;
  return temp;
}
inline ::protocol::Mail* CSendMail::_internal_mutable_mails() {
  
  if (mails_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Mail>(GetArenaForAllocation());
    mails_ = p;
  }
  return mails_;
}
inline ::protocol::Mail* CSendMail::mutable_mails() {
  ::protocol::Mail* _msg = _internal_mutable_mails();
  // @@protoc_insertion_point(field_mutable:protocol.CSendMail.mails)
  return _msg;
}
inline void CSendMail::set_allocated_mails(::protocol::Mail* mails) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete mails_;
  }
  if (mails) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Mail>::GetOwningArena(mails);
    if (message_arena != submessage_arena) {
      mails = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mails, submessage_arena);
    }
    
  } else {
    
  }
  mails_ = mails;
  // @@protoc_insertion_point(field_set_allocated:protocol.CSendMail.mails)
}

// repeated .protocol.MailEquipItem equipItems = 3;
inline int CSendMail::_internal_equipitems_size() const {
  return equipitems_.size();
}
inline int CSendMail::equipitems_size() const {
  return _internal_equipitems_size();
}
inline void CSendMail::clear_equipitems() {
  equipitems_.Clear();
}
inline ::protocol::MailEquipItem* CSendMail::mutable_equipitems(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.CSendMail.equipItems)
  return equipitems_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MailEquipItem >*
CSendMail::mutable_equipitems() {
  // @@protoc_insertion_point(field_mutable_list:protocol.CSendMail.equipItems)
  return &equipitems_;
}
inline const ::protocol::MailEquipItem& CSendMail::_internal_equipitems(int index) const {
  return equipitems_.Get(index);
}
inline const ::protocol::MailEquipItem& CSendMail::equipitems(int index) const {
  // @@protoc_insertion_point(field_get:protocol.CSendMail.equipItems)
  return _internal_equipitems(index);
}
inline ::protocol::MailEquipItem* CSendMail::_internal_add_equipitems() {
  return equipitems_.Add();
}
inline ::protocol::MailEquipItem* CSendMail::add_equipitems() {
  ::protocol::MailEquipItem* _add = _internal_add_equipitems();
  // @@protoc_insertion_point(field_add:protocol.CSendMail.equipItems)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MailEquipItem >&
CSendMail::equipitems() const {
  // @@protoc_insertion_point(field_list:protocol.CSendMail.equipItems)
  return equipitems_;
}

// repeated .protocol.MailEtcItem etcItems = 4;
inline int CSendMail::_internal_etcitems_size() const {
  return etcitems_.size();
}
inline int CSendMail::etcitems_size() const {
  return _internal_etcitems_size();
}
inline void CSendMail::clear_etcitems() {
  etcitems_.Clear();
}
inline ::protocol::MailEtcItem* CSendMail::mutable_etcitems(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.CSendMail.etcItems)
  return etcitems_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MailEtcItem >*
CSendMail::mutable_etcitems() {
  // @@protoc_insertion_point(field_mutable_list:protocol.CSendMail.etcItems)
  return &etcitems_;
}
inline const ::protocol::MailEtcItem& CSendMail::_internal_etcitems(int index) const {
  return etcitems_.Get(index);
}
inline const ::protocol::MailEtcItem& CSendMail::etcitems(int index) const {
  // @@protoc_insertion_point(field_get:protocol.CSendMail.etcItems)
  return _internal_etcitems(index);
}
inline ::protocol::MailEtcItem* CSendMail::_internal_add_etcitems() {
  return etcitems_.Add();
}
inline ::protocol::MailEtcItem* CSendMail::add_etcitems() {
  ::protocol::MailEtcItem* _add = _internal_add_etcitems();
  // @@protoc_insertion_point(field_add:protocol.CSendMail.etcItems)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MailEtcItem >&
CSendMail::etcitems() const {
  // @@protoc_insertion_point(field_list:protocol.CSendMail.etcItems)
  return etcitems_;
}

// -------------------------------------------------------------------

// SSendMail

// int32 result = 1;
inline void SSendMail::clear_result() {
  result_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SSendMail::_internal_result() const {
  return result_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SSendMail::result() const {
  // @@protoc_insertion_point(field_get:protocol.SSendMail.result)
  return _internal_result();
}
inline void SSendMail::_internal_set_result(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  result_ = value;
}
inline void SSendMail::set_result(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:protocol.SSendMail.result)
}

// int32 gold = 2;
inline void SSendMail::clear_gold() {
  gold_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SSendMail::_internal_gold() const {
  return gold_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SSendMail::gold() const {
  // @@protoc_insertion_point(field_get:protocol.SSendMail.gold)
  return _internal_gold();
}
inline void SSendMail::_internal_set_gold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  gold_ = value;
}
inline void SSendMail::set_gold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:protocol.SSendMail.gold)
}

// repeated .protocol.ItemEquip itemEquips = 3;
inline int SSendMail::_internal_itemequips_size() const {
  return itemequips_.size();
}
inline int SSendMail::itemequips_size() const {
  return _internal_itemequips_size();
}
inline void SSendMail::clear_itemequips() {
  itemequips_.Clear();
}
inline ::protocol::ItemEquip* SSendMail::mutable_itemequips(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.SSendMail.itemEquips)
  return itemequips_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >*
SSendMail::mutable_itemequips() {
  // @@protoc_insertion_point(field_mutable_list:protocol.SSendMail.itemEquips)
  return &itemequips_;
}
inline const ::protocol::ItemEquip& SSendMail::_internal_itemequips(int index) const {
  return itemequips_.Get(index);
}
inline const ::protocol::ItemEquip& SSendMail::itemequips(int index) const {
  // @@protoc_insertion_point(field_get:protocol.SSendMail.itemEquips)
  return _internal_itemequips(index);
}
inline ::protocol::ItemEquip* SSendMail::_internal_add_itemequips() {
  return itemequips_.Add();
}
inline ::protocol::ItemEquip* SSendMail::add_itemequips() {
  ::protocol::ItemEquip* _add = _internal_add_itemequips();
  // @@protoc_insertion_point(field_add:protocol.SSendMail.itemEquips)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >&
SSendMail::itemequips() const {
  // @@protoc_insertion_point(field_list:protocol.SSendMail.itemEquips)
  return itemequips_;
}

// repeated .protocol.ItemEquip etcItems = 4;
inline int SSendMail::_internal_etcitems_size() const {
  return etcitems_.size();
}
inline int SSendMail::etcitems_size() const {
  return _internal_etcitems_size();
}
inline void SSendMail::clear_etcitems() {
  etcitems_.Clear();
}
inline ::protocol::ItemEquip* SSendMail::mutable_etcitems(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.SSendMail.etcItems)
  return etcitems_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >*
SSendMail::mutable_etcitems() {
  // @@protoc_insertion_point(field_mutable_list:protocol.SSendMail.etcItems)
  return &etcitems_;
}
inline const ::protocol::ItemEquip& SSendMail::_internal_etcitems(int index) const {
  return etcitems_.Get(index);
}
inline const ::protocol::ItemEquip& SSendMail::etcitems(int index) const {
  // @@protoc_insertion_point(field_get:protocol.SSendMail.etcItems)
  return _internal_etcitems(index);
}
inline ::protocol::ItemEquip* SSendMail::_internal_add_etcitems() {
  return etcitems_.Add();
}
inline ::protocol::ItemEquip* SSendMail::add_etcitems() {
  ::protocol::ItemEquip* _add = _internal_add_etcitems();
  // @@protoc_insertion_point(field_add:protocol.SSendMail.etcItems)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >&
SSendMail::etcitems() const {
  // @@protoc_insertion_point(field_list:protocol.SSendMail.etcItems)
  return etcitems_;
}

// -------------------------------------------------------------------

// CAttack

// int32 attackNumber = 1;
inline void CAttack::clear_attacknumber() {
  attacknumber_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CAttack::_internal_attacknumber() const {
  return attacknumber_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CAttack::attacknumber() const {
  // @@protoc_insertion_point(field_get:protocol.CAttack.attackNumber)
  return _internal_attacknumber();
}
inline void CAttack::_internal_set_attacknumber(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  attacknumber_ = value;
}
inline void CAttack::set_attacknumber(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_attacknumber(value);
  // @@protoc_insertion_point(field_set:protocol.CAttack.attackNumber)
}

// int32 uuid = 2;
inline void CAttack::clear_uuid() {
  uuid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CAttack::_internal_uuid() const {
  return uuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CAttack::uuid() const {
  // @@protoc_insertion_point(field_get:protocol.CAttack.uuid)
  return _internal_uuid();
}
inline void CAttack::_internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  uuid_ = value;
}
inline void CAttack::set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:protocol.CAttack.uuid)
}

// int32 skillCode = 3;
inline void CAttack::clear_skillcode() {
  skillcode_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CAttack::_internal_skillcode() const {
  return skillcode_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CAttack::skillcode() const {
  // @@protoc_insertion_point(field_get:protocol.CAttack.skillCode)
  return _internal_skillcode();
}
inline void CAttack::_internal_set_skillcode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  skillcode_ = value;
}
inline void CAttack::set_skillcode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_skillcode(value);
  // @@protoc_insertion_point(field_set:protocol.CAttack.skillCode)
}

// .protocol.Position position = 4;
inline bool CAttack::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool CAttack::has_position() const {
  return _internal_has_position();
}
inline void CAttack::clear_position() {
  if (GetArenaForAllocation() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::protocol::Position& CAttack::_internal_position() const {
  const ::protocol::Position* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Position&>(
      ::protocol::_Position_default_instance_);
}
inline const ::protocol::Position& CAttack::position() const {
  // @@protoc_insertion_point(field_get:protocol.CAttack.position)
  return _internal_position();
}
inline void CAttack::unsafe_arena_set_allocated_position(
    ::protocol::Position* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.CAttack.position)
}
inline ::protocol::Position* CAttack::release_position() {
  
  ::protocol::Position* temp = position_;
  position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Position* CAttack::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:protocol.CAttack.position)
  
  ::protocol::Position* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::protocol::Position* CAttack::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Position>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::protocol::Position* CAttack::mutable_position() {
  ::protocol::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:protocol.CAttack.position)
  return _msg;
}
inline void CAttack::set_allocated_position(::protocol::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Position>::GetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:protocol.CAttack.position)
}

// -------------------------------------------------------------------

// UserAttack

// int32 attackNumber = 1;
inline void UserAttack::clear_attacknumber() {
  attacknumber_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UserAttack::_internal_attacknumber() const {
  return attacknumber_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UserAttack::attacknumber() const {
  // @@protoc_insertion_point(field_get:protocol.UserAttack.attackNumber)
  return _internal_attacknumber();
}
inline void UserAttack::_internal_set_attacknumber(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  attacknumber_ = value;
}
inline void UserAttack::set_attacknumber(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_attacknumber(value);
  // @@protoc_insertion_point(field_set:protocol.UserAttack.attackNumber)
}

// int32 skillCode = 2;
inline void UserAttack::clear_skillcode() {
  skillcode_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UserAttack::_internal_skillcode() const {
  return skillcode_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UserAttack::skillcode() const {
  // @@protoc_insertion_point(field_get:protocol.UserAttack.skillCode)
  return _internal_skillcode();
}
inline void UserAttack::_internal_set_skillcode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  skillcode_ = value;
}
inline void UserAttack::set_skillcode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_skillcode(value);
  // @@protoc_insertion_point(field_set:protocol.UserAttack.skillCode)
}

// .protocol.Position position = 3;
inline bool UserAttack::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool UserAttack::has_position() const {
  return _internal_has_position();
}
inline void UserAttack::clear_position() {
  if (GetArenaForAllocation() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::protocol::Position& UserAttack::_internal_position() const {
  const ::protocol::Position* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Position&>(
      ::protocol::_Position_default_instance_);
}
inline const ::protocol::Position& UserAttack::position() const {
  // @@protoc_insertion_point(field_get:protocol.UserAttack.position)
  return _internal_position();
}
inline void UserAttack::unsafe_arena_set_allocated_position(
    ::protocol::Position* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.UserAttack.position)
}
inline ::protocol::Position* UserAttack::release_position() {
  
  ::protocol::Position* temp = position_;
  position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Position* UserAttack::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:protocol.UserAttack.position)
  
  ::protocol::Position* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::protocol::Position* UserAttack::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Position>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::protocol::Position* UserAttack::mutable_position() {
  ::protocol::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:protocol.UserAttack.position)
  return _msg;
}
inline void UserAttack::set_allocated_position(::protocol::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Position>::GetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:protocol.UserAttack.position)
}

// repeated int32 targetCodes = 4;
inline int UserAttack::_internal_targetcodes_size() const {
  return targetcodes_.size();
}
inline int UserAttack::targetcodes_size() const {
  return _internal_targetcodes_size();
}
inline void UserAttack::clear_targetcodes() {
  targetcodes_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UserAttack::_internal_targetcodes(int index) const {
  return targetcodes_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UserAttack::targetcodes(int index) const {
  // @@protoc_insertion_point(field_get:protocol.UserAttack.targetCodes)
  return _internal_targetcodes(index);
}
inline void UserAttack::set_targetcodes(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  targetcodes_.Set(index, value);
  // @@protoc_insertion_point(field_set:protocol.UserAttack.targetCodes)
}
inline void UserAttack::_internal_add_targetcodes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  targetcodes_.Add(value);
}
inline void UserAttack::add_targetcodes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_targetcodes(value);
  // @@protoc_insertion_point(field_add:protocol.UserAttack.targetCodes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
UserAttack::_internal_targetcodes() const {
  return targetcodes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
UserAttack::targetcodes() const {
  // @@protoc_insertion_point(field_list:protocol.UserAttack.targetCodes)
  return _internal_targetcodes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
UserAttack::_internal_mutable_targetcodes() {
  return &targetcodes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
UserAttack::mutable_targetcodes() {
  // @@protoc_insertion_point(field_mutable_list:protocol.UserAttack.targetCodes)
  return _internal_mutable_targetcodes();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::protocol::MessageCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::MessageCode>() {
  return ::protocol::MessageCode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_GameService_2eproto
