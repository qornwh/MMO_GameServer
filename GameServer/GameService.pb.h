// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GameService.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_GameService_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_GameService_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_GameService_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_GameService_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[36]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_GameService_2eproto;
namespace protocol {
class Attack;
struct AttackDefaultTypeInternal;
extern AttackDefaultTypeInternal _Attack_default_instance_;
class CAttack;
struct CAttackDefaultTypeInternal;
extern CAttackDefaultTypeInternal _CAttack_default_instance_;
class CBuyCharater;
struct CBuyCharaterDefaultTypeInternal;
extern CBuyCharaterDefaultTypeInternal _CBuyCharater_default_instance_;
class CBuyWeapon;
struct CBuyWeaponDefaultTypeInternal;
extern CBuyWeaponDefaultTypeInternal _CBuyWeapon_default_instance_;
class CLoad;
struct CLoadDefaultTypeInternal;
extern CLoadDefaultTypeInternal _CLoad_default_instance_;
class CMovePotal;
struct CMovePotalDefaultTypeInternal;
extern CMovePotalDefaultTypeInternal _CMovePotal_default_instance_;
class CPlayerAim;
struct CPlayerAimDefaultTypeInternal;
extern CPlayerAimDefaultTypeInternal _CPlayerAim_default_instance_;
class CPlayerJump;
struct CPlayerJumpDefaultTypeInternal;
extern CPlayerJumpDefaultTypeInternal _CPlayerJump_default_instance_;
class CSellItems;
struct CSellItemsDefaultTypeInternal;
extern CSellItemsDefaultTypeInternal _CSellItems_default_instance_;
class CUpdateAccount;
struct CUpdateAccountDefaultTypeInternal;
extern CUpdateAccountDefaultTypeInternal _CUpdateAccount_default_instance_;
class Charater;
struct CharaterDefaultTypeInternal;
extern CharaterDefaultTypeInternal _Charater_default_instance_;
class CreateAccount;
struct CreateAccountDefaultTypeInternal;
extern CreateAccountDefaultTypeInternal _CreateAccount_default_instance_;
class CreateCharacter;
struct CreateCharacterDefaultTypeInternal;
extern CreateCharacterDefaultTypeInternal _CreateCharacter_default_instance_;
class Demage;
struct DemageDefaultTypeInternal;
extern DemageDefaultTypeInternal _Demage_default_instance_;
class DropMessage;
struct DropMessageDefaultTypeInternal;
extern DropMessageDefaultTypeInternal _DropMessage_default_instance_;
class ItemEquip;
struct ItemEquipDefaultTypeInternal;
extern ItemEquipDefaultTypeInternal _ItemEquip_default_instance_;
class ItemEtc;
struct ItemEtcDefaultTypeInternal;
extern ItemEtcDefaultTypeInternal _ItemEtc_default_instance_;
class Login;
struct LoginDefaultTypeInternal;
extern LoginDefaultTypeInternal _Login_default_instance_;
class LoginAccess;
struct LoginAccessDefaultTypeInternal;
extern LoginAccessDefaultTypeInternal _LoginAccess_default_instance_;
class Position;
struct PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class SBuyResult;
struct SBuyResultDefaultTypeInternal;
extern SBuyResultDefaultTypeInternal _SBuyResult_default_instance_;
class SChat;
struct SChatDefaultTypeInternal;
extern SChatDefaultTypeInternal _SChat_default_instance_;
class SClosePlayer;
struct SClosePlayerDefaultTypeInternal;
extern SClosePlayerDefaultTypeInternal _SClosePlayer_default_instance_;
class SCurrentInfo;
struct SCurrentInfoDefaultTypeInternal;
extern SCurrentInfoDefaultTypeInternal _SCurrentInfo_default_instance_;
class SEndGame;
struct SEndGameDefaultTypeInternal;
extern SEndGameDefaultTypeInternal _SEndGame_default_instance_;
class SExpLv;
struct SExpLvDefaultTypeInternal;
extern SExpLvDefaultTypeInternal _SExpLv_default_instance_;
class SInsertplayer;
struct SInsertplayerDefaultTypeInternal;
extern SInsertplayerDefaultTypeInternal _SInsertplayer_default_instance_;
class SLoad;
struct SLoadDefaultTypeInternal;
extern SLoadDefaultTypeInternal _SLoad_default_instance_;
class SLoadInventory;
struct SLoadInventoryDefaultTypeInternal;
extern SLoadInventoryDefaultTypeInternal _SLoadInventory_default_instance_;
class SMove;
struct SMoveDefaultTypeInternal;
extern SMoveDefaultTypeInternal _SMove_default_instance_;
class SPlayerData;
struct SPlayerDataDefaultTypeInternal;
extern SPlayerDataDefaultTypeInternal _SPlayerData_default_instance_;
class SRoomQuest;
struct SRoomQuestDefaultTypeInternal;
extern SRoomQuestDefaultTypeInternal _SRoomQuest_default_instance_;
class SUnitDemage;
struct SUnitDemageDefaultTypeInternal;
extern SUnitDemageDefaultTypeInternal _SUnitDemage_default_instance_;
class SUnitStates;
struct SUnitStatesDefaultTypeInternal;
extern SUnitStatesDefaultTypeInternal _SUnitStates_default_instance_;
class Unit;
struct UnitDefaultTypeInternal;
extern UnitDefaultTypeInternal _Unit_default_instance_;
class UnitState;
struct UnitStateDefaultTypeInternal;
extern UnitStateDefaultTypeInternal _UnitState_default_instance_;
}  // namespace protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::protocol::Attack* Arena::CreateMaybeMessage<::protocol::Attack>(Arena*);
template<> ::protocol::CAttack* Arena::CreateMaybeMessage<::protocol::CAttack>(Arena*);
template<> ::protocol::CBuyCharater* Arena::CreateMaybeMessage<::protocol::CBuyCharater>(Arena*);
template<> ::protocol::CBuyWeapon* Arena::CreateMaybeMessage<::protocol::CBuyWeapon>(Arena*);
template<> ::protocol::CLoad* Arena::CreateMaybeMessage<::protocol::CLoad>(Arena*);
template<> ::protocol::CMovePotal* Arena::CreateMaybeMessage<::protocol::CMovePotal>(Arena*);
template<> ::protocol::CPlayerAim* Arena::CreateMaybeMessage<::protocol::CPlayerAim>(Arena*);
template<> ::protocol::CPlayerJump* Arena::CreateMaybeMessage<::protocol::CPlayerJump>(Arena*);
template<> ::protocol::CSellItems* Arena::CreateMaybeMessage<::protocol::CSellItems>(Arena*);
template<> ::protocol::CUpdateAccount* Arena::CreateMaybeMessage<::protocol::CUpdateAccount>(Arena*);
template<> ::protocol::Charater* Arena::CreateMaybeMessage<::protocol::Charater>(Arena*);
template<> ::protocol::CreateAccount* Arena::CreateMaybeMessage<::protocol::CreateAccount>(Arena*);
template<> ::protocol::CreateCharacter* Arena::CreateMaybeMessage<::protocol::CreateCharacter>(Arena*);
template<> ::protocol::Demage* Arena::CreateMaybeMessage<::protocol::Demage>(Arena*);
template<> ::protocol::DropMessage* Arena::CreateMaybeMessage<::protocol::DropMessage>(Arena*);
template<> ::protocol::ItemEquip* Arena::CreateMaybeMessage<::protocol::ItemEquip>(Arena*);
template<> ::protocol::ItemEtc* Arena::CreateMaybeMessage<::protocol::ItemEtc>(Arena*);
template<> ::protocol::Login* Arena::CreateMaybeMessage<::protocol::Login>(Arena*);
template<> ::protocol::LoginAccess* Arena::CreateMaybeMessage<::protocol::LoginAccess>(Arena*);
template<> ::protocol::Position* Arena::CreateMaybeMessage<::protocol::Position>(Arena*);
template<> ::protocol::SBuyResult* Arena::CreateMaybeMessage<::protocol::SBuyResult>(Arena*);
template<> ::protocol::SChat* Arena::CreateMaybeMessage<::protocol::SChat>(Arena*);
template<> ::protocol::SClosePlayer* Arena::CreateMaybeMessage<::protocol::SClosePlayer>(Arena*);
template<> ::protocol::SCurrentInfo* Arena::CreateMaybeMessage<::protocol::SCurrentInfo>(Arena*);
template<> ::protocol::SEndGame* Arena::CreateMaybeMessage<::protocol::SEndGame>(Arena*);
template<> ::protocol::SExpLv* Arena::CreateMaybeMessage<::protocol::SExpLv>(Arena*);
template<> ::protocol::SInsertplayer* Arena::CreateMaybeMessage<::protocol::SInsertplayer>(Arena*);
template<> ::protocol::SLoad* Arena::CreateMaybeMessage<::protocol::SLoad>(Arena*);
template<> ::protocol::SLoadInventory* Arena::CreateMaybeMessage<::protocol::SLoadInventory>(Arena*);
template<> ::protocol::SMove* Arena::CreateMaybeMessage<::protocol::SMove>(Arena*);
template<> ::protocol::SPlayerData* Arena::CreateMaybeMessage<::protocol::SPlayerData>(Arena*);
template<> ::protocol::SRoomQuest* Arena::CreateMaybeMessage<::protocol::SRoomQuest>(Arena*);
template<> ::protocol::SUnitDemage* Arena::CreateMaybeMessage<::protocol::SUnitDemage>(Arena*);
template<> ::protocol::SUnitStates* Arena::CreateMaybeMessage<::protocol::SUnitStates>(Arena*);
template<> ::protocol::Unit* Arena::CreateMaybeMessage<::protocol::Unit>(Arena*);
template<> ::protocol::UnitState* Arena::CreateMaybeMessage<::protocol::UnitState>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace protocol {

enum MessageCode : int {
  LOGIN = 0,
  S_LOAD = 1,
  S_INSERTPLAYER = 2,
  S_MOVE = 3,
  S_CHAT = 4,
  S_PLAYERDATA = 5,
  S_CLOSEPLAYER = 6,
  S_UNITSTATES = 7,
  C_ATTACK = 8,
  S_UNITDEMAGE = 10,
  S_ROOMQUEST = 12,
  C_MOVEPOTAL = 13,
  S_ENDGAME = 14,
  LOGINACCESS = 15,
  CREATEACCOUNT = 16,
  C_LOAD = 17,
  CREATECHARACTER = 18,
  DROPMESSAGE = 19,
  C_BUYCHARATER = 20,
  C_BUYWEAPON = 21,
  C_UPDATEACCOUNT = 22,
  S_CURRENTINFO = 23,
  S_BUYRESULT = 24,
  C_PLAYERJUMP = 25,
  C_PLAYERAIM = 26,
  S_EXPLV = 27,
  S_LOADINVENTORY = 30,
  C_SELLITEMS = 31,
  MessageCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MessageCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MessageCode_IsValid(int value);
constexpr MessageCode MessageCode_MIN = LOGIN;
constexpr MessageCode MessageCode_MAX = C_SELLITEMS;
constexpr int MessageCode_ARRAYSIZE = MessageCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageCode_descriptor();
template<typename T>
inline const std::string& MessageCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MessageCode_descriptor(), enum_t_value);
}
inline bool MessageCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageCode>(
    MessageCode_descriptor(), name, value);
}
// ===================================================================

class Login final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Login) */ {
 public:
  inline Login() : Login(nullptr) {}
  ~Login() override;
  explicit constexpr Login(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Login(const Login& from);
  Login(Login&& from) noexcept
    : Login() {
    *this = ::std::move(from);
  }

  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }
  inline Login& operator=(Login&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Login& default_instance() {
    return *internal_default_instance();
  }
  static inline const Login* internal_default_instance() {
    return reinterpret_cast<const Login*>(
               &_Login_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Login& a, Login& b) {
    a.Swap(&b);
  }
  inline void Swap(Login* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Login* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Login* New() const final {
    return new Login();
  }

  Login* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Login>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Login& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Login& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Login* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Login";
  }
  protected:
  explicit Login(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPwdFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string pwd = 2;
  void clear_pwd();
  const std::string& pwd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pwd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pwd();
  PROTOBUF_MUST_USE_RESULT std::string* release_pwd();
  void set_allocated_pwd(std::string* pwd);
  private:
  const std::string& _internal_pwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pwd(const std::string& value);
  std::string* _internal_mutable_pwd();
  public:

  // @@protoc_insertion_point(class_scope:protocol.Login)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pwd_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class CreateAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.CreateAccount) */ {
 public:
  inline CreateAccount() : CreateAccount(nullptr) {}
  ~CreateAccount() override;
  explicit constexpr CreateAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateAccount(const CreateAccount& from);
  CreateAccount(CreateAccount&& from) noexcept
    : CreateAccount() {
    *this = ::std::move(from);
  }

  inline CreateAccount& operator=(const CreateAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateAccount& operator=(CreateAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateAccount* internal_default_instance() {
    return reinterpret_cast<const CreateAccount*>(
               &_CreateAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CreateAccount& a, CreateAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateAccount* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateAccount* New() const final {
    return new CreateAccount();
  }

  CreateAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateAccount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateAccount* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.CreateAccount";
  }
  protected:
  explicit CreateAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.CreateAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class CreateCharacter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.CreateCharacter) */ {
 public:
  inline CreateCharacter() : CreateCharacter(nullptr) {}
  ~CreateCharacter() override;
  explicit constexpr CreateCharacter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateCharacter(const CreateCharacter& from);
  CreateCharacter(CreateCharacter&& from) noexcept
    : CreateCharacter() {
    *this = ::std::move(from);
  }

  inline CreateCharacter& operator=(const CreateCharacter& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateCharacter& operator=(CreateCharacter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateCharacter& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateCharacter* internal_default_instance() {
    return reinterpret_cast<const CreateCharacter*>(
               &_CreateCharacter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CreateCharacter& a, CreateCharacter& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateCharacter* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateCharacter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateCharacter* New() const final {
    return new CreateCharacter();
  }

  CreateCharacter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateCharacter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateCharacter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateCharacter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateCharacter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.CreateCharacter";
  }
  protected:
  explicit CreateCharacter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharaterFieldNumber = 1,
  };
  // .protocol.Charater charater = 1;
  bool has_charater() const;
  private:
  bool _internal_has_charater() const;
  public:
  void clear_charater();
  const ::protocol::Charater& charater() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Charater* release_charater();
  ::protocol::Charater* mutable_charater();
  void set_allocated_charater(::protocol::Charater* charater);
  private:
  const ::protocol::Charater& _internal_charater() const;
  ::protocol::Charater* _internal_mutable_charater();
  public:
  void unsafe_arena_set_allocated_charater(
      ::protocol::Charater* charater);
  ::protocol::Charater* unsafe_arena_release_charater();

  // @@protoc_insertion_point(class_scope:protocol.CreateCharacter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::Charater* charater_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class CUpdateAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.CUpdateAccount) */ {
 public:
  inline CUpdateAccount() : CUpdateAccount(nullptr) {}
  ~CUpdateAccount() override;
  explicit constexpr CUpdateAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CUpdateAccount(const CUpdateAccount& from);
  CUpdateAccount(CUpdateAccount&& from) noexcept
    : CUpdateAccount() {
    *this = ::std::move(from);
  }

  inline CUpdateAccount& operator=(const CUpdateAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline CUpdateAccount& operator=(CUpdateAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CUpdateAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const CUpdateAccount* internal_default_instance() {
    return reinterpret_cast<const CUpdateAccount*>(
               &_CUpdateAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CUpdateAccount& a, CUpdateAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(CUpdateAccount* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CUpdateAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CUpdateAccount* New() const final {
    return new CUpdateAccount();
  }

  CUpdateAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CUpdateAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CUpdateAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CUpdateAccount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CUpdateAccount* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.CUpdateAccount";
  }
  protected:
  explicit CUpdateAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharaterTypeFieldNumber = 1,
    kWeaponTypeFieldNumber = 2,
    kUseCashFieldNumber = 3,
  };
  // int32 charaterType = 1;
  void clear_charatertype();
  ::PROTOBUF_NAMESPACE_ID::int32 charatertype() const;
  void set_charatertype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_charatertype() const;
  void _internal_set_charatertype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 weaponType = 2;
  void clear_weapontype();
  ::PROTOBUF_NAMESPACE_ID::int32 weapontype() const;
  void set_weapontype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_weapontype() const;
  void _internal_set_weapontype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 useCash = 3;
  void clear_usecash();
  ::PROTOBUF_NAMESPACE_ID::int32 usecash() const;
  void set_usecash(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_usecash() const;
  void _internal_set_usecash(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.CUpdateAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 charatertype_;
  ::PROTOBUF_NAMESPACE_ID::int32 weapontype_;
  ::PROTOBUF_NAMESPACE_ID::int32 usecash_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class SCurrentInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SCurrentInfo) */ {
 public:
  inline SCurrentInfo() : SCurrentInfo(nullptr) {}
  ~SCurrentInfo() override;
  explicit constexpr SCurrentInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SCurrentInfo(const SCurrentInfo& from);
  SCurrentInfo(SCurrentInfo&& from) noexcept
    : SCurrentInfo() {
    *this = ::std::move(from);
  }

  inline SCurrentInfo& operator=(const SCurrentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCurrentInfo& operator=(SCurrentInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCurrentInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCurrentInfo* internal_default_instance() {
    return reinterpret_cast<const SCurrentInfo*>(
               &_SCurrentInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SCurrentInfo& a, SCurrentInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SCurrentInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCurrentInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SCurrentInfo* New() const final {
    return new SCurrentInfo();
  }

  SCurrentInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SCurrentInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SCurrentInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SCurrentInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCurrentInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SCurrentInfo";
  }
  protected:
  explicit SCurrentInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharaterFieldNumber = 4,
    kCashFieldNumber = 1,
    kCharaterTypeFieldNumber = 2,
    kWeaponTypeFieldNumber = 3,
    kExpFieldNumber = 5,
  };
  // .protocol.Charater charater = 4;
  bool has_charater() const;
  private:
  bool _internal_has_charater() const;
  public:
  void clear_charater();
  const ::protocol::Charater& charater() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Charater* release_charater();
  ::protocol::Charater* mutable_charater();
  void set_allocated_charater(::protocol::Charater* charater);
  private:
  const ::protocol::Charater& _internal_charater() const;
  ::protocol::Charater* _internal_mutable_charater();
  public:
  void unsafe_arena_set_allocated_charater(
      ::protocol::Charater* charater);
  ::protocol::Charater* unsafe_arena_release_charater();

  // int32 cash = 1;
  void clear_cash();
  ::PROTOBUF_NAMESPACE_ID::int32 cash() const;
  void set_cash(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cash() const;
  void _internal_set_cash(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 charaterType = 2;
  void clear_charatertype();
  ::PROTOBUF_NAMESPACE_ID::int32 charatertype() const;
  void set_charatertype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_charatertype() const;
  void _internal_set_charatertype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 weaponType = 3;
  void clear_weapontype();
  ::PROTOBUF_NAMESPACE_ID::int32 weapontype() const;
  void set_weapontype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_weapontype() const;
  void _internal_set_weapontype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 exp = 5;
  void clear_exp();
  ::PROTOBUF_NAMESPACE_ID::int32 exp() const;
  void set_exp(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_exp() const;
  void _internal_set_exp(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SCurrentInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::Charater* charater_;
  ::PROTOBUF_NAMESPACE_ID::int32 cash_;
  ::PROTOBUF_NAMESPACE_ID::int32 charatertype_;
  ::PROTOBUF_NAMESPACE_ID::int32 weapontype_;
  ::PROTOBUF_NAMESPACE_ID::int32 exp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class LoginAccess final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.LoginAccess) */ {
 public:
  inline LoginAccess() : LoginAccess(nullptr) {}
  ~LoginAccess() override;
  explicit constexpr LoginAccess(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginAccess(const LoginAccess& from);
  LoginAccess(LoginAccess&& from) noexcept
    : LoginAccess() {
    *this = ::std::move(from);
  }

  inline LoginAccess& operator=(const LoginAccess& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginAccess& operator=(LoginAccess&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginAccess& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginAccess* internal_default_instance() {
    return reinterpret_cast<const LoginAccess*>(
               &_LoginAccess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LoginAccess& a, LoginAccess& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginAccess* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginAccess* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoginAccess* New() const final {
    return new LoginAccess();
  }

  LoginAccess* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoginAccess>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginAccess& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginAccess& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginAccess* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.LoginAccess";
  }
  protected:
  explicit LoginAccess(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharaterFieldNumber = 2,
    kWeaponListFieldNumber = 6,
    kSuccessFieldNumber = 1,
    kCurCharaterTypeFieldNumber = 3,
    kCurWeaponTypeFieldNumber = 4,
    kCashFieldNumber = 5,
  };
  // repeated .protocol.Charater charater = 2;
  int charater_size() const;
  private:
  int _internal_charater_size() const;
  public:
  void clear_charater();
  ::protocol::Charater* mutable_charater(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Charater >*
      mutable_charater();
  private:
  const ::protocol::Charater& _internal_charater(int index) const;
  ::protocol::Charater* _internal_add_charater();
  public:
  const ::protocol::Charater& charater(int index) const;
  ::protocol::Charater* add_charater();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Charater >&
      charater() const;

  // repeated int32 weaponList = 6;
  int weaponlist_size() const;
  private:
  int _internal_weaponlist_size() const;
  public:
  void clear_weaponlist();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_weaponlist(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_weaponlist() const;
  void _internal_add_weaponlist(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_weaponlist();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 weaponlist(int index) const;
  void set_weaponlist(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_weaponlist(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      weaponlist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_weaponlist();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // int32 curCharaterType = 3;
  void clear_curcharatertype();
  ::PROTOBUF_NAMESPACE_ID::int32 curcharatertype() const;
  void set_curcharatertype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_curcharatertype() const;
  void _internal_set_curcharatertype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 curWeaponType = 4;
  void clear_curweapontype();
  ::PROTOBUF_NAMESPACE_ID::int32 curweapontype() const;
  void set_curweapontype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_curweapontype() const;
  void _internal_set_curweapontype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 cash = 5;
  void clear_cash();
  ::PROTOBUF_NAMESPACE_ID::int32 cash() const;
  void set_cash(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cash() const;
  void _internal_set_cash(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.LoginAccess)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Charater > charater_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > weaponlist_;
  mutable std::atomic<int> _weaponlist_cached_byte_size_;
  bool success_;
  ::PROTOBUF_NAMESPACE_ID::int32 curcharatertype_;
  ::PROTOBUF_NAMESPACE_ID::int32 curweapontype_;
  ::PROTOBUF_NAMESPACE_ID::int32 cash_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class Charater final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Charater) */ {
 public:
  inline Charater() : Charater(nullptr) {}
  ~Charater() override;
  explicit constexpr Charater(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Charater(const Charater& from);
  Charater(Charater&& from) noexcept
    : Charater() {
    *this = ::std::move(from);
  }

  inline Charater& operator=(const Charater& from) {
    CopyFrom(from);
    return *this;
  }
  inline Charater& operator=(Charater&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Charater& default_instance() {
    return *internal_default_instance();
  }
  static inline const Charater* internal_default_instance() {
    return reinterpret_cast<const Charater*>(
               &_Charater_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Charater& a, Charater& b) {
    a.Swap(&b);
  }
  inline void Swap(Charater* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Charater* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Charater* New() const final {
    return new Charater();
  }

  Charater* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Charater>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Charater& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Charater& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Charater* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Charater";
  }
  protected:
  explicit Charater(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kUuidFieldNumber = 1,
    kCodeFieldNumber = 2,
    kLvFieldNumber = 4,
  };
  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 uuid = 1;
  void clear_uuid();
  ::PROTOBUF_NAMESPACE_ID::int32 uuid() const;
  void set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_uuid() const;
  void _internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 code = 2;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 lv = 4;
  void clear_lv();
  ::PROTOBUF_NAMESPACE_ID::int32 lv() const;
  void set_lv(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_lv() const;
  void _internal_set_lv(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Charater)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 uuid_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  ::PROTOBUF_NAMESPACE_ID::int32 lv_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class Position final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Position) */ {
 public:
  inline Position() : Position(nullptr) {}
  ~Position() override;
  explicit constexpr Position(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Position(const Position& from);
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  inline Position& operator=(Position&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Position& default_instance() {
    return *internal_default_instance();
  }
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }
  inline void Swap(Position* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Position* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Position* New() const final {
    return new Position();
  }

  Position* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Position& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Position& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Position";
  }
  protected:
  explicit Position(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kYawFieldNumber = 4,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // float yaw = 4;
  void clear_yaw();
  float yaw() const;
  void set_yaw(float value);
  private:
  float _internal_yaw() const;
  void _internal_set_yaw(float value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Position)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  float z_;
  float yaw_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class Unit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Unit) */ {
 public:
  inline Unit() : Unit(nullptr) {}
  ~Unit() override;
  explicit constexpr Unit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Unit(const Unit& from);
  Unit(Unit&& from) noexcept
    : Unit() {
    *this = ::std::move(from);
  }

  inline Unit& operator=(const Unit& from) {
    CopyFrom(from);
    return *this;
  }
  inline Unit& operator=(Unit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Unit& default_instance() {
    return *internal_default_instance();
  }
  static inline const Unit* internal_default_instance() {
    return reinterpret_cast<const Unit*>(
               &_Unit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Unit& a, Unit& b) {
    a.Swap(&b);
  }
  inline void Swap(Unit* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Unit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Unit* New() const final {
    return new Unit();
  }

  Unit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Unit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Unit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Unit& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Unit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Unit";
  }
  protected:
  explicit Unit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 5,
    kPositionFieldNumber = 4,
    kUuidFieldNumber = 1,
    kHpFieldNumber = 2,
    kCodeFieldNumber = 3,
    kLvFieldNumber = 6,
    kStateFieldNumber = 7,
    kWeaponCodeFieldNumber = 8,
  };
  // string name = 5;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .protocol.Position position = 4;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::protocol::Position& position() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Position* release_position();
  ::protocol::Position* mutable_position();
  void set_allocated_position(::protocol::Position* position);
  private:
  const ::protocol::Position& _internal_position() const;
  ::protocol::Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::protocol::Position* position);
  ::protocol::Position* unsafe_arena_release_position();

  // uint32 uuid = 1;
  void clear_uuid();
  ::PROTOBUF_NAMESPACE_ID::uint32 uuid() const;
  void set_uuid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_uuid() const;
  void _internal_set_uuid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 hp = 2;
  void clear_hp();
  ::PROTOBUF_NAMESPACE_ID::uint32 hp() const;
  void set_hp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_hp() const;
  void _internal_set_hp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // int32 code = 3;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 lv = 6;
  void clear_lv();
  ::PROTOBUF_NAMESPACE_ID::int32 lv() const;
  void set_lv(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_lv() const;
  void _internal_set_lv(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 state = 7;
  void clear_state();
  ::PROTOBUF_NAMESPACE_ID::int32 state() const;
  void set_state(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_state() const;
  void _internal_set_state(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 weaponCode = 8;
  void clear_weaponcode();
  ::PROTOBUF_NAMESPACE_ID::int32 weaponcode() const;
  void set_weaponcode(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_weaponcode() const;
  void _internal_set_weaponcode(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Unit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::protocol::Position* position_;
  ::PROTOBUF_NAMESPACE_ID::uint32 uuid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 hp_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  ::PROTOBUF_NAMESPACE_ID::int32 lv_;
  ::PROTOBUF_NAMESPACE_ID::int32 state_;
  ::PROTOBUF_NAMESPACE_ID::int32 weaponcode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class SLoad final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SLoad) */ {
 public:
  inline SLoad() : SLoad(nullptr) {}
  ~SLoad() override;
  explicit constexpr SLoad(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLoad(const SLoad& from);
  SLoad(SLoad&& from) noexcept
    : SLoad() {
    *this = ::std::move(from);
  }

  inline SLoad& operator=(const SLoad& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLoad& operator=(SLoad&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLoad& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLoad* internal_default_instance() {
    return reinterpret_cast<const SLoad*>(
               &_SLoad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SLoad& a, SLoad& b) {
    a.Swap(&b);
  }
  inline void Swap(SLoad* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLoad* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SLoad* New() const final {
    return new SLoad();
  }

  SLoad* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SLoad>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLoad& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLoad& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLoad* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SLoad";
  }
  protected:
  explicit SLoad(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnitFieldNumber = 1,
    kRoomIdFieldNumber = 3,
  };
  // repeated .protocol.UnitState unit = 1;
  int unit_size() const;
  private:
  int _internal_unit_size() const;
  public:
  void clear_unit();
  ::protocol::UnitState* mutable_unit(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::UnitState >*
      mutable_unit();
  private:
  const ::protocol::UnitState& _internal_unit(int index) const;
  ::protocol::UnitState* _internal_add_unit();
  public:
  const ::protocol::UnitState& unit(int index) const;
  ::protocol::UnitState* add_unit();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::UnitState >&
      unit() const;

  // int32 room_id = 3;
  void clear_room_id();
  ::PROTOBUF_NAMESPACE_ID::int32 room_id() const;
  void set_room_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_room_id() const;
  void _internal_set_room_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SLoad)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::UnitState > unit_;
  ::PROTOBUF_NAMESPACE_ID::int32 room_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class CLoad final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.CLoad) */ {
 public:
  inline CLoad() : CLoad(nullptr) {}
  ~CLoad() override;
  explicit constexpr CLoad(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CLoad(const CLoad& from);
  CLoad(CLoad&& from) noexcept
    : CLoad() {
    *this = ::std::move(from);
  }

  inline CLoad& operator=(const CLoad& from) {
    CopyFrom(from);
    return *this;
  }
  inline CLoad& operator=(CLoad&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CLoad& default_instance() {
    return *internal_default_instance();
  }
  static inline const CLoad* internal_default_instance() {
    return reinterpret_cast<const CLoad*>(
               &_CLoad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CLoad& a, CLoad& b) {
    a.Swap(&b);
  }
  inline void Swap(CLoad* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CLoad* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CLoad* New() const final {
    return new CLoad();
  }

  CLoad* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CLoad>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CLoad& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CLoad& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CLoad* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.CLoad";
  }
  protected:
  explicit CLoad(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 100,
    kCodeFieldNumber = 1,
    kIsDummyFieldNumber = 101,
  };
  // .protocol.Position position = 100;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::protocol::Position& position() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Position* release_position();
  ::protocol::Position* mutable_position();
  void set_allocated_position(::protocol::Position* position);
  private:
  const ::protocol::Position& _internal_position() const;
  ::protocol::Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::protocol::Position* position);
  ::protocol::Position* unsafe_arena_release_position();

  // int32 code = 1;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool is_dummy = 101;
  void clear_is_dummy();
  bool is_dummy() const;
  void set_is_dummy(bool value);
  private:
  bool _internal_is_dummy() const;
  void _internal_set_is_dummy(bool value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.CLoad)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::Position* position_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  bool is_dummy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class SInsertplayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SInsertplayer) */ {
 public:
  inline SInsertplayer() : SInsertplayer(nullptr) {}
  ~SInsertplayer() override;
  explicit constexpr SInsertplayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SInsertplayer(const SInsertplayer& from);
  SInsertplayer(SInsertplayer&& from) noexcept
    : SInsertplayer() {
    *this = ::std::move(from);
  }

  inline SInsertplayer& operator=(const SInsertplayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline SInsertplayer& operator=(SInsertplayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SInsertplayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const SInsertplayer* internal_default_instance() {
    return reinterpret_cast<const SInsertplayer*>(
               &_SInsertplayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SInsertplayer& a, SInsertplayer& b) {
    a.Swap(&b);
  }
  inline void Swap(SInsertplayer* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SInsertplayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SInsertplayer* New() const final {
    return new SInsertplayer();
  }

  SInsertplayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SInsertplayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SInsertplayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SInsertplayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SInsertplayer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SInsertplayer";
  }
  protected:
  explicit SInsertplayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerFieldNumber = 1,
  };
  // .protocol.Unit player = 1;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::protocol::Unit& player() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Unit* release_player();
  ::protocol::Unit* mutable_player();
  void set_allocated_player(::protocol::Unit* player);
  private:
  const ::protocol::Unit& _internal_player() const;
  ::protocol::Unit* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::protocol::Unit* player);
  ::protocol::Unit* unsafe_arena_release_player();

  // @@protoc_insertion_point(class_scope:protocol.SInsertplayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::Unit* player_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class SMove final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SMove) */ {
 public:
  inline SMove() : SMove(nullptr) {}
  ~SMove() override;
  explicit constexpr SMove(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SMove(const SMove& from);
  SMove(SMove&& from) noexcept
    : SMove() {
    *this = ::std::move(from);
  }

  inline SMove& operator=(const SMove& from) {
    CopyFrom(from);
    return *this;
  }
  inline SMove& operator=(SMove&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SMove& default_instance() {
    return *internal_default_instance();
  }
  static inline const SMove* internal_default_instance() {
    return reinterpret_cast<const SMove*>(
               &_SMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SMove& a, SMove& b) {
    a.Swap(&b);
  }
  inline void Swap(SMove* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SMove* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SMove* New() const final {
    return new SMove();
  }

  SMove* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SMove>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SMove& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SMove& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SMove* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SMove";
  }
  protected:
  explicit SMove(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 2,
    kUuidFieldNumber = 1,
    kIsMonsterFieldNumber = 3,
  };
  // .protocol.Position position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::protocol::Position& position() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Position* release_position();
  ::protocol::Position* mutable_position();
  void set_allocated_position(::protocol::Position* position);
  private:
  const ::protocol::Position& _internal_position() const;
  ::protocol::Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::protocol::Position* position);
  ::protocol::Position* unsafe_arena_release_position();

  // int32 uuid = 1;
  void clear_uuid();
  ::PROTOBUF_NAMESPACE_ID::int32 uuid() const;
  void set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_uuid() const;
  void _internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool is_monster = 3;
  void clear_is_monster();
  bool is_monster() const;
  void set_is_monster(bool value);
  private:
  bool _internal_is_monster() const;
  void _internal_set_is_monster(bool value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SMove)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::Position* position_;
  ::PROTOBUF_NAMESPACE_ID::int32 uuid_;
  bool is_monster_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class SChat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SChat) */ {
 public:
  inline SChat() : SChat(nullptr) {}
  ~SChat() override;
  explicit constexpr SChat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SChat(const SChat& from);
  SChat(SChat&& from) noexcept
    : SChat() {
    *this = ::std::move(from);
  }

  inline SChat& operator=(const SChat& from) {
    CopyFrom(from);
    return *this;
  }
  inline SChat& operator=(SChat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SChat& default_instance() {
    return *internal_default_instance();
  }
  static inline const SChat* internal_default_instance() {
    return reinterpret_cast<const SChat*>(
               &_SChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SChat& a, SChat& b) {
    a.Swap(&b);
  }
  inline void Swap(SChat* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SChat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SChat* New() const final {
    return new SChat();
  }

  SChat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SChat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SChat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SChat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SChat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SChat";
  }
  protected:
  explicit SChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 5,
    kTypeFieldNumber = 1,
    kUuidFieldNumber = 2,
  };
  // string text = 5;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_MUST_USE_RESULT std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // uint32 type = 1;
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::uint32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // int32 uuid = 2;
  void clear_uuid();
  ::PROTOBUF_NAMESPACE_ID::int32 uuid() const;
  void set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_uuid() const;
  void _internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SChat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::PROTOBUF_NAMESPACE_ID::uint32 type_;
  ::PROTOBUF_NAMESPACE_ID::int32 uuid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class SPlayerData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SPlayerData) */ {
 public:
  inline SPlayerData() : SPlayerData(nullptr) {}
  ~SPlayerData() override;
  explicit constexpr SPlayerData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SPlayerData(const SPlayerData& from);
  SPlayerData(SPlayerData&& from) noexcept
    : SPlayerData() {
    *this = ::std::move(from);
  }

  inline SPlayerData& operator=(const SPlayerData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SPlayerData& operator=(SPlayerData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SPlayerData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SPlayerData* internal_default_instance() {
    return reinterpret_cast<const SPlayerData*>(
               &_SPlayerData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SPlayerData& a, SPlayerData& b) {
    a.Swap(&b);
  }
  inline void Swap(SPlayerData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SPlayerData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SPlayerData* New() const final {
    return new SPlayerData();
  }

  SPlayerData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SPlayerData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SPlayerData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SPlayerData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SPlayerData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SPlayerData";
  }
  protected:
  explicit SPlayerData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerFieldNumber = 1,
    kExpFieldNumber = 2,
  };
  // .protocol.Unit player = 1;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::protocol::Unit& player() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Unit* release_player();
  ::protocol::Unit* mutable_player();
  void set_allocated_player(::protocol::Unit* player);
  private:
  const ::protocol::Unit& _internal_player() const;
  ::protocol::Unit* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::protocol::Unit* player);
  ::protocol::Unit* unsafe_arena_release_player();

  // int32 exp = 2;
  void clear_exp();
  ::PROTOBUF_NAMESPACE_ID::int32 exp() const;
  void set_exp(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_exp() const;
  void _internal_set_exp(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SPlayerData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::Unit* player_;
  ::PROTOBUF_NAMESPACE_ID::int32 exp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class SClosePlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SClosePlayer) */ {
 public:
  inline SClosePlayer() : SClosePlayer(nullptr) {}
  ~SClosePlayer() override;
  explicit constexpr SClosePlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SClosePlayer(const SClosePlayer& from);
  SClosePlayer(SClosePlayer&& from) noexcept
    : SClosePlayer() {
    *this = ::std::move(from);
  }

  inline SClosePlayer& operator=(const SClosePlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline SClosePlayer& operator=(SClosePlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SClosePlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const SClosePlayer* internal_default_instance() {
    return reinterpret_cast<const SClosePlayer*>(
               &_SClosePlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SClosePlayer& a, SClosePlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(SClosePlayer* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SClosePlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SClosePlayer* New() const final {
    return new SClosePlayer();
  }

  SClosePlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SClosePlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SClosePlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SClosePlayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SClosePlayer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SClosePlayer";
  }
  protected:
  explicit SClosePlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
  };
  // int32 uuid = 1;
  void clear_uuid();
  ::PROTOBUF_NAMESPACE_ID::int32 uuid() const;
  void set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_uuid() const;
  void _internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SClosePlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 uuid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class UnitState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.UnitState) */ {
 public:
  inline UnitState() : UnitState(nullptr) {}
  ~UnitState() override;
  explicit constexpr UnitState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnitState(const UnitState& from);
  UnitState(UnitState&& from) noexcept
    : UnitState() {
    *this = ::std::move(from);
  }

  inline UnitState& operator=(const UnitState& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnitState& operator=(UnitState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnitState& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnitState* internal_default_instance() {
    return reinterpret_cast<const UnitState*>(
               &_UnitState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(UnitState& a, UnitState& b) {
    a.Swap(&b);
  }
  inline void Swap(UnitState* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnitState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnitState* New() const final {
    return new UnitState();
  }

  UnitState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnitState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnitState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnitState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.UnitState";
  }
  protected:
  explicit UnitState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnitFieldNumber = 1,
    kAttackFieldNumber = 11,
    kIsMonsterFieldNumber = 10,
  };
  // .protocol.Unit unit = 1;
  bool has_unit() const;
  private:
  bool _internal_has_unit() const;
  public:
  void clear_unit();
  const ::protocol::Unit& unit() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Unit* release_unit();
  ::protocol::Unit* mutable_unit();
  void set_allocated_unit(::protocol::Unit* unit);
  private:
  const ::protocol::Unit& _internal_unit() const;
  ::protocol::Unit* _internal_mutable_unit();
  public:
  void unsafe_arena_set_allocated_unit(
      ::protocol::Unit* unit);
  ::protocol::Unit* unsafe_arena_release_unit();

  // .protocol.Attack attack = 11;
  bool has_attack() const;
  private:
  bool _internal_has_attack() const;
  public:
  void clear_attack();
  const ::protocol::Attack& attack() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Attack* release_attack();
  ::protocol::Attack* mutable_attack();
  void set_allocated_attack(::protocol::Attack* attack);
  private:
  const ::protocol::Attack& _internal_attack() const;
  ::protocol::Attack* _internal_mutable_attack();
  public:
  void unsafe_arena_set_allocated_attack(
      ::protocol::Attack* attack);
  ::protocol::Attack* unsafe_arena_release_attack();

  // bool is_monster = 10;
  void clear_is_monster();
  bool is_monster() const;
  void set_is_monster(bool value);
  private:
  bool _internal_is_monster() const;
  void _internal_set_is_monster(bool value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.UnitState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::Unit* unit_;
  ::protocol::Attack* attack_;
  bool is_monster_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class SUnitStates final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SUnitStates) */ {
 public:
  inline SUnitStates() : SUnitStates(nullptr) {}
  ~SUnitStates() override;
  explicit constexpr SUnitStates(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SUnitStates(const SUnitStates& from);
  SUnitStates(SUnitStates&& from) noexcept
    : SUnitStates() {
    *this = ::std::move(from);
  }

  inline SUnitStates& operator=(const SUnitStates& from) {
    CopyFrom(from);
    return *this;
  }
  inline SUnitStates& operator=(SUnitStates&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SUnitStates& default_instance() {
    return *internal_default_instance();
  }
  static inline const SUnitStates* internal_default_instance() {
    return reinterpret_cast<const SUnitStates*>(
               &_SUnitStates_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SUnitStates& a, SUnitStates& b) {
    a.Swap(&b);
  }
  inline void Swap(SUnitStates* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SUnitStates* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SUnitStates* New() const final {
    return new SUnitStates();
  }

  SUnitStates* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SUnitStates>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SUnitStates& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SUnitStates& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SUnitStates* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SUnitStates";
  }
  protected:
  explicit SUnitStates(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnitStateFieldNumber = 1,
  };
  // repeated .protocol.UnitState unit_state = 1;
  int unit_state_size() const;
  private:
  int _internal_unit_state_size() const;
  public:
  void clear_unit_state();
  ::protocol::UnitState* mutable_unit_state(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::UnitState >*
      mutable_unit_state();
  private:
  const ::protocol::UnitState& _internal_unit_state(int index) const;
  ::protocol::UnitState* _internal_add_unit_state();
  public:
  const ::protocol::UnitState& unit_state(int index) const;
  ::protocol::UnitState* add_unit_state();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::UnitState >&
      unit_state() const;

  // @@protoc_insertion_point(class_scope:protocol.SUnitStates)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::UnitState > unit_state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class Attack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Attack) */ {
 public:
  inline Attack() : Attack(nullptr) {}
  ~Attack() override;
  explicit constexpr Attack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Attack(const Attack& from);
  Attack(Attack&& from) noexcept
    : Attack() {
    *this = ::std::move(from);
  }

  inline Attack& operator=(const Attack& from) {
    CopyFrom(from);
    return *this;
  }
  inline Attack& operator=(Attack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Attack& default_instance() {
    return *internal_default_instance();
  }
  static inline const Attack* internal_default_instance() {
    return reinterpret_cast<const Attack*>(
               &_Attack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Attack& a, Attack& b) {
    a.Swap(&b);
  }
  inline void Swap(Attack* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Attack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Attack* New() const final {
    return new Attack();
  }

  Attack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Attack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Attack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Attack& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Attack* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Attack";
  }
  protected:
  explicit Attack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kSkillCodeFieldNumber = 2,
    kTargetUuidFieldNumber = 3,
  };
  // int32 uuid = 1;
  void clear_uuid();
  ::PROTOBUF_NAMESPACE_ID::int32 uuid() const;
  void set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_uuid() const;
  void _internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 skill_code = 2;
  void clear_skill_code();
  ::PROTOBUF_NAMESPACE_ID::int32 skill_code() const;
  void set_skill_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_skill_code() const;
  void _internal_set_skill_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 target_uuid = 3;
  void clear_target_uuid();
  ::PROTOBUF_NAMESPACE_ID::int32 target_uuid() const;
  void set_target_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_target_uuid() const;
  void _internal_set_target_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Attack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 uuid_;
  ::PROTOBUF_NAMESPACE_ID::int32 skill_code_;
  ::PROTOBUF_NAMESPACE_ID::int32 target_uuid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class CAttack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.CAttack) */ {
 public:
  inline CAttack() : CAttack(nullptr) {}
  ~CAttack() override;
  explicit constexpr CAttack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAttack(const CAttack& from);
  CAttack(CAttack&& from) noexcept
    : CAttack() {
    *this = ::std::move(from);
  }

  inline CAttack& operator=(const CAttack& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAttack& operator=(CAttack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAttack& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAttack* internal_default_instance() {
    return reinterpret_cast<const CAttack*>(
               &_CAttack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CAttack& a, CAttack& b) {
    a.Swap(&b);
  }
  inline void Swap(CAttack* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAttack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CAttack* New() const final {
    return new CAttack();
  }

  CAttack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CAttack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAttack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAttack& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAttack* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.CAttack";
  }
  protected:
  explicit CAttack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 4,
    kUuidFieldNumber = 1,
    kSkillCodeFieldNumber = 2,
    kTargetUuidFieldNumber = 3,
  };
  // .protocol.Position position = 4;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::protocol::Position& position() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Position* release_position();
  ::protocol::Position* mutable_position();
  void set_allocated_position(::protocol::Position* position);
  private:
  const ::protocol::Position& _internal_position() const;
  ::protocol::Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::protocol::Position* position);
  ::protocol::Position* unsafe_arena_release_position();

  // int32 uuid = 1;
  void clear_uuid();
  ::PROTOBUF_NAMESPACE_ID::int32 uuid() const;
  void set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_uuid() const;
  void _internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 skill_code = 2;
  void clear_skill_code();
  ::PROTOBUF_NAMESPACE_ID::int32 skill_code() const;
  void set_skill_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_skill_code() const;
  void _internal_set_skill_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 target_uuid = 3;
  void clear_target_uuid();
  ::PROTOBUF_NAMESPACE_ID::int32 target_uuid() const;
  void set_target_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_target_uuid() const;
  void _internal_set_target_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.CAttack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::Position* position_;
  ::PROTOBUF_NAMESPACE_ID::int32 uuid_;
  ::PROTOBUF_NAMESPACE_ID::int32 skill_code_;
  ::PROTOBUF_NAMESPACE_ID::int32 target_uuid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class Demage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Demage) */ {
 public:
  inline Demage() : Demage(nullptr) {}
  ~Demage() override;
  explicit constexpr Demage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Demage(const Demage& from);
  Demage(Demage&& from) noexcept
    : Demage() {
    *this = ::std::move(from);
  }

  inline Demage& operator=(const Demage& from) {
    CopyFrom(from);
    return *this;
  }
  inline Demage& operator=(Demage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Demage& default_instance() {
    return *internal_default_instance();
  }
  static inline const Demage* internal_default_instance() {
    return reinterpret_cast<const Demage*>(
               &_Demage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Demage& a, Demage& b) {
    a.Swap(&b);
  }
  inline void Swap(Demage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Demage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Demage* New() const final {
    return new Demage();
  }

  Demage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Demage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Demage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Demage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Demage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Demage";
  }
  protected:
  explicit Demage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 3,
    kUuidFieldNumber = 1,
    kDemageFieldNumber = 2,
    kIsHealFieldNumber = 4,
    kIsMonsterFieldNumber = 10,
  };
  // .protocol.Position position = 3;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::protocol::Position& position() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Position* release_position();
  ::protocol::Position* mutable_position();
  void set_allocated_position(::protocol::Position* position);
  private:
  const ::protocol::Position& _internal_position() const;
  ::protocol::Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::protocol::Position* position);
  ::protocol::Position* unsafe_arena_release_position();

  // int32 uuid = 1;
  void clear_uuid();
  ::PROTOBUF_NAMESPACE_ID::int32 uuid() const;
  void set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_uuid() const;
  void _internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 demage = 2;
  void clear_demage();
  ::PROTOBUF_NAMESPACE_ID::int32 demage() const;
  void set_demage(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_demage() const;
  void _internal_set_demage(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool is_heal = 4;
  void clear_is_heal();
  bool is_heal() const;
  void set_is_heal(bool value);
  private:
  bool _internal_is_heal() const;
  void _internal_set_is_heal(bool value);
  public:

  // bool is_monster = 10;
  void clear_is_monster();
  bool is_monster() const;
  void set_is_monster(bool value);
  private:
  bool _internal_is_monster() const;
  void _internal_set_is_monster(bool value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Demage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::Position* position_;
  ::PROTOBUF_NAMESPACE_ID::int32 uuid_;
  ::PROTOBUF_NAMESPACE_ID::int32 demage_;
  bool is_heal_;
  bool is_monster_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class SUnitDemage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SUnitDemage) */ {
 public:
  inline SUnitDemage() : SUnitDemage(nullptr) {}
  ~SUnitDemage() override;
  explicit constexpr SUnitDemage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SUnitDemage(const SUnitDemage& from);
  SUnitDemage(SUnitDemage&& from) noexcept
    : SUnitDemage() {
    *this = ::std::move(from);
  }

  inline SUnitDemage& operator=(const SUnitDemage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SUnitDemage& operator=(SUnitDemage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SUnitDemage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SUnitDemage* internal_default_instance() {
    return reinterpret_cast<const SUnitDemage*>(
               &_SUnitDemage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SUnitDemage& a, SUnitDemage& b) {
    a.Swap(&b);
  }
  inline void Swap(SUnitDemage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SUnitDemage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SUnitDemage* New() const final {
    return new SUnitDemage();
  }

  SUnitDemage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SUnitDemage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SUnitDemage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SUnitDemage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SUnitDemage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SUnitDemage";
  }
  protected:
  explicit SUnitDemage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDemageFieldNumber = 3,
    kUuidFieldNumber = 1,
    kIsMonsterFieldNumber = 2,
  };
  // repeated .protocol.Demage demage = 3;
  int demage_size() const;
  private:
  int _internal_demage_size() const;
  public:
  void clear_demage();
  ::protocol::Demage* mutable_demage(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Demage >*
      mutable_demage();
  private:
  const ::protocol::Demage& _internal_demage(int index) const;
  ::protocol::Demage* _internal_add_demage();
  public:
  const ::protocol::Demage& demage(int index) const;
  ::protocol::Demage* add_demage();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Demage >&
      demage() const;

  // int32 uuid = 1;
  void clear_uuid();
  ::PROTOBUF_NAMESPACE_ID::int32 uuid() const;
  void set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_uuid() const;
  void _internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool is_monster = 2;
  void clear_is_monster();
  bool is_monster() const;
  void set_is_monster(bool value);
  private:
  bool _internal_is_monster() const;
  void _internal_set_is_monster(bool value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SUnitDemage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Demage > demage_;
  ::PROTOBUF_NAMESPACE_ID::int32 uuid_;
  bool is_monster_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class SRoomQuest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SRoomQuest) */ {
 public:
  inline SRoomQuest() : SRoomQuest(nullptr) {}
  ~SRoomQuest() override;
  explicit constexpr SRoomQuest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SRoomQuest(const SRoomQuest& from);
  SRoomQuest(SRoomQuest&& from) noexcept
    : SRoomQuest() {
    *this = ::std::move(from);
  }

  inline SRoomQuest& operator=(const SRoomQuest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SRoomQuest& operator=(SRoomQuest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SRoomQuest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SRoomQuest* internal_default_instance() {
    return reinterpret_cast<const SRoomQuest*>(
               &_SRoomQuest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SRoomQuest& a, SRoomQuest& b) {
    a.Swap(&b);
  }
  inline void Swap(SRoomQuest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SRoomQuest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SRoomQuest* New() const final {
    return new SRoomQuest();
  }

  SRoomQuest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SRoomQuest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SRoomQuest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SRoomQuest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SRoomQuest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SRoomQuest";
  }
  protected:
  explicit SRoomQuest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsClearFieldNumber = 1,
    kKillCountFieldNumber = 2,
    kSumKillFieldNumber = 3,
  };
  // bool is_clear = 1;
  void clear_is_clear();
  bool is_clear() const;
  void set_is_clear(bool value);
  private:
  bool _internal_is_clear() const;
  void _internal_set_is_clear(bool value);
  public:

  // int32 kill_count = 2;
  void clear_kill_count();
  ::PROTOBUF_NAMESPACE_ID::int32 kill_count() const;
  void set_kill_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_kill_count() const;
  void _internal_set_kill_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 sum_kill = 3;
  void clear_sum_kill();
  ::PROTOBUF_NAMESPACE_ID::int32 sum_kill() const;
  void set_sum_kill(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_sum_kill() const;
  void _internal_set_sum_kill(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SRoomQuest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool is_clear_;
  ::PROTOBUF_NAMESPACE_ID::int32 kill_count_;
  ::PROTOBUF_NAMESPACE_ID::int32 sum_kill_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class CMovePotal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.CMovePotal) */ {
 public:
  inline CMovePotal() : CMovePotal(nullptr) {}
  ~CMovePotal() override;
  explicit constexpr CMovePotal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMovePotal(const CMovePotal& from);
  CMovePotal(CMovePotal&& from) noexcept
    : CMovePotal() {
    *this = ::std::move(from);
  }

  inline CMovePotal& operator=(const CMovePotal& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMovePotal& operator=(CMovePotal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMovePotal& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMovePotal* internal_default_instance() {
    return reinterpret_cast<const CMovePotal*>(
               &_CMovePotal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(CMovePotal& a, CMovePotal& b) {
    a.Swap(&b);
  }
  inline void Swap(CMovePotal* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMovePotal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CMovePotal* New() const final {
    return new CMovePotal();
  }

  CMovePotal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CMovePotal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMovePotal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMovePotal& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMovePotal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.CMovePotal";
  }
  protected:
  explicit CMovePotal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPreRoomIdFieldNumber = 1,
    kNextRoomIdFieldNumber = 2,
  };
  // int32 pre_room_id = 1;
  void clear_pre_room_id();
  ::PROTOBUF_NAMESPACE_ID::int32 pre_room_id() const;
  void set_pre_room_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_pre_room_id() const;
  void _internal_set_pre_room_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 next_room_id = 2;
  void clear_next_room_id();
  ::PROTOBUF_NAMESPACE_ID::int32 next_room_id() const;
  void set_next_room_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_next_room_id() const;
  void _internal_set_next_room_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.CMovePotal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 pre_room_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 next_room_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class SEndGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SEndGame) */ {
 public:
  inline SEndGame() : SEndGame(nullptr) {}
  ~SEndGame() override;
  explicit constexpr SEndGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SEndGame(const SEndGame& from);
  SEndGame(SEndGame&& from) noexcept
    : SEndGame() {
    *this = ::std::move(from);
  }

  inline SEndGame& operator=(const SEndGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline SEndGame& operator=(SEndGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SEndGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const SEndGame* internal_default_instance() {
    return reinterpret_cast<const SEndGame*>(
               &_SEndGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(SEndGame& a, SEndGame& b) {
    a.Swap(&b);
  }
  inline void Swap(SEndGame* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SEndGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SEndGame* New() const final {
    return new SEndGame();
  }

  SEndGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SEndGame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SEndGame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SEndGame& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SEndGame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SEndGame";
  }
  protected:
  explicit SEndGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndGameFieldNumber = 1,
  };
  // bool end_game = 1;
  void clear_end_game();
  bool end_game() const;
  void set_end_game(bool value);
  private:
  bool _internal_end_game() const;
  void _internal_set_end_game(bool value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SEndGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool end_game_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class CBuyCharater final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.CBuyCharater) */ {
 public:
  inline CBuyCharater() : CBuyCharater(nullptr) {}
  ~CBuyCharater() override;
  explicit constexpr CBuyCharater(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CBuyCharater(const CBuyCharater& from);
  CBuyCharater(CBuyCharater&& from) noexcept
    : CBuyCharater() {
    *this = ::std::move(from);
  }

  inline CBuyCharater& operator=(const CBuyCharater& from) {
    CopyFrom(from);
    return *this;
  }
  inline CBuyCharater& operator=(CBuyCharater&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CBuyCharater& default_instance() {
    return *internal_default_instance();
  }
  static inline const CBuyCharater* internal_default_instance() {
    return reinterpret_cast<const CBuyCharater*>(
               &_CBuyCharater_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CBuyCharater& a, CBuyCharater& b) {
    a.Swap(&b);
  }
  inline void Swap(CBuyCharater* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CBuyCharater* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CBuyCharater* New() const final {
    return new CBuyCharater();
  }

  CBuyCharater* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CBuyCharater>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CBuyCharater& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CBuyCharater& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CBuyCharater* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.CBuyCharater";
  }
  protected:
  explicit CBuyCharater(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kCharaterTypeFieldNumber = 1,
    kUseCashFieldNumber = 2,
  };
  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 CharaterType = 1;
  void clear_charatertype();
  ::PROTOBUF_NAMESPACE_ID::int32 charatertype() const;
  void set_charatertype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_charatertype() const;
  void _internal_set_charatertype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 useCash = 2;
  void clear_usecash();
  ::PROTOBUF_NAMESPACE_ID::int32 usecash() const;
  void set_usecash(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_usecash() const;
  void _internal_set_usecash(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.CBuyCharater)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 charatertype_;
  ::PROTOBUF_NAMESPACE_ID::int32 usecash_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class CBuyWeapon final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.CBuyWeapon) */ {
 public:
  inline CBuyWeapon() : CBuyWeapon(nullptr) {}
  ~CBuyWeapon() override;
  explicit constexpr CBuyWeapon(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CBuyWeapon(const CBuyWeapon& from);
  CBuyWeapon(CBuyWeapon&& from) noexcept
    : CBuyWeapon() {
    *this = ::std::move(from);
  }

  inline CBuyWeapon& operator=(const CBuyWeapon& from) {
    CopyFrom(from);
    return *this;
  }
  inline CBuyWeapon& operator=(CBuyWeapon&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CBuyWeapon& default_instance() {
    return *internal_default_instance();
  }
  static inline const CBuyWeapon* internal_default_instance() {
    return reinterpret_cast<const CBuyWeapon*>(
               &_CBuyWeapon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CBuyWeapon& a, CBuyWeapon& b) {
    a.Swap(&b);
  }
  inline void Swap(CBuyWeapon* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CBuyWeapon* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CBuyWeapon* New() const final {
    return new CBuyWeapon();
  }

  CBuyWeapon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CBuyWeapon>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CBuyWeapon& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CBuyWeapon& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CBuyWeapon* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.CBuyWeapon";
  }
  protected:
  explicit CBuyWeapon(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWeaponTypeFieldNumber = 1,
    kUseCashFieldNumber = 2,
  };
  // int32 weaponType = 1;
  void clear_weapontype();
  ::PROTOBUF_NAMESPACE_ID::int32 weapontype() const;
  void set_weapontype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_weapontype() const;
  void _internal_set_weapontype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 useCash = 2;
  void clear_usecash();
  ::PROTOBUF_NAMESPACE_ID::int32 usecash() const;
  void set_usecash(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_usecash() const;
  void _internal_set_usecash(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.CBuyWeapon)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 weapontype_;
  ::PROTOBUF_NAMESPACE_ID::int32 usecash_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class SBuyResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SBuyResult) */ {
 public:
  inline SBuyResult() : SBuyResult(nullptr) {}
  ~SBuyResult() override;
  explicit constexpr SBuyResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SBuyResult(const SBuyResult& from);
  SBuyResult(SBuyResult&& from) noexcept
    : SBuyResult() {
    *this = ::std::move(from);
  }

  inline SBuyResult& operator=(const SBuyResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SBuyResult& operator=(SBuyResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SBuyResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const SBuyResult* internal_default_instance() {
    return reinterpret_cast<const SBuyResult*>(
               &_SBuyResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(SBuyResult& a, SBuyResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SBuyResult* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SBuyResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SBuyResult* New() const final {
    return new SBuyResult();
  }

  SBuyResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SBuyResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SBuyResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SBuyResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SBuyResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SBuyResult";
  }
  protected:
  explicit SBuyResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharaterFieldNumber = 2,
    kWeaponListFieldNumber = 6,
    kResultFieldNumber = 1,
    kCurCharaterTypeFieldNumber = 3,
    kCurWeaponTypeFieldNumber = 4,
    kCashFieldNumber = 5,
  };
  // repeated .protocol.Charater charater = 2;
  int charater_size() const;
  private:
  int _internal_charater_size() const;
  public:
  void clear_charater();
  ::protocol::Charater* mutable_charater(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Charater >*
      mutable_charater();
  private:
  const ::protocol::Charater& _internal_charater(int index) const;
  ::protocol::Charater* _internal_add_charater();
  public:
  const ::protocol::Charater& charater(int index) const;
  ::protocol::Charater* add_charater();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Charater >&
      charater() const;

  // repeated int32 weaponList = 6;
  int weaponlist_size() const;
  private:
  int _internal_weaponlist_size() const;
  public:
  void clear_weaponlist();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_weaponlist(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_weaponlist() const;
  void _internal_add_weaponlist(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_weaponlist();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 weaponlist(int index) const;
  void set_weaponlist(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_weaponlist(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      weaponlist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_weaponlist();

  // int32 result = 1;
  void clear_result();
  ::PROTOBUF_NAMESPACE_ID::int32 result() const;
  void set_result(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_result() const;
  void _internal_set_result(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 curCharaterType = 3;
  void clear_curcharatertype();
  ::PROTOBUF_NAMESPACE_ID::int32 curcharatertype() const;
  void set_curcharatertype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_curcharatertype() const;
  void _internal_set_curcharatertype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 curWeaponType = 4;
  void clear_curweapontype();
  ::PROTOBUF_NAMESPACE_ID::int32 curweapontype() const;
  void set_curweapontype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_curweapontype() const;
  void _internal_set_curweapontype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 cash = 5;
  void clear_cash();
  ::PROTOBUF_NAMESPACE_ID::int32 cash() const;
  void set_cash(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cash() const;
  void _internal_set_cash(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SBuyResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Charater > charater_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > weaponlist_;
  mutable std::atomic<int> _weaponlist_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 result_;
  ::PROTOBUF_NAMESPACE_ID::int32 curcharatertype_;
  ::PROTOBUF_NAMESPACE_ID::int32 curweapontype_;
  ::PROTOBUF_NAMESPACE_ID::int32 cash_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class CPlayerJump final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.CPlayerJump) */ {
 public:
  inline CPlayerJump() : CPlayerJump(nullptr) {}
  ~CPlayerJump() override;
  explicit constexpr CPlayerJump(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CPlayerJump(const CPlayerJump& from);
  CPlayerJump(CPlayerJump&& from) noexcept
    : CPlayerJump() {
    *this = ::std::move(from);
  }

  inline CPlayerJump& operator=(const CPlayerJump& from) {
    CopyFrom(from);
    return *this;
  }
  inline CPlayerJump& operator=(CPlayerJump&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CPlayerJump& default_instance() {
    return *internal_default_instance();
  }
  static inline const CPlayerJump* internal_default_instance() {
    return reinterpret_cast<const CPlayerJump*>(
               &_CPlayerJump_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(CPlayerJump& a, CPlayerJump& b) {
    a.Swap(&b);
  }
  inline void Swap(CPlayerJump* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CPlayerJump* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CPlayerJump* New() const final {
    return new CPlayerJump();
  }

  CPlayerJump* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CPlayerJump>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CPlayerJump& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CPlayerJump& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CPlayerJump* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.CPlayerJump";
  }
  protected:
  explicit CPlayerJump(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsJumpFieldNumber = 1,
    kUuidFieldNumber = 2,
  };
  // bool isJump = 1;
  void clear_isjump();
  bool isjump() const;
  void set_isjump(bool value);
  private:
  bool _internal_isjump() const;
  void _internal_set_isjump(bool value);
  public:

  // int32 uuid = 2;
  void clear_uuid();
  ::PROTOBUF_NAMESPACE_ID::int32 uuid() const;
  void set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_uuid() const;
  void _internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.CPlayerJump)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool isjump_;
  ::PROTOBUF_NAMESPACE_ID::int32 uuid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class CPlayerAim final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.CPlayerAim) */ {
 public:
  inline CPlayerAim() : CPlayerAim(nullptr) {}
  ~CPlayerAim() override;
  explicit constexpr CPlayerAim(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CPlayerAim(const CPlayerAim& from);
  CPlayerAim(CPlayerAim&& from) noexcept
    : CPlayerAim() {
    *this = ::std::move(from);
  }

  inline CPlayerAim& operator=(const CPlayerAim& from) {
    CopyFrom(from);
    return *this;
  }
  inline CPlayerAim& operator=(CPlayerAim&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CPlayerAim& default_instance() {
    return *internal_default_instance();
  }
  static inline const CPlayerAim* internal_default_instance() {
    return reinterpret_cast<const CPlayerAim*>(
               &_CPlayerAim_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(CPlayerAim& a, CPlayerAim& b) {
    a.Swap(&b);
  }
  inline void Swap(CPlayerAim* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CPlayerAim* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CPlayerAim* New() const final {
    return new CPlayerAim();
  }

  CPlayerAim* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CPlayerAim>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CPlayerAim& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CPlayerAim& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CPlayerAim* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.CPlayerAim";
  }
  protected:
  explicit CPlayerAim(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsAimFieldNumber = 1,
    kUuidFieldNumber = 2,
  };
  // bool isAim = 1;
  void clear_isaim();
  bool isaim() const;
  void set_isaim(bool value);
  private:
  bool _internal_isaim() const;
  void _internal_set_isaim(bool value);
  public:

  // int32 uuid = 2;
  void clear_uuid();
  ::PROTOBUF_NAMESPACE_ID::int32 uuid() const;
  void set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_uuid() const;
  void _internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.CPlayerAim)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool isaim_;
  ::PROTOBUF_NAMESPACE_ID::int32 uuid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class SExpLv final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SExpLv) */ {
 public:
  inline SExpLv() : SExpLv(nullptr) {}
  ~SExpLv() override;
  explicit constexpr SExpLv(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SExpLv(const SExpLv& from);
  SExpLv(SExpLv&& from) noexcept
    : SExpLv() {
    *this = ::std::move(from);
  }

  inline SExpLv& operator=(const SExpLv& from) {
    CopyFrom(from);
    return *this;
  }
  inline SExpLv& operator=(SExpLv&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SExpLv& default_instance() {
    return *internal_default_instance();
  }
  static inline const SExpLv* internal_default_instance() {
    return reinterpret_cast<const SExpLv*>(
               &_SExpLv_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(SExpLv& a, SExpLv& b) {
    a.Swap(&b);
  }
  inline void Swap(SExpLv* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SExpLv* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SExpLv* New() const final {
    return new SExpLv();
  }

  SExpLv* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SExpLv>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SExpLv& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SExpLv& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SExpLv* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SExpLv";
  }
  protected:
  explicit SExpLv(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kLvFieldNumber = 2,
    kExpFieldNumber = 3,
  };
  // int32 uuid = 1;
  void clear_uuid();
  ::PROTOBUF_NAMESPACE_ID::int32 uuid() const;
  void set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_uuid() const;
  void _internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 lv = 2;
  void clear_lv();
  ::PROTOBUF_NAMESPACE_ID::int32 lv() const;
  void set_lv(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_lv() const;
  void _internal_set_lv(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 exp = 3;
  void clear_exp();
  ::PROTOBUF_NAMESPACE_ID::int32 exp() const;
  void set_exp(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_exp() const;
  void _internal_set_exp(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SExpLv)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 uuid_;
  ::PROTOBUF_NAMESPACE_ID::int32 lv_;
  ::PROTOBUF_NAMESPACE_ID::int32 exp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class ItemEquip final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.ItemEquip) */ {
 public:
  inline ItemEquip() : ItemEquip(nullptr) {}
  ~ItemEquip() override;
  explicit constexpr ItemEquip(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemEquip(const ItemEquip& from);
  ItemEquip(ItemEquip&& from) noexcept
    : ItemEquip() {
    *this = ::std::move(from);
  }

  inline ItemEquip& operator=(const ItemEquip& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemEquip& operator=(ItemEquip&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemEquip& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemEquip* internal_default_instance() {
    return reinterpret_cast<const ItemEquip*>(
               &_ItemEquip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ItemEquip& a, ItemEquip& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemEquip* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemEquip* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ItemEquip* New() const final {
    return new ItemEquip();
  }

  ItemEquip* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ItemEquip>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemEquip& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ItemEquip& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemEquip* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.ItemEquip";
  }
  protected:
  explicit ItemEquip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemCodeFieldNumber = 1,
  };
  // int32 item_code = 1;
  void clear_item_code();
  ::PROTOBUF_NAMESPACE_ID::int32 item_code() const;
  void set_item_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_item_code() const;
  void _internal_set_item_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.ItemEquip)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 item_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class ItemEtc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.ItemEtc) */ {
 public:
  inline ItemEtc() : ItemEtc(nullptr) {}
  ~ItemEtc() override;
  explicit constexpr ItemEtc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemEtc(const ItemEtc& from);
  ItemEtc(ItemEtc&& from) noexcept
    : ItemEtc() {
    *this = ::std::move(from);
  }

  inline ItemEtc& operator=(const ItemEtc& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemEtc& operator=(ItemEtc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemEtc& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemEtc* internal_default_instance() {
    return reinterpret_cast<const ItemEtc*>(
               &_ItemEtc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ItemEtc& a, ItemEtc& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemEtc* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemEtc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ItemEtc* New() const final {
    return new ItemEtc();
  }

  ItemEtc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ItemEtc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemEtc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ItemEtc& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemEtc* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.ItemEtc";
  }
  protected:
  explicit ItemEtc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemCodeFieldNumber = 1,
    kItemCountFieldNumber = 2,
  };
  // int32 item_code = 1;
  void clear_item_code();
  ::PROTOBUF_NAMESPACE_ID::int32 item_code() const;
  void set_item_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_item_code() const;
  void _internal_set_item_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 item_count = 2;
  void clear_item_count();
  ::PROTOBUF_NAMESPACE_ID::int32 item_count() const;
  void set_item_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_item_count() const;
  void _internal_set_item_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.ItemEtc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 item_code_;
  ::PROTOBUF_NAMESPACE_ID::int32 item_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class DropMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.DropMessage) */ {
 public:
  inline DropMessage() : DropMessage(nullptr) {}
  ~DropMessage() override;
  explicit constexpr DropMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropMessage(const DropMessage& from);
  DropMessage(DropMessage&& from) noexcept
    : DropMessage() {
    *this = ::std::move(from);
  }

  inline DropMessage& operator=(const DropMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropMessage& operator=(DropMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropMessage* internal_default_instance() {
    return reinterpret_cast<const DropMessage*>(
               &_DropMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(DropMessage& a, DropMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DropMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DropMessage* New() const final {
    return new DropMessage();
  }

  DropMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DropMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DropMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.DropMessage";
  }
  protected:
  explicit DropMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemEquipsFieldNumber = 1,
    kItemEtcsFieldNumber = 2,
    kGoldFieldNumber = 3,
  };
  // repeated .protocol.ItemEquip itemEquips = 1;
  int itemequips_size() const;
  private:
  int _internal_itemequips_size() const;
  public:
  void clear_itemequips();
  ::protocol::ItemEquip* mutable_itemequips(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >*
      mutable_itemequips();
  private:
  const ::protocol::ItemEquip& _internal_itemequips(int index) const;
  ::protocol::ItemEquip* _internal_add_itemequips();
  public:
  const ::protocol::ItemEquip& itemequips(int index) const;
  ::protocol::ItemEquip* add_itemequips();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >&
      itemequips() const;

  // repeated .protocol.ItemEtc itemEtcs = 2;
  int itemetcs_size() const;
  private:
  int _internal_itemetcs_size() const;
  public:
  void clear_itemetcs();
  ::protocol::ItemEtc* mutable_itemetcs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEtc >*
      mutable_itemetcs();
  private:
  const ::protocol::ItemEtc& _internal_itemetcs(int index) const;
  ::protocol::ItemEtc* _internal_add_itemetcs();
  public:
  const ::protocol::ItemEtc& itemetcs(int index) const;
  ::protocol::ItemEtc* add_itemetcs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEtc >&
      itemetcs() const;

  // int32 gold = 3;
  void clear_gold();
  ::PROTOBUF_NAMESPACE_ID::int32 gold() const;
  void set_gold(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_gold() const;
  void _internal_set_gold(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.DropMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip > itemequips_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEtc > itemetcs_;
  ::PROTOBUF_NAMESPACE_ID::int32 gold_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class SLoadInventory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SLoadInventory) */ {
 public:
  inline SLoadInventory() : SLoadInventory(nullptr) {}
  ~SLoadInventory() override;
  explicit constexpr SLoadInventory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SLoadInventory(const SLoadInventory& from);
  SLoadInventory(SLoadInventory&& from) noexcept
    : SLoadInventory() {
    *this = ::std::move(from);
  }

  inline SLoadInventory& operator=(const SLoadInventory& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLoadInventory& operator=(SLoadInventory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SLoadInventory& default_instance() {
    return *internal_default_instance();
  }
  static inline const SLoadInventory* internal_default_instance() {
    return reinterpret_cast<const SLoadInventory*>(
               &_SLoadInventory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(SLoadInventory& a, SLoadInventory& b) {
    a.Swap(&b);
  }
  inline void Swap(SLoadInventory* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SLoadInventory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SLoadInventory* New() const final {
    return new SLoadInventory();
  }

  SLoadInventory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SLoadInventory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SLoadInventory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SLoadInventory& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLoadInventory* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SLoadInventory";
  }
  protected:
  explicit SLoadInventory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemEquipsFieldNumber = 1,
    kItemEtcsFieldNumber = 2,
    kGoldFieldNumber = 3,
  };
  // repeated .protocol.ItemEquip itemEquips = 1;
  int itemequips_size() const;
  private:
  int _internal_itemequips_size() const;
  public:
  void clear_itemequips();
  ::protocol::ItemEquip* mutable_itemequips(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >*
      mutable_itemequips();
  private:
  const ::protocol::ItemEquip& _internal_itemequips(int index) const;
  ::protocol::ItemEquip* _internal_add_itemequips();
  public:
  const ::protocol::ItemEquip& itemequips(int index) const;
  ::protocol::ItemEquip* add_itemequips();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >&
      itemequips() const;

  // repeated .protocol.ItemEtc itemEtcs = 2;
  int itemetcs_size() const;
  private:
  int _internal_itemetcs_size() const;
  public:
  void clear_itemetcs();
  ::protocol::ItemEtc* mutable_itemetcs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEtc >*
      mutable_itemetcs();
  private:
  const ::protocol::ItemEtc& _internal_itemetcs(int index) const;
  ::protocol::ItemEtc* _internal_add_itemetcs();
  public:
  const ::protocol::ItemEtc& itemetcs(int index) const;
  ::protocol::ItemEtc* add_itemetcs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEtc >&
      itemetcs() const;

  // int32 gold = 3;
  void clear_gold();
  ::PROTOBUF_NAMESPACE_ID::int32 gold() const;
  void set_gold(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_gold() const;
  void _internal_set_gold(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SLoadInventory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip > itemequips_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEtc > itemetcs_;
  ::PROTOBUF_NAMESPACE_ID::int32 gold_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class CSellItems final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.CSellItems) */ {
 public:
  inline CSellItems() : CSellItems(nullptr) {}
  ~CSellItems() override;
  explicit constexpr CSellItems(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSellItems(const CSellItems& from);
  CSellItems(CSellItems&& from) noexcept
    : CSellItems() {
    *this = ::std::move(from);
  }

  inline CSellItems& operator=(const CSellItems& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSellItems& operator=(CSellItems&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSellItems& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSellItems* internal_default_instance() {
    return reinterpret_cast<const CSellItems*>(
               &_CSellItems_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(CSellItems& a, CSellItems& b) {
    a.Swap(&b);
  }
  inline void Swap(CSellItems* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSellItems* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CSellItems* New() const final {
    return new CSellItems();
  }

  CSellItems* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CSellItems>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSellItems& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSellItems& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSellItems* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.CSellItems";
  }
  protected:
  explicit CSellItems(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemEquipsFieldNumber = 1,
    kItemEtcsFieldNumber = 2,
    kGoldFieldNumber = 3,
  };
  // repeated .protocol.ItemEquip itemEquips = 1;
  int itemequips_size() const;
  private:
  int _internal_itemequips_size() const;
  public:
  void clear_itemequips();
  ::protocol::ItemEquip* mutable_itemequips(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >*
      mutable_itemequips();
  private:
  const ::protocol::ItemEquip& _internal_itemequips(int index) const;
  ::protocol::ItemEquip* _internal_add_itemequips();
  public:
  const ::protocol::ItemEquip& itemequips(int index) const;
  ::protocol::ItemEquip* add_itemequips();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >&
      itemequips() const;

  // repeated .protocol.ItemEtc itemEtcs = 2;
  int itemetcs_size() const;
  private:
  int _internal_itemetcs_size() const;
  public:
  void clear_itemetcs();
  ::protocol::ItemEtc* mutable_itemetcs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEtc >*
      mutable_itemetcs();
  private:
  const ::protocol::ItemEtc& _internal_itemetcs(int index) const;
  ::protocol::ItemEtc* _internal_add_itemetcs();
  public:
  const ::protocol::ItemEtc& itemetcs(int index) const;
  ::protocol::ItemEtc* add_itemetcs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEtc >&
      itemetcs() const;

  // int32 gold = 3;
  void clear_gold();
  ::PROTOBUF_NAMESPACE_ID::int32 gold() const;
  void set_gold(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_gold() const;
  void _internal_set_gold(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.CSellItems)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip > itemequips_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEtc > itemetcs_;
  ::PROTOBUF_NAMESPACE_ID::int32 gold_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Login

// string id = 1;
inline void Login::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Login::id() const {
  // @@protoc_insertion_point(field_get:protocol.Login.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Login::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Login.id)
}
inline std::string* Login::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:protocol.Login.id)
  return _s;
}
inline const std::string& Login::_internal_id() const {
  return id_.Get();
}
inline void Login::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Login::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Login::release_id() {
  // @@protoc_insertion_point(field_release:protocol.Login.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Login::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.Login.id)
}

// string pwd = 2;
inline void Login::clear_pwd() {
  pwd_.ClearToEmpty();
}
inline const std::string& Login::pwd() const {
  // @@protoc_insertion_point(field_get:protocol.Login.pwd)
  return _internal_pwd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Login::set_pwd(ArgT0&& arg0, ArgT... args) {
 
 pwd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Login.pwd)
}
inline std::string* Login::mutable_pwd() {
  std::string* _s = _internal_mutable_pwd();
  // @@protoc_insertion_point(field_mutable:protocol.Login.pwd)
  return _s;
}
inline const std::string& Login::_internal_pwd() const {
  return pwd_.Get();
}
inline void Login::_internal_set_pwd(const std::string& value) {
  
  pwd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Login::_internal_mutable_pwd() {
  
  return pwd_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Login::release_pwd() {
  // @@protoc_insertion_point(field_release:protocol.Login.pwd)
  return pwd_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Login::set_allocated_pwd(std::string* pwd) {
  if (pwd != nullptr) {
    
  } else {
    
  }
  pwd_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pwd,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.Login.pwd)
}

// -------------------------------------------------------------------

// CreateAccount

// bool success = 1;
inline void CreateAccount::clear_success() {
  success_ = false;
}
inline bool CreateAccount::_internal_success() const {
  return success_;
}
inline bool CreateAccount::success() const {
  // @@protoc_insertion_point(field_get:protocol.CreateAccount.success)
  return _internal_success();
}
inline void CreateAccount::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void CreateAccount::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:protocol.CreateAccount.success)
}

// -------------------------------------------------------------------

// CreateCharacter

// .protocol.Charater charater = 1;
inline bool CreateCharacter::_internal_has_charater() const {
  return this != internal_default_instance() && charater_ != nullptr;
}
inline bool CreateCharacter::has_charater() const {
  return _internal_has_charater();
}
inline void CreateCharacter::clear_charater() {
  if (GetArenaForAllocation() == nullptr && charater_ != nullptr) {
    delete charater_;
  }
  charater_ = nullptr;
}
inline const ::protocol::Charater& CreateCharacter::_internal_charater() const {
  const ::protocol::Charater* p = charater_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Charater&>(
      ::protocol::_Charater_default_instance_);
}
inline const ::protocol::Charater& CreateCharacter::charater() const {
  // @@protoc_insertion_point(field_get:protocol.CreateCharacter.charater)
  return _internal_charater();
}
inline void CreateCharacter::unsafe_arena_set_allocated_charater(
    ::protocol::Charater* charater) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(charater_);
  }
  charater_ = charater;
  if (charater) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.CreateCharacter.charater)
}
inline ::protocol::Charater* CreateCharacter::release_charater() {
  
  ::protocol::Charater* temp = charater_;
  charater_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Charater* CreateCharacter::unsafe_arena_release_charater() {
  // @@protoc_insertion_point(field_release:protocol.CreateCharacter.charater)
  
  ::protocol::Charater* temp = charater_;
  charater_ = nullptr;
  return temp;
}
inline ::protocol::Charater* CreateCharacter::_internal_mutable_charater() {
  
  if (charater_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Charater>(GetArenaForAllocation());
    charater_ = p;
  }
  return charater_;
}
inline ::protocol::Charater* CreateCharacter::mutable_charater() {
  ::protocol::Charater* _msg = _internal_mutable_charater();
  // @@protoc_insertion_point(field_mutable:protocol.CreateCharacter.charater)
  return _msg;
}
inline void CreateCharacter::set_allocated_charater(::protocol::Charater* charater) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete charater_;
  }
  if (charater) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Charater>::GetOwningArena(charater);
    if (message_arena != submessage_arena) {
      charater = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, charater, submessage_arena);
    }
    
  } else {
    
  }
  charater_ = charater;
  // @@protoc_insertion_point(field_set_allocated:protocol.CreateCharacter.charater)
}

// -------------------------------------------------------------------

// CUpdateAccount

// int32 charaterType = 1;
inline void CUpdateAccount::clear_charatertype() {
  charatertype_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CUpdateAccount::_internal_charatertype() const {
  return charatertype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CUpdateAccount::charatertype() const {
  // @@protoc_insertion_point(field_get:protocol.CUpdateAccount.charaterType)
  return _internal_charatertype();
}
inline void CUpdateAccount::_internal_set_charatertype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  charatertype_ = value;
}
inline void CUpdateAccount::set_charatertype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_charatertype(value);
  // @@protoc_insertion_point(field_set:protocol.CUpdateAccount.charaterType)
}

// int32 weaponType = 2;
inline void CUpdateAccount::clear_weapontype() {
  weapontype_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CUpdateAccount::_internal_weapontype() const {
  return weapontype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CUpdateAccount::weapontype() const {
  // @@protoc_insertion_point(field_get:protocol.CUpdateAccount.weaponType)
  return _internal_weapontype();
}
inline void CUpdateAccount::_internal_set_weapontype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  weapontype_ = value;
}
inline void CUpdateAccount::set_weapontype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_weapontype(value);
  // @@protoc_insertion_point(field_set:protocol.CUpdateAccount.weaponType)
}

// int32 useCash = 3;
inline void CUpdateAccount::clear_usecash() {
  usecash_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CUpdateAccount::_internal_usecash() const {
  return usecash_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CUpdateAccount::usecash() const {
  // @@protoc_insertion_point(field_get:protocol.CUpdateAccount.useCash)
  return _internal_usecash();
}
inline void CUpdateAccount::_internal_set_usecash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  usecash_ = value;
}
inline void CUpdateAccount::set_usecash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_usecash(value);
  // @@protoc_insertion_point(field_set:protocol.CUpdateAccount.useCash)
}

// -------------------------------------------------------------------

// SCurrentInfo

// int32 cash = 1;
inline void SCurrentInfo::clear_cash() {
  cash_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SCurrentInfo::_internal_cash() const {
  return cash_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SCurrentInfo::cash() const {
  // @@protoc_insertion_point(field_get:protocol.SCurrentInfo.cash)
  return _internal_cash();
}
inline void SCurrentInfo::_internal_set_cash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  cash_ = value;
}
inline void SCurrentInfo::set_cash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cash(value);
  // @@protoc_insertion_point(field_set:protocol.SCurrentInfo.cash)
}

// int32 charaterType = 2;
inline void SCurrentInfo::clear_charatertype() {
  charatertype_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SCurrentInfo::_internal_charatertype() const {
  return charatertype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SCurrentInfo::charatertype() const {
  // @@protoc_insertion_point(field_get:protocol.SCurrentInfo.charaterType)
  return _internal_charatertype();
}
inline void SCurrentInfo::_internal_set_charatertype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  charatertype_ = value;
}
inline void SCurrentInfo::set_charatertype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_charatertype(value);
  // @@protoc_insertion_point(field_set:protocol.SCurrentInfo.charaterType)
}

// int32 weaponType = 3;
inline void SCurrentInfo::clear_weapontype() {
  weapontype_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SCurrentInfo::_internal_weapontype() const {
  return weapontype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SCurrentInfo::weapontype() const {
  // @@protoc_insertion_point(field_get:protocol.SCurrentInfo.weaponType)
  return _internal_weapontype();
}
inline void SCurrentInfo::_internal_set_weapontype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  weapontype_ = value;
}
inline void SCurrentInfo::set_weapontype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_weapontype(value);
  // @@protoc_insertion_point(field_set:protocol.SCurrentInfo.weaponType)
}

// .protocol.Charater charater = 4;
inline bool SCurrentInfo::_internal_has_charater() const {
  return this != internal_default_instance() && charater_ != nullptr;
}
inline bool SCurrentInfo::has_charater() const {
  return _internal_has_charater();
}
inline void SCurrentInfo::clear_charater() {
  if (GetArenaForAllocation() == nullptr && charater_ != nullptr) {
    delete charater_;
  }
  charater_ = nullptr;
}
inline const ::protocol::Charater& SCurrentInfo::_internal_charater() const {
  const ::protocol::Charater* p = charater_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Charater&>(
      ::protocol::_Charater_default_instance_);
}
inline const ::protocol::Charater& SCurrentInfo::charater() const {
  // @@protoc_insertion_point(field_get:protocol.SCurrentInfo.charater)
  return _internal_charater();
}
inline void SCurrentInfo::unsafe_arena_set_allocated_charater(
    ::protocol::Charater* charater) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(charater_);
  }
  charater_ = charater;
  if (charater) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.SCurrentInfo.charater)
}
inline ::protocol::Charater* SCurrentInfo::release_charater() {
  
  ::protocol::Charater* temp = charater_;
  charater_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Charater* SCurrentInfo::unsafe_arena_release_charater() {
  // @@protoc_insertion_point(field_release:protocol.SCurrentInfo.charater)
  
  ::protocol::Charater* temp = charater_;
  charater_ = nullptr;
  return temp;
}
inline ::protocol::Charater* SCurrentInfo::_internal_mutable_charater() {
  
  if (charater_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Charater>(GetArenaForAllocation());
    charater_ = p;
  }
  return charater_;
}
inline ::protocol::Charater* SCurrentInfo::mutable_charater() {
  ::protocol::Charater* _msg = _internal_mutable_charater();
  // @@protoc_insertion_point(field_mutable:protocol.SCurrentInfo.charater)
  return _msg;
}
inline void SCurrentInfo::set_allocated_charater(::protocol::Charater* charater) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete charater_;
  }
  if (charater) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Charater>::GetOwningArena(charater);
    if (message_arena != submessage_arena) {
      charater = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, charater, submessage_arena);
    }
    
  } else {
    
  }
  charater_ = charater;
  // @@protoc_insertion_point(field_set_allocated:protocol.SCurrentInfo.charater)
}

// int32 exp = 5;
inline void SCurrentInfo::clear_exp() {
  exp_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SCurrentInfo::_internal_exp() const {
  return exp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SCurrentInfo::exp() const {
  // @@protoc_insertion_point(field_get:protocol.SCurrentInfo.exp)
  return _internal_exp();
}
inline void SCurrentInfo::_internal_set_exp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  exp_ = value;
}
inline void SCurrentInfo::set_exp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:protocol.SCurrentInfo.exp)
}

// -------------------------------------------------------------------

// LoginAccess

// bool success = 1;
inline void LoginAccess::clear_success() {
  success_ = false;
}
inline bool LoginAccess::_internal_success() const {
  return success_;
}
inline bool LoginAccess::success() const {
  // @@protoc_insertion_point(field_get:protocol.LoginAccess.success)
  return _internal_success();
}
inline void LoginAccess::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void LoginAccess::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:protocol.LoginAccess.success)
}

// repeated .protocol.Charater charater = 2;
inline int LoginAccess::_internal_charater_size() const {
  return charater_.size();
}
inline int LoginAccess::charater_size() const {
  return _internal_charater_size();
}
inline void LoginAccess::clear_charater() {
  charater_.Clear();
}
inline ::protocol::Charater* LoginAccess::mutable_charater(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.LoginAccess.charater)
  return charater_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Charater >*
LoginAccess::mutable_charater() {
  // @@protoc_insertion_point(field_mutable_list:protocol.LoginAccess.charater)
  return &charater_;
}
inline const ::protocol::Charater& LoginAccess::_internal_charater(int index) const {
  return charater_.Get(index);
}
inline const ::protocol::Charater& LoginAccess::charater(int index) const {
  // @@protoc_insertion_point(field_get:protocol.LoginAccess.charater)
  return _internal_charater(index);
}
inline ::protocol::Charater* LoginAccess::_internal_add_charater() {
  return charater_.Add();
}
inline ::protocol::Charater* LoginAccess::add_charater() {
  ::protocol::Charater* _add = _internal_add_charater();
  // @@protoc_insertion_point(field_add:protocol.LoginAccess.charater)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Charater >&
LoginAccess::charater() const {
  // @@protoc_insertion_point(field_list:protocol.LoginAccess.charater)
  return charater_;
}

// int32 curCharaterType = 3;
inline void LoginAccess::clear_curcharatertype() {
  curcharatertype_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginAccess::_internal_curcharatertype() const {
  return curcharatertype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginAccess::curcharatertype() const {
  // @@protoc_insertion_point(field_get:protocol.LoginAccess.curCharaterType)
  return _internal_curcharatertype();
}
inline void LoginAccess::_internal_set_curcharatertype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  curcharatertype_ = value;
}
inline void LoginAccess::set_curcharatertype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_curcharatertype(value);
  // @@protoc_insertion_point(field_set:protocol.LoginAccess.curCharaterType)
}

// int32 curWeaponType = 4;
inline void LoginAccess::clear_curweapontype() {
  curweapontype_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginAccess::_internal_curweapontype() const {
  return curweapontype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginAccess::curweapontype() const {
  // @@protoc_insertion_point(field_get:protocol.LoginAccess.curWeaponType)
  return _internal_curweapontype();
}
inline void LoginAccess::_internal_set_curweapontype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  curweapontype_ = value;
}
inline void LoginAccess::set_curweapontype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_curweapontype(value);
  // @@protoc_insertion_point(field_set:protocol.LoginAccess.curWeaponType)
}

// int32 cash = 5;
inline void LoginAccess::clear_cash() {
  cash_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginAccess::_internal_cash() const {
  return cash_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginAccess::cash() const {
  // @@protoc_insertion_point(field_get:protocol.LoginAccess.cash)
  return _internal_cash();
}
inline void LoginAccess::_internal_set_cash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  cash_ = value;
}
inline void LoginAccess::set_cash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cash(value);
  // @@protoc_insertion_point(field_set:protocol.LoginAccess.cash)
}

// repeated int32 weaponList = 6;
inline int LoginAccess::_internal_weaponlist_size() const {
  return weaponlist_.size();
}
inline int LoginAccess::weaponlist_size() const {
  return _internal_weaponlist_size();
}
inline void LoginAccess::clear_weaponlist() {
  weaponlist_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginAccess::_internal_weaponlist(int index) const {
  return weaponlist_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginAccess::weaponlist(int index) const {
  // @@protoc_insertion_point(field_get:protocol.LoginAccess.weaponList)
  return _internal_weaponlist(index);
}
inline void LoginAccess::set_weaponlist(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  weaponlist_.Set(index, value);
  // @@protoc_insertion_point(field_set:protocol.LoginAccess.weaponList)
}
inline void LoginAccess::_internal_add_weaponlist(::PROTOBUF_NAMESPACE_ID::int32 value) {
  weaponlist_.Add(value);
}
inline void LoginAccess::add_weaponlist(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_weaponlist(value);
  // @@protoc_insertion_point(field_add:protocol.LoginAccess.weaponList)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
LoginAccess::_internal_weaponlist() const {
  return weaponlist_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
LoginAccess::weaponlist() const {
  // @@protoc_insertion_point(field_list:protocol.LoginAccess.weaponList)
  return _internal_weaponlist();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
LoginAccess::_internal_mutable_weaponlist() {
  return &weaponlist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
LoginAccess::mutable_weaponlist() {
  // @@protoc_insertion_point(field_mutable_list:protocol.LoginAccess.weaponList)
  return _internal_mutable_weaponlist();
}

// -------------------------------------------------------------------

// Charater

// int32 uuid = 1;
inline void Charater::clear_uuid() {
  uuid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Charater::_internal_uuid() const {
  return uuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Charater::uuid() const {
  // @@protoc_insertion_point(field_get:protocol.Charater.uuid)
  return _internal_uuid();
}
inline void Charater::_internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  uuid_ = value;
}
inline void Charater::set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:protocol.Charater.uuid)
}

// int32 code = 2;
inline void Charater::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Charater::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Charater::code() const {
  // @@protoc_insertion_point(field_get:protocol.Charater.code)
  return _internal_code();
}
inline void Charater::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void Charater::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:protocol.Charater.code)
}

// string name = 3;
inline void Charater::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Charater::name() const {
  // @@protoc_insertion_point(field_get:protocol.Charater.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Charater::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Charater.name)
}
inline std::string* Charater::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:protocol.Charater.name)
  return _s;
}
inline const std::string& Charater::_internal_name() const {
  return name_.Get();
}
inline void Charater::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Charater::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Charater::release_name() {
  // @@protoc_insertion_point(field_release:protocol.Charater.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Charater::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.Charater.name)
}

// int32 lv = 4;
inline void Charater::clear_lv() {
  lv_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Charater::_internal_lv() const {
  return lv_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Charater::lv() const {
  // @@protoc_insertion_point(field_get:protocol.Charater.lv)
  return _internal_lv();
}
inline void Charater::_internal_set_lv(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  lv_ = value;
}
inline void Charater::set_lv(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_lv(value);
  // @@protoc_insertion_point(field_set:protocol.Charater.lv)
}

// -------------------------------------------------------------------

// Position

// float x = 1;
inline void Position::clear_x() {
  x_ = 0;
}
inline float Position::_internal_x() const {
  return x_;
}
inline float Position::x() const {
  // @@protoc_insertion_point(field_get:protocol.Position.x)
  return _internal_x();
}
inline void Position::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Position::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:protocol.Position.x)
}

// float y = 2;
inline void Position::clear_y() {
  y_ = 0;
}
inline float Position::_internal_y() const {
  return y_;
}
inline float Position::y() const {
  // @@protoc_insertion_point(field_get:protocol.Position.y)
  return _internal_y();
}
inline void Position::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Position::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:protocol.Position.y)
}

// float z = 3;
inline void Position::clear_z() {
  z_ = 0;
}
inline float Position::_internal_z() const {
  return z_;
}
inline float Position::z() const {
  // @@protoc_insertion_point(field_get:protocol.Position.z)
  return _internal_z();
}
inline void Position::_internal_set_z(float value) {
  
  z_ = value;
}
inline void Position::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:protocol.Position.z)
}

// float yaw = 4;
inline void Position::clear_yaw() {
  yaw_ = 0;
}
inline float Position::_internal_yaw() const {
  return yaw_;
}
inline float Position::yaw() const {
  // @@protoc_insertion_point(field_get:protocol.Position.yaw)
  return _internal_yaw();
}
inline void Position::_internal_set_yaw(float value) {
  
  yaw_ = value;
}
inline void Position::set_yaw(float value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:protocol.Position.yaw)
}

// -------------------------------------------------------------------

// Unit

// uint32 uuid = 1;
inline void Unit::clear_uuid() {
  uuid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Unit::_internal_uuid() const {
  return uuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Unit::uuid() const {
  // @@protoc_insertion_point(field_get:protocol.Unit.uuid)
  return _internal_uuid();
}
inline void Unit::_internal_set_uuid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  uuid_ = value;
}
inline void Unit::set_uuid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:protocol.Unit.uuid)
}

// uint32 hp = 2;
inline void Unit::clear_hp() {
  hp_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Unit::_internal_hp() const {
  return hp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Unit::hp() const {
  // @@protoc_insertion_point(field_get:protocol.Unit.hp)
  return _internal_hp();
}
inline void Unit::_internal_set_hp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  hp_ = value;
}
inline void Unit::set_hp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:protocol.Unit.hp)
}

// int32 code = 3;
inline void Unit::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Unit::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Unit::code() const {
  // @@protoc_insertion_point(field_get:protocol.Unit.code)
  return _internal_code();
}
inline void Unit::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void Unit::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:protocol.Unit.code)
}

// .protocol.Position position = 4;
inline bool Unit::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool Unit::has_position() const {
  return _internal_has_position();
}
inline void Unit::clear_position() {
  if (GetArenaForAllocation() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::protocol::Position& Unit::_internal_position() const {
  const ::protocol::Position* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Position&>(
      ::protocol::_Position_default_instance_);
}
inline const ::protocol::Position& Unit::position() const {
  // @@protoc_insertion_point(field_get:protocol.Unit.position)
  return _internal_position();
}
inline void Unit::unsafe_arena_set_allocated_position(
    ::protocol::Position* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.Unit.position)
}
inline ::protocol::Position* Unit::release_position() {
  
  ::protocol::Position* temp = position_;
  position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Position* Unit::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:protocol.Unit.position)
  
  ::protocol::Position* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::protocol::Position* Unit::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Position>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::protocol::Position* Unit::mutable_position() {
  ::protocol::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:protocol.Unit.position)
  return _msg;
}
inline void Unit::set_allocated_position(::protocol::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Position>::GetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:protocol.Unit.position)
}

// string name = 5;
inline void Unit::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Unit::name() const {
  // @@protoc_insertion_point(field_get:protocol.Unit.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Unit::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Unit.name)
}
inline std::string* Unit::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:protocol.Unit.name)
  return _s;
}
inline const std::string& Unit::_internal_name() const {
  return name_.Get();
}
inline void Unit::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Unit::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Unit::release_name() {
  // @@protoc_insertion_point(field_release:protocol.Unit.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Unit::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.Unit.name)
}

// int32 lv = 6;
inline void Unit::clear_lv() {
  lv_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Unit::_internal_lv() const {
  return lv_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Unit::lv() const {
  // @@protoc_insertion_point(field_get:protocol.Unit.lv)
  return _internal_lv();
}
inline void Unit::_internal_set_lv(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  lv_ = value;
}
inline void Unit::set_lv(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_lv(value);
  // @@protoc_insertion_point(field_set:protocol.Unit.lv)
}

// int32 state = 7;
inline void Unit::clear_state() {
  state_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Unit::_internal_state() const {
  return state_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Unit::state() const {
  // @@protoc_insertion_point(field_get:protocol.Unit.state)
  return _internal_state();
}
inline void Unit::_internal_set_state(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  state_ = value;
}
inline void Unit::set_state(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:protocol.Unit.state)
}

// int32 weaponCode = 8;
inline void Unit::clear_weaponcode() {
  weaponcode_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Unit::_internal_weaponcode() const {
  return weaponcode_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Unit::weaponcode() const {
  // @@protoc_insertion_point(field_get:protocol.Unit.weaponCode)
  return _internal_weaponcode();
}
inline void Unit::_internal_set_weaponcode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  weaponcode_ = value;
}
inline void Unit::set_weaponcode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_weaponcode(value);
  // @@protoc_insertion_point(field_set:protocol.Unit.weaponCode)
}

// -------------------------------------------------------------------

// SLoad

// repeated .protocol.UnitState unit = 1;
inline int SLoad::_internal_unit_size() const {
  return unit_.size();
}
inline int SLoad::unit_size() const {
  return _internal_unit_size();
}
inline void SLoad::clear_unit() {
  unit_.Clear();
}
inline ::protocol::UnitState* SLoad::mutable_unit(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.SLoad.unit)
  return unit_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::UnitState >*
SLoad::mutable_unit() {
  // @@protoc_insertion_point(field_mutable_list:protocol.SLoad.unit)
  return &unit_;
}
inline const ::protocol::UnitState& SLoad::_internal_unit(int index) const {
  return unit_.Get(index);
}
inline const ::protocol::UnitState& SLoad::unit(int index) const {
  // @@protoc_insertion_point(field_get:protocol.SLoad.unit)
  return _internal_unit(index);
}
inline ::protocol::UnitState* SLoad::_internal_add_unit() {
  return unit_.Add();
}
inline ::protocol::UnitState* SLoad::add_unit() {
  ::protocol::UnitState* _add = _internal_add_unit();
  // @@protoc_insertion_point(field_add:protocol.SLoad.unit)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::UnitState >&
SLoad::unit() const {
  // @@protoc_insertion_point(field_list:protocol.SLoad.unit)
  return unit_;
}

// int32 room_id = 3;
inline void SLoad::clear_room_id() {
  room_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SLoad::_internal_room_id() const {
  return room_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SLoad::room_id() const {
  // @@protoc_insertion_point(field_get:protocol.SLoad.room_id)
  return _internal_room_id();
}
inline void SLoad::_internal_set_room_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  room_id_ = value;
}
inline void SLoad::set_room_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_room_id(value);
  // @@protoc_insertion_point(field_set:protocol.SLoad.room_id)
}

// -------------------------------------------------------------------

// CLoad

// int32 code = 1;
inline void CLoad::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CLoad::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CLoad::code() const {
  // @@protoc_insertion_point(field_get:protocol.CLoad.code)
  return _internal_code();
}
inline void CLoad::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void CLoad::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:protocol.CLoad.code)
}

// .protocol.Position position = 100;
inline bool CLoad::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool CLoad::has_position() const {
  return _internal_has_position();
}
inline void CLoad::clear_position() {
  if (GetArenaForAllocation() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::protocol::Position& CLoad::_internal_position() const {
  const ::protocol::Position* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Position&>(
      ::protocol::_Position_default_instance_);
}
inline const ::protocol::Position& CLoad::position() const {
  // @@protoc_insertion_point(field_get:protocol.CLoad.position)
  return _internal_position();
}
inline void CLoad::unsafe_arena_set_allocated_position(
    ::protocol::Position* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.CLoad.position)
}
inline ::protocol::Position* CLoad::release_position() {
  
  ::protocol::Position* temp = position_;
  position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Position* CLoad::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:protocol.CLoad.position)
  
  ::protocol::Position* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::protocol::Position* CLoad::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Position>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::protocol::Position* CLoad::mutable_position() {
  ::protocol::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:protocol.CLoad.position)
  return _msg;
}
inline void CLoad::set_allocated_position(::protocol::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Position>::GetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:protocol.CLoad.position)
}

// bool is_dummy = 101;
inline void CLoad::clear_is_dummy() {
  is_dummy_ = false;
}
inline bool CLoad::_internal_is_dummy() const {
  return is_dummy_;
}
inline bool CLoad::is_dummy() const {
  // @@protoc_insertion_point(field_get:protocol.CLoad.is_dummy)
  return _internal_is_dummy();
}
inline void CLoad::_internal_set_is_dummy(bool value) {
  
  is_dummy_ = value;
}
inline void CLoad::set_is_dummy(bool value) {
  _internal_set_is_dummy(value);
  // @@protoc_insertion_point(field_set:protocol.CLoad.is_dummy)
}

// -------------------------------------------------------------------

// SInsertplayer

// .protocol.Unit player = 1;
inline bool SInsertplayer::_internal_has_player() const {
  return this != internal_default_instance() && player_ != nullptr;
}
inline bool SInsertplayer::has_player() const {
  return _internal_has_player();
}
inline void SInsertplayer::clear_player() {
  if (GetArenaForAllocation() == nullptr && player_ != nullptr) {
    delete player_;
  }
  player_ = nullptr;
}
inline const ::protocol::Unit& SInsertplayer::_internal_player() const {
  const ::protocol::Unit* p = player_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Unit&>(
      ::protocol::_Unit_default_instance_);
}
inline const ::protocol::Unit& SInsertplayer::player() const {
  // @@protoc_insertion_point(field_get:protocol.SInsertplayer.player)
  return _internal_player();
}
inline void SInsertplayer::unsafe_arena_set_allocated_player(
    ::protocol::Unit* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_);
  }
  player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.SInsertplayer.player)
}
inline ::protocol::Unit* SInsertplayer::release_player() {
  
  ::protocol::Unit* temp = player_;
  player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Unit* SInsertplayer::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:protocol.SInsertplayer.player)
  
  ::protocol::Unit* temp = player_;
  player_ = nullptr;
  return temp;
}
inline ::protocol::Unit* SInsertplayer::_internal_mutable_player() {
  
  if (player_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Unit>(GetArenaForAllocation());
    player_ = p;
  }
  return player_;
}
inline ::protocol::Unit* SInsertplayer::mutable_player() {
  ::protocol::Unit* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:protocol.SInsertplayer.player)
  return _msg;
}
inline void SInsertplayer::set_allocated_player(::protocol::Unit* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Unit>::GetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:protocol.SInsertplayer.player)
}

// -------------------------------------------------------------------

// SMove

// int32 uuid = 1;
inline void SMove::clear_uuid() {
  uuid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SMove::_internal_uuid() const {
  return uuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SMove::uuid() const {
  // @@protoc_insertion_point(field_get:protocol.SMove.uuid)
  return _internal_uuid();
}
inline void SMove::_internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  uuid_ = value;
}
inline void SMove::set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:protocol.SMove.uuid)
}

// .protocol.Position position = 2;
inline bool SMove::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool SMove::has_position() const {
  return _internal_has_position();
}
inline void SMove::clear_position() {
  if (GetArenaForAllocation() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::protocol::Position& SMove::_internal_position() const {
  const ::protocol::Position* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Position&>(
      ::protocol::_Position_default_instance_);
}
inline const ::protocol::Position& SMove::position() const {
  // @@protoc_insertion_point(field_get:protocol.SMove.position)
  return _internal_position();
}
inline void SMove::unsafe_arena_set_allocated_position(
    ::protocol::Position* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.SMove.position)
}
inline ::protocol::Position* SMove::release_position() {
  
  ::protocol::Position* temp = position_;
  position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Position* SMove::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:protocol.SMove.position)
  
  ::protocol::Position* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::protocol::Position* SMove::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Position>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::protocol::Position* SMove::mutable_position() {
  ::protocol::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:protocol.SMove.position)
  return _msg;
}
inline void SMove::set_allocated_position(::protocol::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Position>::GetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:protocol.SMove.position)
}

// bool is_monster = 3;
inline void SMove::clear_is_monster() {
  is_monster_ = false;
}
inline bool SMove::_internal_is_monster() const {
  return is_monster_;
}
inline bool SMove::is_monster() const {
  // @@protoc_insertion_point(field_get:protocol.SMove.is_monster)
  return _internal_is_monster();
}
inline void SMove::_internal_set_is_monster(bool value) {
  
  is_monster_ = value;
}
inline void SMove::set_is_monster(bool value) {
  _internal_set_is_monster(value);
  // @@protoc_insertion_point(field_set:protocol.SMove.is_monster)
}

// -------------------------------------------------------------------

// SChat

// uint32 type = 1;
inline void SChat::clear_type() {
  type_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SChat::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SChat::type() const {
  // @@protoc_insertion_point(field_get:protocol.SChat.type)
  return _internal_type();
}
inline void SChat::_internal_set_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  type_ = value;
}
inline void SChat::set_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:protocol.SChat.type)
}

// int32 uuid = 2;
inline void SChat::clear_uuid() {
  uuid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SChat::_internal_uuid() const {
  return uuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SChat::uuid() const {
  // @@protoc_insertion_point(field_get:protocol.SChat.uuid)
  return _internal_uuid();
}
inline void SChat::_internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  uuid_ = value;
}
inline void SChat::set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:protocol.SChat.uuid)
}

// string text = 5;
inline void SChat::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& SChat::text() const {
  // @@protoc_insertion_point(field_get:protocol.SChat.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SChat::set_text(ArgT0&& arg0, ArgT... args) {
 
 text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.SChat.text)
}
inline std::string* SChat::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:protocol.SChat.text)
  return _s;
}
inline const std::string& SChat::_internal_text() const {
  return text_.Get();
}
inline void SChat::_internal_set_text(const std::string& value) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SChat::_internal_mutable_text() {
  
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SChat::release_text() {
  // @@protoc_insertion_point(field_release:protocol.SChat.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SChat::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.SChat.text)
}

// -------------------------------------------------------------------

// SPlayerData

// .protocol.Unit player = 1;
inline bool SPlayerData::_internal_has_player() const {
  return this != internal_default_instance() && player_ != nullptr;
}
inline bool SPlayerData::has_player() const {
  return _internal_has_player();
}
inline void SPlayerData::clear_player() {
  if (GetArenaForAllocation() == nullptr && player_ != nullptr) {
    delete player_;
  }
  player_ = nullptr;
}
inline const ::protocol::Unit& SPlayerData::_internal_player() const {
  const ::protocol::Unit* p = player_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Unit&>(
      ::protocol::_Unit_default_instance_);
}
inline const ::protocol::Unit& SPlayerData::player() const {
  // @@protoc_insertion_point(field_get:protocol.SPlayerData.player)
  return _internal_player();
}
inline void SPlayerData::unsafe_arena_set_allocated_player(
    ::protocol::Unit* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_);
  }
  player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.SPlayerData.player)
}
inline ::protocol::Unit* SPlayerData::release_player() {
  
  ::protocol::Unit* temp = player_;
  player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Unit* SPlayerData::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:protocol.SPlayerData.player)
  
  ::protocol::Unit* temp = player_;
  player_ = nullptr;
  return temp;
}
inline ::protocol::Unit* SPlayerData::_internal_mutable_player() {
  
  if (player_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Unit>(GetArenaForAllocation());
    player_ = p;
  }
  return player_;
}
inline ::protocol::Unit* SPlayerData::mutable_player() {
  ::protocol::Unit* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:protocol.SPlayerData.player)
  return _msg;
}
inline void SPlayerData::set_allocated_player(::protocol::Unit* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Unit>::GetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:protocol.SPlayerData.player)
}

// int32 exp = 2;
inline void SPlayerData::clear_exp() {
  exp_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SPlayerData::_internal_exp() const {
  return exp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SPlayerData::exp() const {
  // @@protoc_insertion_point(field_get:protocol.SPlayerData.exp)
  return _internal_exp();
}
inline void SPlayerData::_internal_set_exp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  exp_ = value;
}
inline void SPlayerData::set_exp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:protocol.SPlayerData.exp)
}

// -------------------------------------------------------------------

// SClosePlayer

// int32 uuid = 1;
inline void SClosePlayer::clear_uuid() {
  uuid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SClosePlayer::_internal_uuid() const {
  return uuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SClosePlayer::uuid() const {
  // @@protoc_insertion_point(field_get:protocol.SClosePlayer.uuid)
  return _internal_uuid();
}
inline void SClosePlayer::_internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  uuid_ = value;
}
inline void SClosePlayer::set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:protocol.SClosePlayer.uuid)
}

// -------------------------------------------------------------------

// UnitState

// .protocol.Unit unit = 1;
inline bool UnitState::_internal_has_unit() const {
  return this != internal_default_instance() && unit_ != nullptr;
}
inline bool UnitState::has_unit() const {
  return _internal_has_unit();
}
inline void UnitState::clear_unit() {
  if (GetArenaForAllocation() == nullptr && unit_ != nullptr) {
    delete unit_;
  }
  unit_ = nullptr;
}
inline const ::protocol::Unit& UnitState::_internal_unit() const {
  const ::protocol::Unit* p = unit_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Unit&>(
      ::protocol::_Unit_default_instance_);
}
inline const ::protocol::Unit& UnitState::unit() const {
  // @@protoc_insertion_point(field_get:protocol.UnitState.unit)
  return _internal_unit();
}
inline void UnitState::unsafe_arena_set_allocated_unit(
    ::protocol::Unit* unit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(unit_);
  }
  unit_ = unit;
  if (unit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.UnitState.unit)
}
inline ::protocol::Unit* UnitState::release_unit() {
  
  ::protocol::Unit* temp = unit_;
  unit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Unit* UnitState::unsafe_arena_release_unit() {
  // @@protoc_insertion_point(field_release:protocol.UnitState.unit)
  
  ::protocol::Unit* temp = unit_;
  unit_ = nullptr;
  return temp;
}
inline ::protocol::Unit* UnitState::_internal_mutable_unit() {
  
  if (unit_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Unit>(GetArenaForAllocation());
    unit_ = p;
  }
  return unit_;
}
inline ::protocol::Unit* UnitState::mutable_unit() {
  ::protocol::Unit* _msg = _internal_mutable_unit();
  // @@protoc_insertion_point(field_mutable:protocol.UnitState.unit)
  return _msg;
}
inline void UnitState::set_allocated_unit(::protocol::Unit* unit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete unit_;
  }
  if (unit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Unit>::GetOwningArena(unit);
    if (message_arena != submessage_arena) {
      unit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unit, submessage_arena);
    }
    
  } else {
    
  }
  unit_ = unit;
  // @@protoc_insertion_point(field_set_allocated:protocol.UnitState.unit)
}

// bool is_monster = 10;
inline void UnitState::clear_is_monster() {
  is_monster_ = false;
}
inline bool UnitState::_internal_is_monster() const {
  return is_monster_;
}
inline bool UnitState::is_monster() const {
  // @@protoc_insertion_point(field_get:protocol.UnitState.is_monster)
  return _internal_is_monster();
}
inline void UnitState::_internal_set_is_monster(bool value) {
  
  is_monster_ = value;
}
inline void UnitState::set_is_monster(bool value) {
  _internal_set_is_monster(value);
  // @@protoc_insertion_point(field_set:protocol.UnitState.is_monster)
}

// .protocol.Attack attack = 11;
inline bool UnitState::_internal_has_attack() const {
  return this != internal_default_instance() && attack_ != nullptr;
}
inline bool UnitState::has_attack() const {
  return _internal_has_attack();
}
inline void UnitState::clear_attack() {
  if (GetArenaForAllocation() == nullptr && attack_ != nullptr) {
    delete attack_;
  }
  attack_ = nullptr;
}
inline const ::protocol::Attack& UnitState::_internal_attack() const {
  const ::protocol::Attack* p = attack_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Attack&>(
      ::protocol::_Attack_default_instance_);
}
inline const ::protocol::Attack& UnitState::attack() const {
  // @@protoc_insertion_point(field_get:protocol.UnitState.attack)
  return _internal_attack();
}
inline void UnitState::unsafe_arena_set_allocated_attack(
    ::protocol::Attack* attack) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attack_);
  }
  attack_ = attack;
  if (attack) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.UnitState.attack)
}
inline ::protocol::Attack* UnitState::release_attack() {
  
  ::protocol::Attack* temp = attack_;
  attack_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Attack* UnitState::unsafe_arena_release_attack() {
  // @@protoc_insertion_point(field_release:protocol.UnitState.attack)
  
  ::protocol::Attack* temp = attack_;
  attack_ = nullptr;
  return temp;
}
inline ::protocol::Attack* UnitState::_internal_mutable_attack() {
  
  if (attack_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Attack>(GetArenaForAllocation());
    attack_ = p;
  }
  return attack_;
}
inline ::protocol::Attack* UnitState::mutable_attack() {
  ::protocol::Attack* _msg = _internal_mutable_attack();
  // @@protoc_insertion_point(field_mutable:protocol.UnitState.attack)
  return _msg;
}
inline void UnitState::set_allocated_attack(::protocol::Attack* attack) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete attack_;
  }
  if (attack) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Attack>::GetOwningArena(attack);
    if (message_arena != submessage_arena) {
      attack = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attack, submessage_arena);
    }
    
  } else {
    
  }
  attack_ = attack;
  // @@protoc_insertion_point(field_set_allocated:protocol.UnitState.attack)
}

// -------------------------------------------------------------------

// SUnitStates

// repeated .protocol.UnitState unit_state = 1;
inline int SUnitStates::_internal_unit_state_size() const {
  return unit_state_.size();
}
inline int SUnitStates::unit_state_size() const {
  return _internal_unit_state_size();
}
inline void SUnitStates::clear_unit_state() {
  unit_state_.Clear();
}
inline ::protocol::UnitState* SUnitStates::mutable_unit_state(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.SUnitStates.unit_state)
  return unit_state_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::UnitState >*
SUnitStates::mutable_unit_state() {
  // @@protoc_insertion_point(field_mutable_list:protocol.SUnitStates.unit_state)
  return &unit_state_;
}
inline const ::protocol::UnitState& SUnitStates::_internal_unit_state(int index) const {
  return unit_state_.Get(index);
}
inline const ::protocol::UnitState& SUnitStates::unit_state(int index) const {
  // @@protoc_insertion_point(field_get:protocol.SUnitStates.unit_state)
  return _internal_unit_state(index);
}
inline ::protocol::UnitState* SUnitStates::_internal_add_unit_state() {
  return unit_state_.Add();
}
inline ::protocol::UnitState* SUnitStates::add_unit_state() {
  ::protocol::UnitState* _add = _internal_add_unit_state();
  // @@protoc_insertion_point(field_add:protocol.SUnitStates.unit_state)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::UnitState >&
SUnitStates::unit_state() const {
  // @@protoc_insertion_point(field_list:protocol.SUnitStates.unit_state)
  return unit_state_;
}

// -------------------------------------------------------------------

// Attack

// int32 uuid = 1;
inline void Attack::clear_uuid() {
  uuid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Attack::_internal_uuid() const {
  return uuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Attack::uuid() const {
  // @@protoc_insertion_point(field_get:protocol.Attack.uuid)
  return _internal_uuid();
}
inline void Attack::_internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  uuid_ = value;
}
inline void Attack::set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:protocol.Attack.uuid)
}

// int32 skill_code = 2;
inline void Attack::clear_skill_code() {
  skill_code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Attack::_internal_skill_code() const {
  return skill_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Attack::skill_code() const {
  // @@protoc_insertion_point(field_get:protocol.Attack.skill_code)
  return _internal_skill_code();
}
inline void Attack::_internal_set_skill_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  skill_code_ = value;
}
inline void Attack::set_skill_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_skill_code(value);
  // @@protoc_insertion_point(field_set:protocol.Attack.skill_code)
}

// int32 target_uuid = 3;
inline void Attack::clear_target_uuid() {
  target_uuid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Attack::_internal_target_uuid() const {
  return target_uuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Attack::target_uuid() const {
  // @@protoc_insertion_point(field_get:protocol.Attack.target_uuid)
  return _internal_target_uuid();
}
inline void Attack::_internal_set_target_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  target_uuid_ = value;
}
inline void Attack::set_target_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_target_uuid(value);
  // @@protoc_insertion_point(field_set:protocol.Attack.target_uuid)
}

// -------------------------------------------------------------------

// CAttack

// int32 uuid = 1;
inline void CAttack::clear_uuid() {
  uuid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CAttack::_internal_uuid() const {
  return uuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CAttack::uuid() const {
  // @@protoc_insertion_point(field_get:protocol.CAttack.uuid)
  return _internal_uuid();
}
inline void CAttack::_internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  uuid_ = value;
}
inline void CAttack::set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:protocol.CAttack.uuid)
}

// int32 skill_code = 2;
inline void CAttack::clear_skill_code() {
  skill_code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CAttack::_internal_skill_code() const {
  return skill_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CAttack::skill_code() const {
  // @@protoc_insertion_point(field_get:protocol.CAttack.skill_code)
  return _internal_skill_code();
}
inline void CAttack::_internal_set_skill_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  skill_code_ = value;
}
inline void CAttack::set_skill_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_skill_code(value);
  // @@protoc_insertion_point(field_set:protocol.CAttack.skill_code)
}

// int32 target_uuid = 3;
inline void CAttack::clear_target_uuid() {
  target_uuid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CAttack::_internal_target_uuid() const {
  return target_uuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CAttack::target_uuid() const {
  // @@protoc_insertion_point(field_get:protocol.CAttack.target_uuid)
  return _internal_target_uuid();
}
inline void CAttack::_internal_set_target_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  target_uuid_ = value;
}
inline void CAttack::set_target_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_target_uuid(value);
  // @@protoc_insertion_point(field_set:protocol.CAttack.target_uuid)
}

// .protocol.Position position = 4;
inline bool CAttack::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool CAttack::has_position() const {
  return _internal_has_position();
}
inline void CAttack::clear_position() {
  if (GetArenaForAllocation() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::protocol::Position& CAttack::_internal_position() const {
  const ::protocol::Position* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Position&>(
      ::protocol::_Position_default_instance_);
}
inline const ::protocol::Position& CAttack::position() const {
  // @@protoc_insertion_point(field_get:protocol.CAttack.position)
  return _internal_position();
}
inline void CAttack::unsafe_arena_set_allocated_position(
    ::protocol::Position* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.CAttack.position)
}
inline ::protocol::Position* CAttack::release_position() {
  
  ::protocol::Position* temp = position_;
  position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Position* CAttack::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:protocol.CAttack.position)
  
  ::protocol::Position* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::protocol::Position* CAttack::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Position>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::protocol::Position* CAttack::mutable_position() {
  ::protocol::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:protocol.CAttack.position)
  return _msg;
}
inline void CAttack::set_allocated_position(::protocol::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Position>::GetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:protocol.CAttack.position)
}

// -------------------------------------------------------------------

// Demage

// int32 uuid = 1;
inline void Demage::clear_uuid() {
  uuid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Demage::_internal_uuid() const {
  return uuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Demage::uuid() const {
  // @@protoc_insertion_point(field_get:protocol.Demage.uuid)
  return _internal_uuid();
}
inline void Demage::_internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  uuid_ = value;
}
inline void Demage::set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:protocol.Demage.uuid)
}

// int32 demage = 2;
inline void Demage::clear_demage() {
  demage_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Demage::_internal_demage() const {
  return demage_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Demage::demage() const {
  // @@protoc_insertion_point(field_get:protocol.Demage.demage)
  return _internal_demage();
}
inline void Demage::_internal_set_demage(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  demage_ = value;
}
inline void Demage::set_demage(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_demage(value);
  // @@protoc_insertion_point(field_set:protocol.Demage.demage)
}

// .protocol.Position position = 3;
inline bool Demage::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool Demage::has_position() const {
  return _internal_has_position();
}
inline void Demage::clear_position() {
  if (GetArenaForAllocation() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::protocol::Position& Demage::_internal_position() const {
  const ::protocol::Position* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Position&>(
      ::protocol::_Position_default_instance_);
}
inline const ::protocol::Position& Demage::position() const {
  // @@protoc_insertion_point(field_get:protocol.Demage.position)
  return _internal_position();
}
inline void Demage::unsafe_arena_set_allocated_position(
    ::protocol::Position* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.Demage.position)
}
inline ::protocol::Position* Demage::release_position() {
  
  ::protocol::Position* temp = position_;
  position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Position* Demage::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:protocol.Demage.position)
  
  ::protocol::Position* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::protocol::Position* Demage::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Position>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::protocol::Position* Demage::mutable_position() {
  ::protocol::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:protocol.Demage.position)
  return _msg;
}
inline void Demage::set_allocated_position(::protocol::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Position>::GetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:protocol.Demage.position)
}

// bool is_heal = 4;
inline void Demage::clear_is_heal() {
  is_heal_ = false;
}
inline bool Demage::_internal_is_heal() const {
  return is_heal_;
}
inline bool Demage::is_heal() const {
  // @@protoc_insertion_point(field_get:protocol.Demage.is_heal)
  return _internal_is_heal();
}
inline void Demage::_internal_set_is_heal(bool value) {
  
  is_heal_ = value;
}
inline void Demage::set_is_heal(bool value) {
  _internal_set_is_heal(value);
  // @@protoc_insertion_point(field_set:protocol.Demage.is_heal)
}

// bool is_monster = 10;
inline void Demage::clear_is_monster() {
  is_monster_ = false;
}
inline bool Demage::_internal_is_monster() const {
  return is_monster_;
}
inline bool Demage::is_monster() const {
  // @@protoc_insertion_point(field_get:protocol.Demage.is_monster)
  return _internal_is_monster();
}
inline void Demage::_internal_set_is_monster(bool value) {
  
  is_monster_ = value;
}
inline void Demage::set_is_monster(bool value) {
  _internal_set_is_monster(value);
  // @@protoc_insertion_point(field_set:protocol.Demage.is_monster)
}

// -------------------------------------------------------------------

// SUnitDemage

// int32 uuid = 1;
inline void SUnitDemage::clear_uuid() {
  uuid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SUnitDemage::_internal_uuid() const {
  return uuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SUnitDemage::uuid() const {
  // @@protoc_insertion_point(field_get:protocol.SUnitDemage.uuid)
  return _internal_uuid();
}
inline void SUnitDemage::_internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  uuid_ = value;
}
inline void SUnitDemage::set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:protocol.SUnitDemage.uuid)
}

// bool is_monster = 2;
inline void SUnitDemage::clear_is_monster() {
  is_monster_ = false;
}
inline bool SUnitDemage::_internal_is_monster() const {
  return is_monster_;
}
inline bool SUnitDemage::is_monster() const {
  // @@protoc_insertion_point(field_get:protocol.SUnitDemage.is_monster)
  return _internal_is_monster();
}
inline void SUnitDemage::_internal_set_is_monster(bool value) {
  
  is_monster_ = value;
}
inline void SUnitDemage::set_is_monster(bool value) {
  _internal_set_is_monster(value);
  // @@protoc_insertion_point(field_set:protocol.SUnitDemage.is_monster)
}

// repeated .protocol.Demage demage = 3;
inline int SUnitDemage::_internal_demage_size() const {
  return demage_.size();
}
inline int SUnitDemage::demage_size() const {
  return _internal_demage_size();
}
inline void SUnitDemage::clear_demage() {
  demage_.Clear();
}
inline ::protocol::Demage* SUnitDemage::mutable_demage(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.SUnitDemage.demage)
  return demage_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Demage >*
SUnitDemage::mutable_demage() {
  // @@protoc_insertion_point(field_mutable_list:protocol.SUnitDemage.demage)
  return &demage_;
}
inline const ::protocol::Demage& SUnitDemage::_internal_demage(int index) const {
  return demage_.Get(index);
}
inline const ::protocol::Demage& SUnitDemage::demage(int index) const {
  // @@protoc_insertion_point(field_get:protocol.SUnitDemage.demage)
  return _internal_demage(index);
}
inline ::protocol::Demage* SUnitDemage::_internal_add_demage() {
  return demage_.Add();
}
inline ::protocol::Demage* SUnitDemage::add_demage() {
  ::protocol::Demage* _add = _internal_add_demage();
  // @@protoc_insertion_point(field_add:protocol.SUnitDemage.demage)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Demage >&
SUnitDemage::demage() const {
  // @@protoc_insertion_point(field_list:protocol.SUnitDemage.demage)
  return demage_;
}

// -------------------------------------------------------------------

// SRoomQuest

// bool is_clear = 1;
inline void SRoomQuest::clear_is_clear() {
  is_clear_ = false;
}
inline bool SRoomQuest::_internal_is_clear() const {
  return is_clear_;
}
inline bool SRoomQuest::is_clear() const {
  // @@protoc_insertion_point(field_get:protocol.SRoomQuest.is_clear)
  return _internal_is_clear();
}
inline void SRoomQuest::_internal_set_is_clear(bool value) {
  
  is_clear_ = value;
}
inline void SRoomQuest::set_is_clear(bool value) {
  _internal_set_is_clear(value);
  // @@protoc_insertion_point(field_set:protocol.SRoomQuest.is_clear)
}

// int32 kill_count = 2;
inline void SRoomQuest::clear_kill_count() {
  kill_count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SRoomQuest::_internal_kill_count() const {
  return kill_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SRoomQuest::kill_count() const {
  // @@protoc_insertion_point(field_get:protocol.SRoomQuest.kill_count)
  return _internal_kill_count();
}
inline void SRoomQuest::_internal_set_kill_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  kill_count_ = value;
}
inline void SRoomQuest::set_kill_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_kill_count(value);
  // @@protoc_insertion_point(field_set:protocol.SRoomQuest.kill_count)
}

// int32 sum_kill = 3;
inline void SRoomQuest::clear_sum_kill() {
  sum_kill_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SRoomQuest::_internal_sum_kill() const {
  return sum_kill_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SRoomQuest::sum_kill() const {
  // @@protoc_insertion_point(field_get:protocol.SRoomQuest.sum_kill)
  return _internal_sum_kill();
}
inline void SRoomQuest::_internal_set_sum_kill(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  sum_kill_ = value;
}
inline void SRoomQuest::set_sum_kill(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_sum_kill(value);
  // @@protoc_insertion_point(field_set:protocol.SRoomQuest.sum_kill)
}

// -------------------------------------------------------------------

// CMovePotal

// int32 pre_room_id = 1;
inline void CMovePotal::clear_pre_room_id() {
  pre_room_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CMovePotal::_internal_pre_room_id() const {
  return pre_room_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CMovePotal::pre_room_id() const {
  // @@protoc_insertion_point(field_get:protocol.CMovePotal.pre_room_id)
  return _internal_pre_room_id();
}
inline void CMovePotal::_internal_set_pre_room_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  pre_room_id_ = value;
}
inline void CMovePotal::set_pre_room_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_pre_room_id(value);
  // @@protoc_insertion_point(field_set:protocol.CMovePotal.pre_room_id)
}

// int32 next_room_id = 2;
inline void CMovePotal::clear_next_room_id() {
  next_room_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CMovePotal::_internal_next_room_id() const {
  return next_room_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CMovePotal::next_room_id() const {
  // @@protoc_insertion_point(field_get:protocol.CMovePotal.next_room_id)
  return _internal_next_room_id();
}
inline void CMovePotal::_internal_set_next_room_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  next_room_id_ = value;
}
inline void CMovePotal::set_next_room_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_next_room_id(value);
  // @@protoc_insertion_point(field_set:protocol.CMovePotal.next_room_id)
}

// -------------------------------------------------------------------

// SEndGame

// bool end_game = 1;
inline void SEndGame::clear_end_game() {
  end_game_ = false;
}
inline bool SEndGame::_internal_end_game() const {
  return end_game_;
}
inline bool SEndGame::end_game() const {
  // @@protoc_insertion_point(field_get:protocol.SEndGame.end_game)
  return _internal_end_game();
}
inline void SEndGame::_internal_set_end_game(bool value) {
  
  end_game_ = value;
}
inline void SEndGame::set_end_game(bool value) {
  _internal_set_end_game(value);
  // @@protoc_insertion_point(field_set:protocol.SEndGame.end_game)
}

// -------------------------------------------------------------------

// CBuyCharater

// int32 CharaterType = 1;
inline void CBuyCharater::clear_charatertype() {
  charatertype_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CBuyCharater::_internal_charatertype() const {
  return charatertype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CBuyCharater::charatertype() const {
  // @@protoc_insertion_point(field_get:protocol.CBuyCharater.CharaterType)
  return _internal_charatertype();
}
inline void CBuyCharater::_internal_set_charatertype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  charatertype_ = value;
}
inline void CBuyCharater::set_charatertype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_charatertype(value);
  // @@protoc_insertion_point(field_set:protocol.CBuyCharater.CharaterType)
}

// int32 useCash = 2;
inline void CBuyCharater::clear_usecash() {
  usecash_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CBuyCharater::_internal_usecash() const {
  return usecash_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CBuyCharater::usecash() const {
  // @@protoc_insertion_point(field_get:protocol.CBuyCharater.useCash)
  return _internal_usecash();
}
inline void CBuyCharater::_internal_set_usecash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  usecash_ = value;
}
inline void CBuyCharater::set_usecash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_usecash(value);
  // @@protoc_insertion_point(field_set:protocol.CBuyCharater.useCash)
}

// string name = 3;
inline void CBuyCharater::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CBuyCharater::name() const {
  // @@protoc_insertion_point(field_get:protocol.CBuyCharater.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CBuyCharater::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.CBuyCharater.name)
}
inline std::string* CBuyCharater::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:protocol.CBuyCharater.name)
  return _s;
}
inline const std::string& CBuyCharater::_internal_name() const {
  return name_.Get();
}
inline void CBuyCharater::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CBuyCharater::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CBuyCharater::release_name() {
  // @@protoc_insertion_point(field_release:protocol.CBuyCharater.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CBuyCharater::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.CBuyCharater.name)
}

// -------------------------------------------------------------------

// CBuyWeapon

// int32 weaponType = 1;
inline void CBuyWeapon::clear_weapontype() {
  weapontype_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CBuyWeapon::_internal_weapontype() const {
  return weapontype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CBuyWeapon::weapontype() const {
  // @@protoc_insertion_point(field_get:protocol.CBuyWeapon.weaponType)
  return _internal_weapontype();
}
inline void CBuyWeapon::_internal_set_weapontype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  weapontype_ = value;
}
inline void CBuyWeapon::set_weapontype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_weapontype(value);
  // @@protoc_insertion_point(field_set:protocol.CBuyWeapon.weaponType)
}

// int32 useCash = 2;
inline void CBuyWeapon::clear_usecash() {
  usecash_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CBuyWeapon::_internal_usecash() const {
  return usecash_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CBuyWeapon::usecash() const {
  // @@protoc_insertion_point(field_get:protocol.CBuyWeapon.useCash)
  return _internal_usecash();
}
inline void CBuyWeapon::_internal_set_usecash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  usecash_ = value;
}
inline void CBuyWeapon::set_usecash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_usecash(value);
  // @@protoc_insertion_point(field_set:protocol.CBuyWeapon.useCash)
}

// -------------------------------------------------------------------

// SBuyResult

// int32 result = 1;
inline void SBuyResult::clear_result() {
  result_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SBuyResult::_internal_result() const {
  return result_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SBuyResult::result() const {
  // @@protoc_insertion_point(field_get:protocol.SBuyResult.result)
  return _internal_result();
}
inline void SBuyResult::_internal_set_result(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  result_ = value;
}
inline void SBuyResult::set_result(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:protocol.SBuyResult.result)
}

// repeated .protocol.Charater charater = 2;
inline int SBuyResult::_internal_charater_size() const {
  return charater_.size();
}
inline int SBuyResult::charater_size() const {
  return _internal_charater_size();
}
inline void SBuyResult::clear_charater() {
  charater_.Clear();
}
inline ::protocol::Charater* SBuyResult::mutable_charater(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.SBuyResult.charater)
  return charater_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Charater >*
SBuyResult::mutable_charater() {
  // @@protoc_insertion_point(field_mutable_list:protocol.SBuyResult.charater)
  return &charater_;
}
inline const ::protocol::Charater& SBuyResult::_internal_charater(int index) const {
  return charater_.Get(index);
}
inline const ::protocol::Charater& SBuyResult::charater(int index) const {
  // @@protoc_insertion_point(field_get:protocol.SBuyResult.charater)
  return _internal_charater(index);
}
inline ::protocol::Charater* SBuyResult::_internal_add_charater() {
  return charater_.Add();
}
inline ::protocol::Charater* SBuyResult::add_charater() {
  ::protocol::Charater* _add = _internal_add_charater();
  // @@protoc_insertion_point(field_add:protocol.SBuyResult.charater)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Charater >&
SBuyResult::charater() const {
  // @@protoc_insertion_point(field_list:protocol.SBuyResult.charater)
  return charater_;
}

// int32 curCharaterType = 3;
inline void SBuyResult::clear_curcharatertype() {
  curcharatertype_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SBuyResult::_internal_curcharatertype() const {
  return curcharatertype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SBuyResult::curcharatertype() const {
  // @@protoc_insertion_point(field_get:protocol.SBuyResult.curCharaterType)
  return _internal_curcharatertype();
}
inline void SBuyResult::_internal_set_curcharatertype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  curcharatertype_ = value;
}
inline void SBuyResult::set_curcharatertype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_curcharatertype(value);
  // @@protoc_insertion_point(field_set:protocol.SBuyResult.curCharaterType)
}

// int32 curWeaponType = 4;
inline void SBuyResult::clear_curweapontype() {
  curweapontype_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SBuyResult::_internal_curweapontype() const {
  return curweapontype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SBuyResult::curweapontype() const {
  // @@protoc_insertion_point(field_get:protocol.SBuyResult.curWeaponType)
  return _internal_curweapontype();
}
inline void SBuyResult::_internal_set_curweapontype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  curweapontype_ = value;
}
inline void SBuyResult::set_curweapontype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_curweapontype(value);
  // @@protoc_insertion_point(field_set:protocol.SBuyResult.curWeaponType)
}

// int32 cash = 5;
inline void SBuyResult::clear_cash() {
  cash_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SBuyResult::_internal_cash() const {
  return cash_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SBuyResult::cash() const {
  // @@protoc_insertion_point(field_get:protocol.SBuyResult.cash)
  return _internal_cash();
}
inline void SBuyResult::_internal_set_cash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  cash_ = value;
}
inline void SBuyResult::set_cash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cash(value);
  // @@protoc_insertion_point(field_set:protocol.SBuyResult.cash)
}

// repeated int32 weaponList = 6;
inline int SBuyResult::_internal_weaponlist_size() const {
  return weaponlist_.size();
}
inline int SBuyResult::weaponlist_size() const {
  return _internal_weaponlist_size();
}
inline void SBuyResult::clear_weaponlist() {
  weaponlist_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SBuyResult::_internal_weaponlist(int index) const {
  return weaponlist_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SBuyResult::weaponlist(int index) const {
  // @@protoc_insertion_point(field_get:protocol.SBuyResult.weaponList)
  return _internal_weaponlist(index);
}
inline void SBuyResult::set_weaponlist(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  weaponlist_.Set(index, value);
  // @@protoc_insertion_point(field_set:protocol.SBuyResult.weaponList)
}
inline void SBuyResult::_internal_add_weaponlist(::PROTOBUF_NAMESPACE_ID::int32 value) {
  weaponlist_.Add(value);
}
inline void SBuyResult::add_weaponlist(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_weaponlist(value);
  // @@protoc_insertion_point(field_add:protocol.SBuyResult.weaponList)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
SBuyResult::_internal_weaponlist() const {
  return weaponlist_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
SBuyResult::weaponlist() const {
  // @@protoc_insertion_point(field_list:protocol.SBuyResult.weaponList)
  return _internal_weaponlist();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
SBuyResult::_internal_mutable_weaponlist() {
  return &weaponlist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
SBuyResult::mutable_weaponlist() {
  // @@protoc_insertion_point(field_mutable_list:protocol.SBuyResult.weaponList)
  return _internal_mutable_weaponlist();
}

// -------------------------------------------------------------------

// CPlayerJump

// bool isJump = 1;
inline void CPlayerJump::clear_isjump() {
  isjump_ = false;
}
inline bool CPlayerJump::_internal_isjump() const {
  return isjump_;
}
inline bool CPlayerJump::isjump() const {
  // @@protoc_insertion_point(field_get:protocol.CPlayerJump.isJump)
  return _internal_isjump();
}
inline void CPlayerJump::_internal_set_isjump(bool value) {
  
  isjump_ = value;
}
inline void CPlayerJump::set_isjump(bool value) {
  _internal_set_isjump(value);
  // @@protoc_insertion_point(field_set:protocol.CPlayerJump.isJump)
}

// int32 uuid = 2;
inline void CPlayerJump::clear_uuid() {
  uuid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CPlayerJump::_internal_uuid() const {
  return uuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CPlayerJump::uuid() const {
  // @@protoc_insertion_point(field_get:protocol.CPlayerJump.uuid)
  return _internal_uuid();
}
inline void CPlayerJump::_internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  uuid_ = value;
}
inline void CPlayerJump::set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:protocol.CPlayerJump.uuid)
}

// -------------------------------------------------------------------

// CPlayerAim

// bool isAim = 1;
inline void CPlayerAim::clear_isaim() {
  isaim_ = false;
}
inline bool CPlayerAim::_internal_isaim() const {
  return isaim_;
}
inline bool CPlayerAim::isaim() const {
  // @@protoc_insertion_point(field_get:protocol.CPlayerAim.isAim)
  return _internal_isaim();
}
inline void CPlayerAim::_internal_set_isaim(bool value) {
  
  isaim_ = value;
}
inline void CPlayerAim::set_isaim(bool value) {
  _internal_set_isaim(value);
  // @@protoc_insertion_point(field_set:protocol.CPlayerAim.isAim)
}

// int32 uuid = 2;
inline void CPlayerAim::clear_uuid() {
  uuid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CPlayerAim::_internal_uuid() const {
  return uuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CPlayerAim::uuid() const {
  // @@protoc_insertion_point(field_get:protocol.CPlayerAim.uuid)
  return _internal_uuid();
}
inline void CPlayerAim::_internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  uuid_ = value;
}
inline void CPlayerAim::set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:protocol.CPlayerAim.uuid)
}

// -------------------------------------------------------------------

// SExpLv

// int32 uuid = 1;
inline void SExpLv::clear_uuid() {
  uuid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SExpLv::_internal_uuid() const {
  return uuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SExpLv::uuid() const {
  // @@protoc_insertion_point(field_get:protocol.SExpLv.uuid)
  return _internal_uuid();
}
inline void SExpLv::_internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  uuid_ = value;
}
inline void SExpLv::set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:protocol.SExpLv.uuid)
}

// int32 lv = 2;
inline void SExpLv::clear_lv() {
  lv_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SExpLv::_internal_lv() const {
  return lv_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SExpLv::lv() const {
  // @@protoc_insertion_point(field_get:protocol.SExpLv.lv)
  return _internal_lv();
}
inline void SExpLv::_internal_set_lv(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  lv_ = value;
}
inline void SExpLv::set_lv(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_lv(value);
  // @@protoc_insertion_point(field_set:protocol.SExpLv.lv)
}

// int32 exp = 3;
inline void SExpLv::clear_exp() {
  exp_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SExpLv::_internal_exp() const {
  return exp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SExpLv::exp() const {
  // @@protoc_insertion_point(field_get:protocol.SExpLv.exp)
  return _internal_exp();
}
inline void SExpLv::_internal_set_exp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  exp_ = value;
}
inline void SExpLv::set_exp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:protocol.SExpLv.exp)
}

// -------------------------------------------------------------------

// ItemEquip

// int32 item_code = 1;
inline void ItemEquip::clear_item_code() {
  item_code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ItemEquip::_internal_item_code() const {
  return item_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ItemEquip::item_code() const {
  // @@protoc_insertion_point(field_get:protocol.ItemEquip.item_code)
  return _internal_item_code();
}
inline void ItemEquip::_internal_set_item_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  item_code_ = value;
}
inline void ItemEquip::set_item_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_item_code(value);
  // @@protoc_insertion_point(field_set:protocol.ItemEquip.item_code)
}

// -------------------------------------------------------------------

// ItemEtc

// int32 item_code = 1;
inline void ItemEtc::clear_item_code() {
  item_code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ItemEtc::_internal_item_code() const {
  return item_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ItemEtc::item_code() const {
  // @@protoc_insertion_point(field_get:protocol.ItemEtc.item_code)
  return _internal_item_code();
}
inline void ItemEtc::_internal_set_item_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  item_code_ = value;
}
inline void ItemEtc::set_item_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_item_code(value);
  // @@protoc_insertion_point(field_set:protocol.ItemEtc.item_code)
}

// int32 item_count = 2;
inline void ItemEtc::clear_item_count() {
  item_count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ItemEtc::_internal_item_count() const {
  return item_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ItemEtc::item_count() const {
  // @@protoc_insertion_point(field_get:protocol.ItemEtc.item_count)
  return _internal_item_count();
}
inline void ItemEtc::_internal_set_item_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  item_count_ = value;
}
inline void ItemEtc::set_item_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_item_count(value);
  // @@protoc_insertion_point(field_set:protocol.ItemEtc.item_count)
}

// -------------------------------------------------------------------

// DropMessage

// repeated .protocol.ItemEquip itemEquips = 1;
inline int DropMessage::_internal_itemequips_size() const {
  return itemequips_.size();
}
inline int DropMessage::itemequips_size() const {
  return _internal_itemequips_size();
}
inline void DropMessage::clear_itemequips() {
  itemequips_.Clear();
}
inline ::protocol::ItemEquip* DropMessage::mutable_itemequips(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.DropMessage.itemEquips)
  return itemequips_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >*
DropMessage::mutable_itemequips() {
  // @@protoc_insertion_point(field_mutable_list:protocol.DropMessage.itemEquips)
  return &itemequips_;
}
inline const ::protocol::ItemEquip& DropMessage::_internal_itemequips(int index) const {
  return itemequips_.Get(index);
}
inline const ::protocol::ItemEquip& DropMessage::itemequips(int index) const {
  // @@protoc_insertion_point(field_get:protocol.DropMessage.itemEquips)
  return _internal_itemequips(index);
}
inline ::protocol::ItemEquip* DropMessage::_internal_add_itemequips() {
  return itemequips_.Add();
}
inline ::protocol::ItemEquip* DropMessage::add_itemequips() {
  ::protocol::ItemEquip* _add = _internal_add_itemequips();
  // @@protoc_insertion_point(field_add:protocol.DropMessage.itemEquips)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >&
DropMessage::itemequips() const {
  // @@protoc_insertion_point(field_list:protocol.DropMessage.itemEquips)
  return itemequips_;
}

// repeated .protocol.ItemEtc itemEtcs = 2;
inline int DropMessage::_internal_itemetcs_size() const {
  return itemetcs_.size();
}
inline int DropMessage::itemetcs_size() const {
  return _internal_itemetcs_size();
}
inline void DropMessage::clear_itemetcs() {
  itemetcs_.Clear();
}
inline ::protocol::ItemEtc* DropMessage::mutable_itemetcs(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.DropMessage.itemEtcs)
  return itemetcs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEtc >*
DropMessage::mutable_itemetcs() {
  // @@protoc_insertion_point(field_mutable_list:protocol.DropMessage.itemEtcs)
  return &itemetcs_;
}
inline const ::protocol::ItemEtc& DropMessage::_internal_itemetcs(int index) const {
  return itemetcs_.Get(index);
}
inline const ::protocol::ItemEtc& DropMessage::itemetcs(int index) const {
  // @@protoc_insertion_point(field_get:protocol.DropMessage.itemEtcs)
  return _internal_itemetcs(index);
}
inline ::protocol::ItemEtc* DropMessage::_internal_add_itemetcs() {
  return itemetcs_.Add();
}
inline ::protocol::ItemEtc* DropMessage::add_itemetcs() {
  ::protocol::ItemEtc* _add = _internal_add_itemetcs();
  // @@protoc_insertion_point(field_add:protocol.DropMessage.itemEtcs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEtc >&
DropMessage::itemetcs() const {
  // @@protoc_insertion_point(field_list:protocol.DropMessage.itemEtcs)
  return itemetcs_;
}

// int32 gold = 3;
inline void DropMessage::clear_gold() {
  gold_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DropMessage::_internal_gold() const {
  return gold_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DropMessage::gold() const {
  // @@protoc_insertion_point(field_get:protocol.DropMessage.gold)
  return _internal_gold();
}
inline void DropMessage::_internal_set_gold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  gold_ = value;
}
inline void DropMessage::set_gold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:protocol.DropMessage.gold)
}

// -------------------------------------------------------------------

// SLoadInventory

// repeated .protocol.ItemEquip itemEquips = 1;
inline int SLoadInventory::_internal_itemequips_size() const {
  return itemequips_.size();
}
inline int SLoadInventory::itemequips_size() const {
  return _internal_itemequips_size();
}
inline void SLoadInventory::clear_itemequips() {
  itemequips_.Clear();
}
inline ::protocol::ItemEquip* SLoadInventory::mutable_itemequips(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.SLoadInventory.itemEquips)
  return itemequips_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >*
SLoadInventory::mutable_itemequips() {
  // @@protoc_insertion_point(field_mutable_list:protocol.SLoadInventory.itemEquips)
  return &itemequips_;
}
inline const ::protocol::ItemEquip& SLoadInventory::_internal_itemequips(int index) const {
  return itemequips_.Get(index);
}
inline const ::protocol::ItemEquip& SLoadInventory::itemequips(int index) const {
  // @@protoc_insertion_point(field_get:protocol.SLoadInventory.itemEquips)
  return _internal_itemequips(index);
}
inline ::protocol::ItemEquip* SLoadInventory::_internal_add_itemequips() {
  return itemequips_.Add();
}
inline ::protocol::ItemEquip* SLoadInventory::add_itemequips() {
  ::protocol::ItemEquip* _add = _internal_add_itemequips();
  // @@protoc_insertion_point(field_add:protocol.SLoadInventory.itemEquips)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >&
SLoadInventory::itemequips() const {
  // @@protoc_insertion_point(field_list:protocol.SLoadInventory.itemEquips)
  return itemequips_;
}

// repeated .protocol.ItemEtc itemEtcs = 2;
inline int SLoadInventory::_internal_itemetcs_size() const {
  return itemetcs_.size();
}
inline int SLoadInventory::itemetcs_size() const {
  return _internal_itemetcs_size();
}
inline void SLoadInventory::clear_itemetcs() {
  itemetcs_.Clear();
}
inline ::protocol::ItemEtc* SLoadInventory::mutable_itemetcs(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.SLoadInventory.itemEtcs)
  return itemetcs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEtc >*
SLoadInventory::mutable_itemetcs() {
  // @@protoc_insertion_point(field_mutable_list:protocol.SLoadInventory.itemEtcs)
  return &itemetcs_;
}
inline const ::protocol::ItemEtc& SLoadInventory::_internal_itemetcs(int index) const {
  return itemetcs_.Get(index);
}
inline const ::protocol::ItemEtc& SLoadInventory::itemetcs(int index) const {
  // @@protoc_insertion_point(field_get:protocol.SLoadInventory.itemEtcs)
  return _internal_itemetcs(index);
}
inline ::protocol::ItemEtc* SLoadInventory::_internal_add_itemetcs() {
  return itemetcs_.Add();
}
inline ::protocol::ItemEtc* SLoadInventory::add_itemetcs() {
  ::protocol::ItemEtc* _add = _internal_add_itemetcs();
  // @@protoc_insertion_point(field_add:protocol.SLoadInventory.itemEtcs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEtc >&
SLoadInventory::itemetcs() const {
  // @@protoc_insertion_point(field_list:protocol.SLoadInventory.itemEtcs)
  return itemetcs_;
}

// int32 gold = 3;
inline void SLoadInventory::clear_gold() {
  gold_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SLoadInventory::_internal_gold() const {
  return gold_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SLoadInventory::gold() const {
  // @@protoc_insertion_point(field_get:protocol.SLoadInventory.gold)
  return _internal_gold();
}
inline void SLoadInventory::_internal_set_gold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  gold_ = value;
}
inline void SLoadInventory::set_gold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:protocol.SLoadInventory.gold)
}

// -------------------------------------------------------------------

// CSellItems

// repeated .protocol.ItemEquip itemEquips = 1;
inline int CSellItems::_internal_itemequips_size() const {
  return itemequips_.size();
}
inline int CSellItems::itemequips_size() const {
  return _internal_itemequips_size();
}
inline void CSellItems::clear_itemequips() {
  itemequips_.Clear();
}
inline ::protocol::ItemEquip* CSellItems::mutable_itemequips(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.CSellItems.itemEquips)
  return itemequips_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >*
CSellItems::mutable_itemequips() {
  // @@protoc_insertion_point(field_mutable_list:protocol.CSellItems.itemEquips)
  return &itemequips_;
}
inline const ::protocol::ItemEquip& CSellItems::_internal_itemequips(int index) const {
  return itemequips_.Get(index);
}
inline const ::protocol::ItemEquip& CSellItems::itemequips(int index) const {
  // @@protoc_insertion_point(field_get:protocol.CSellItems.itemEquips)
  return _internal_itemequips(index);
}
inline ::protocol::ItemEquip* CSellItems::_internal_add_itemequips() {
  return itemequips_.Add();
}
inline ::protocol::ItemEquip* CSellItems::add_itemequips() {
  ::protocol::ItemEquip* _add = _internal_add_itemequips();
  // @@protoc_insertion_point(field_add:protocol.CSellItems.itemEquips)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEquip >&
CSellItems::itemequips() const {
  // @@protoc_insertion_point(field_list:protocol.CSellItems.itemEquips)
  return itemequips_;
}

// repeated .protocol.ItemEtc itemEtcs = 2;
inline int CSellItems::_internal_itemetcs_size() const {
  return itemetcs_.size();
}
inline int CSellItems::itemetcs_size() const {
  return _internal_itemetcs_size();
}
inline void CSellItems::clear_itemetcs() {
  itemetcs_.Clear();
}
inline ::protocol::ItemEtc* CSellItems::mutable_itemetcs(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.CSellItems.itemEtcs)
  return itemetcs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEtc >*
CSellItems::mutable_itemetcs() {
  // @@protoc_insertion_point(field_mutable_list:protocol.CSellItems.itemEtcs)
  return &itemetcs_;
}
inline const ::protocol::ItemEtc& CSellItems::_internal_itemetcs(int index) const {
  return itemetcs_.Get(index);
}
inline const ::protocol::ItemEtc& CSellItems::itemetcs(int index) const {
  // @@protoc_insertion_point(field_get:protocol.CSellItems.itemEtcs)
  return _internal_itemetcs(index);
}
inline ::protocol::ItemEtc* CSellItems::_internal_add_itemetcs() {
  return itemetcs_.Add();
}
inline ::protocol::ItemEtc* CSellItems::add_itemetcs() {
  ::protocol::ItemEtc* _add = _internal_add_itemetcs();
  // @@protoc_insertion_point(field_add:protocol.CSellItems.itemEtcs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ItemEtc >&
CSellItems::itemetcs() const {
  // @@protoc_insertion_point(field_list:protocol.CSellItems.itemEtcs)
  return itemetcs_;
}

// int32 gold = 3;
inline void CSellItems::clear_gold() {
  gold_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CSellItems::_internal_gold() const {
  return gold_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CSellItems::gold() const {
  // @@protoc_insertion_point(field_get:protocol.CSellItems.gold)
  return _internal_gold();
}
inline void CSellItems::_internal_set_gold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  gold_ = value;
}
inline void CSellItems::set_gold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:protocol.CSellItems.gold)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::protocol::MessageCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::MessageCode>() {
  return ::protocol::MessageCode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_GameService_2eproto
